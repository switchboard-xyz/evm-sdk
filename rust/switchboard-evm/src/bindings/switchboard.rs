pub use switchboard::*;
/// This module was auto-generated with ethers-rs Abigen.
/// More information at: <https://github.com/gakonst/ethers-rs>
#[allow(
    clippy::enum_variant_names,
    clippy::too_many_arguments,
    clippy::upper_case_acronyms,
    clippy::type_complexity,
    dead_code,
    non_camel_case_types
)]
pub mod switchboard {
    #[allow(deprecated)]
    fn __abi() -> ::ethers::core::abi::Abi {
        ::ethers::core::abi::ethabi::Contract {
            constructor: ::core::option::Option::None,
            functions: ::core::convert::From::from([
                (
                    ::std::borrow::ToOwned::to_owned("addMrEnclaveToAttestationQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "addMrEnclaveToAttestationQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("addMrEnclaveToFunction"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "addMrEnclaveToFunction",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("addMrEnclaveToOracleQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "addMrEnclaveToOracleQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("addStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("addStake"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("aggregatorEscrowFund"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "aggregatorEscrowFund",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("accountId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("aggregatorEscrowWithdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "aggregatorEscrowWithdraw",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("recipient"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address payable"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("aggregatorHistory"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("aggregatorHistory"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("roundId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(80usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint80"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct AggregatorLib.AggregatorHistoryResult",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("aggregators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("aggregators"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ],
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ],
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(80usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct AggregatorLib.Aggregator",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("allowance"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("allowance"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("owner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("spender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("approve"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("approve"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("spender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("attestationQueueHasMrEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "attestationQueueHasMrEnclave",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("attestationQueues"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("attestationQueues"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct AttestationQueueLib.AttestationQueue",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("balanceOf"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("balanceOf"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("account"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("callBalances"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("callBalances"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callIds"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("balances"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("callFunction"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("callFunction"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createAggregator"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("createAggregator"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("batchSize"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "minUpdateDelaySeconds",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("minOracleResults"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("jobsHash"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("varianceThreshold"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("minJobResults"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("forceReportPeriod"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enableHistory"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createAttestationQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "createAttestationQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("maxSize"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reward"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveTimeout"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "maxEnclaveVerificationAge",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "allowAuthorityOverrideAfter",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireAuthorityHeartbeatPermission",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireUsagePermissions",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "maxConsecutiveFunctionFailures",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("createEnclave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createEnclaveWithId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "createEnclaveWithId",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createFunction"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("createFunction"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("containerRegistry"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("container"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("version"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("schedule"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("paramsSchema"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("permittedCallers"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createFunctionWithId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "createFunctionWithId",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("containerRegistry"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("container"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("version"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("schedule"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("paramsSchema"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("permittedCallers"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createOracle"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("createOracle"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createOracleQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("createOracleQueue"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "unpermissionedFeedsEnabled",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("maxSize"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reward"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleTimeout"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createOracleWithId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("createOracleWithId"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("createRoutineWithId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "createRoutineWithId",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("schedule"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("diamondCut"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("diamondCut"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_diamondCut"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct IDiamondCut.FacetCut[]",
                                        ),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_init"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_calldata"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("enclaveGarbageCollect"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "enclaveGarbageCollect",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("enclaveHeartbeat"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("enclaveHeartbeat"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("enclaveSignerToEnclaveId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "enclaveSignerToEnclaveId",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("enclaves"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("enclaves"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct EnclaveLib.Enclave",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("estimatedRunCost"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("estimatedRunCost"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("gasPrice"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("facetAddress"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("facetAddress"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_functionSelector"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("facetAddress_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("facetAddresses"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("facetAddresses"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("facetAddresses_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("facetFunctionSelectors"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "facetFunctionSelectors",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_facet"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "facetFunctionSelectors_",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("facets"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("facets"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("facets_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct IDiamondLoupe.Facet[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("failEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("failEnclave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("verifierId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("verifierIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("failFunctionResult"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("failFunctionResult"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                ),
                                            ),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionVerifyLib.FunctionFailParams",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("forceOverrideVerify"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "forceOverrideVerify",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("forward"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("forward"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("transactions"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct TransactionLib.Transaction[]",
                                        ),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signatures"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("funcs"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("funcs"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                                        ),
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                                        ),
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                ],
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ],
                                            ),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionLib.SbFunction",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("functionCallSettings"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "functionCallSettings",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionCallLib.FunctionCallSettings",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("functionCalls"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("functionCalls"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionCallLib.FunctionCall",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("functionEscrowFund"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("functionEscrowFund"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("accountId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("functionEscrowWithdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "functionEscrowWithdraw",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("recipient"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address payable"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("functionExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("functionExists"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("functionSettings"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("functionSettings"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionSettingsLib.FunctionSettings",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("functionVerify"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("functionVerify"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "delegatedSignerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("observedTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "nextAllowedTimestamp",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isFailure"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("transactions"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct TransactionLib.Transaction[]",
                                        ),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signatures"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("functionVerifyRequest"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "functionVerifyRequest",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "delegatedSignerAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("observedTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "nextAllowedTimestamp",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("isFailure"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("transactions"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct TransactionLib.Transaction[]",
                                        ),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signatures"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionCallIds"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getActiveFunctionCallsByQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getActiveFunctionCallsByQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionCallLib.FunctionCall[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getActiveFunctionsByQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getActiveFunctionsByQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                                ::std::boxed::Box::new(
                                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                                ),
                                                            ),
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                                ::std::boxed::Box::new(
                                                                    ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                                                ),
                                                            ),
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                        ],
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ],
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionLib.SbFunction[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getActiveRequestsByQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getActiveRequestsByQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct RequestLib.Request[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getActiveRoutinesByQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getActiveRoutinesByQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct RoutineLib.Routine[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getAggregatorsByAuthority"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getAggregatorsByAuthority",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("user"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                                        ],
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ],
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(80usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct AggregatorLib.Aggregator[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getAllAggregators"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getAllAggregators"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                                        ],
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ],
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(80usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct AggregatorLib.Aggregator[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getAllFunctions"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getAllFunctions"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                                ::std::boxed::Box::new(
                                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                                ),
                                                            ),
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                                ::std::boxed::Box::new(
                                                                    ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                                                ),
                                                            ),
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                        ],
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ],
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionLib.SbFunction[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getAttestationQueueMrEnclaves"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getAttestationQueueMrEnclaves",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getCurrentIntervalId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getCurrentIntervalId",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("roundId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(80usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint80"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getEnclaveIdx"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getEnclaveIdx"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("int256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getEnclaves"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getEnclaves"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getFunctionMrEnclaves"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getFunctionMrEnclaves",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getFunctionPermittedCallers"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getFunctionPermittedCallers",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getFunctionsByAuthority"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getFunctionsByAuthority",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("user"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                                ::std::boxed::Box::new(
                                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                                ),
                                                            ),
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::String,
                                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                                ::std::boxed::Box::new(
                                                                    ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                                                ),
                                                            ),
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                        ],
                                                    ),
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                        ],
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionLib.SbFunction[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getIntervalResult"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getIntervalResult"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("intervalId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(80usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint80"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("int256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("medianTimestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getOracleIdx"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getOracleIdx"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("int256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getOracleQueueAllowedMrEnclaves"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getOracleQueueAllowedMrEnclaves",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getOracles"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getOracles"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getPermission"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getPermission"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("granter"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("grantee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getRequestsByFunctionId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getRequestsByFunctionId",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                    ::ethers::core::abi::ethabi::ParamType::Bool,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct RequestLib.Request[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getRoutinesByAuthority"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getRoutinesByAuthority",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct RoutineLib.Routine[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getRoutinesByFunctionId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getRoutinesByFunctionId",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::String,
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct RoutineLib.Routine[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getStakeForEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getStakeForEnclave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("struct StakingLib.Stake"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getStakeForEnclaveWithToken"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "getStakeForEnclaveWithToken",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("token"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("struct StakingLib.Stake"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getStakingConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getStakingConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct StakingLib.StakingConfig",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("getTransactionHash"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("getTransactionHash"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "expirationTimeSeconds",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("gasLimit"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("from"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("data"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("hasPermission"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("hasPermission"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("granter"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("grantee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("permission"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("init"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("init"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("initialize"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("initialize"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isAdmin"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isAdmin"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isAllowed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isAllowed"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isEnclaveValid"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isEnclaveValid"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("isTrustedForwarder"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("isTrustedForwarder"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Pure,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("latestResult"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("latestResult"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("int256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("openInterval"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("openInterval"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("oracleGarbageCollect"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "oracleGarbageCollect",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("oracleHeartbeat"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("oracleHeartbeat"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("oracleQueues"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("oracleQueues"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct OracleQueueLib.OracleQueue",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("oracles"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("oracles"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("struct OracleLib.Oracle"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("owner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("owner"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("owner_"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("prepareUnstake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("prepareUnstake"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("queueAttestationConfigs"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "queueAttestationConfigs",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct OracleQueueLib.AttestationConfig",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("recoverStakeWithToken"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "recoverStakeWithToken",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("token"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "removeMrEnclaveFromAttestationQueue",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "removeMrEnclaveFromAttestationQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("removeMrEnclaveFromFunction"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "removeMrEnclaveFromFunction",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("removeMrEnclaveFromOracleQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "removeMrEnclaveFromOracleQueue",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requestFund"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("requestFund"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("requestId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requestWithdrawal"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("requestWithdrawal"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("requestId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("recipient"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("requests"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("requests"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("requestId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct RequestLib.Request",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("rotateEnclaveSigner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "rotateEnclaveSigner",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newSigner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("rotateOracleSigner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("rotateOracleSigner"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("newSigner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("routineEscrowFund"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("routineEscrowFund"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("routineEscrowWithdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "routineEscrowWithdraw",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("routineExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("routineExists"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("routines"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("routines"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::String,
                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct RoutineLib.Routine",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("saveResults"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("saveResults"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("ids"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("results"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("int256[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("sendDelayedRequest"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("sendDelayedRequest"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("requestId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("startAfter"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("sendRequest"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("sendRequest"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("id"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("sendRequestWithId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("sendRequestWithId"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("requestId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("id"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setAdmin"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setAdmin"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("status"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setAggregatorConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setAggregatorConfig",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("batchSize"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "minUpdateDelaySeconds",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("minOracleResults"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("jobsHash"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("varianceThreshold"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("minJobResults"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("forceReportPeriod"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enableHistory"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setAllowed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setAllowed"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("status"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setAttestationQueueConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setAttestationQueueConfig",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("maxSize"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reward"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveTimeout"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "maxEnclaveVerificationAge",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "allowAuthorityOverrideAfter",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireAuthorityHeartbeatPermission",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireUsagePermissions",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "maxConsecutiveFunctionFailures",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setAttestationQueuePermission"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setAttestationQueuePermission",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("grantee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("permission"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("on"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setFunctionCallSettings"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setFunctionCallSettings",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireEstimatedRunCostFee",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("minimumFee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("maxGasCost"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireCallerPayFullCost",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireSenderBeReturnAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setFunctionConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setFunctionConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("containerRegistry"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("container"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("version"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("schedule"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("paramsSchema"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("permittedCallers"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setFunctionDeactivated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setFunctionDeactivated",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setFunctionSettings"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setFunctionSettings",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("settings"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Bool,
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionSettingsLib.FunctionSettings",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setOracleConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setOracleConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setOracleQueueAttestationConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setOracleQueueAttestationConfig",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "attestationQueueId",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclaves"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireValidEnclave",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "requireHeartbeatPermission",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setOracleQueueConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setOracleQueueConfig",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "unpermissionedFeedsEnabled",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("maxSize"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reward"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleTimeout"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setOracleQueuePermission"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setOracleQueuePermission",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("grantee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("permission"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("on"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setStakingConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("setStakingConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("token"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakingAmount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("stakingPeriod"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("unstakingPeriod"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("setToleratedTimestampDiscrepancy"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "setToleratedTimestampDiscrepancy",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("tolerance"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("slashStake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("slashStake"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("supportsInterface"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("supportsInterface"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_interfaceId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        4usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes4"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("totalStaked"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("totalStaked"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("token"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("totalSupply"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("totalSupply"),
                            inputs: ::std::vec![],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("transfer"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("transfer"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("transferFrom"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("transferFrom"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("from"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bool,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bool"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("transferOwnership"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("transferOwnership"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_newOwner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("unstake"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("unstake"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("updateEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("updateEnclave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("cid"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::Payable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("updateRoutine"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("updateRoutine"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("schedule"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("string"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("validate"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("validate"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "attestationQueueId",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("validMeasurements"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("verifyCallbackParams"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "verifyCallbackParams",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callIds"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address[]"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("hashes"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32[]"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("verifyEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("verifyEnclave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("verifierId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("verifyFunctionResult"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "verifyFunctionResult",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Tuple(
                                        ::std::vec![
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                        ::std::vec![
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                                            ::ethers::core::abi::ethabi::ParamType::Address,
                                                            ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                        ],
                                                    ),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Bytes,
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::FixedBytes(32usize),
                                                ),
                                            ),
                                            ::ethers::core::abi::ethabi::ParamType::Array(
                                                ::std::boxed::Box::new(
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                ),
                                            ),
                                        ],
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct FunctionVerifyLib.FunctionVerifyParams",
                                        ),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::NonPayable,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("viewAggregatorResults"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned(
                                "viewAggregatorResults",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::string::String::new(),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(256usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                ],
                                            ),
                                        ),
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned(
                                            "struct AggregatorLib.Result[]",
                                        ),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("viewLatestResult"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Function {
                            name: ::std::borrow::ToOwned::to_owned("viewLatestResult"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                            outputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("int256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("timestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                            constant: ::core::option::Option::None,
                            state_mutability: ::ethers::core::abi::ethabi::StateMutability::View,
                        },
                    ],
                ),
            ]),
            events: ::core::convert::From::from([
                (
                    ::std::borrow::ToOwned::to_owned("AddMrEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("AddMrEnclave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorAccountInit"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorAccountInit",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("accountId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("timestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorFundEvent"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorFundEvent",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("funder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorIntervalRefreshed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorIntervalRefreshed",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("intervalId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "balanceLeftForInterval",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorOpenInterval"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorOpenInterval",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("intervalId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorRead"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("AggregatorRead"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("reader"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorSaveResult"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorSaveResult",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("oracle"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorSettingsUpdated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorSettingsUpdated",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "minUpdateDelaySeconds",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("minOracleResults"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("varianceThreshold"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("minJobResults"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("forceReportPeriod"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorUpdate"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("AggregatorUpdate"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Int(256usize),
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("timestamp"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorWithdrawEvent"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorWithdrawEvent",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("funder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Approval"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("Approval"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("owner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("spender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AttestationQueueAccountInit"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AttestationQueueAccountInit",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("accountId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned(
                        "AttestationQueuePermissionUpdated",
                    ),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AttestationQueuePermissionUpdated",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("granter"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("grantee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("permission"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AttestationQueueSetConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AttestationQueueSetConfig",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("DiamondCut"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("DiamondCut"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("_diamondCut"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Array(
                                        ::std::boxed::Box::new(
                                            ::ethers::core::abi::ethabi::ParamType::Tuple(
                                                ::std::vec![
                                                    ::ethers::core::abi::ethabi::ParamType::Address,
                                                    ::ethers::core::abi::ethabi::ParamType::Uint(8usize),
                                                    ::ethers::core::abi::ethabi::ParamType::Array(
                                                        ::std::boxed::Box::new(
                                                            ::ethers::core::abi::ethabi::ParamType::FixedBytes(4usize),
                                                        ),
                                                    ),
                                                ],
                                            ),
                                        ),
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("_init"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("_calldata"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveAccountInit"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("EnclaveAccountInit"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("accountId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveGC"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("EnclaveGC"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queue"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveHeartbeat"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("EnclaveHeartbeat"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclavePayoutEvent"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("EnclavePayoutEvent"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("nodeId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveRotateSigner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "EnclaveRotateSigner",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("oldSigner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newSigner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveVerifyRequest"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "EnclaveVerifyRequest",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("verifier"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("verifiee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionAccountInit"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "FunctionAccountInit",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("accountId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionCallEvent"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("FunctionCallEvent"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionCallFund"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("FunctionCallFund"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("funder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionFund"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("FunctionFund"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("funder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionWithdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("FunctionWithdraw"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("withdrawer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleAccountInit"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("OracleAccountInit"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("accountId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleGC"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("OracleGC"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleHeartbeat"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("OracleHeartbeat"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OraclePayoutEvent"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("OraclePayoutEvent"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleQueueAccountInit"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleQueueAccountInit",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("accountId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleQueueAddMrEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleQueueAddMrEnclave",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "attestationQueueId",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleQueueRemoveMrEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleQueueRemoveMrEnclave",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "attestationQueueId",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleQueueSetAttestationConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleQueueSetAttestationConfig",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "attestationQueueId",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleQueueSetConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleQueueSetConfig",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleQueueSetPermission"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleQueueSetPermission",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("granter"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("grantee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("permission"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleRotateSigner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("OracleRotateSigner"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("oldSigner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newSigner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleSetConfig"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("OracleSetConfig"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("name"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::String,
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("signer"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("authority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OwnershipTransferred"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OwnershipTransferred",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("previousOwner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("newOwner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RemoveMrEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RemoveMrEnclave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RequestEvent"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RequestEvent"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("requestId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RequestFund"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RequestFund"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("funder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RequestWithdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RequestWithdraw"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("funder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RoutineCreated"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RoutineCreated"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("params"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RoutineFund"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RoutineFund"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("funder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RoutineWithdraw"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("RoutineWithdraw"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("funder"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeAdded"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("StakeAdded"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeRemoved"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("StakeRemoved"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Transfer"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("Transfer"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("from"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("value"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Unstaked"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("Unstaked"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: false,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: false,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("VerifyFailed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::Event {
                            name: ::std::borrow::ToOwned::to_owned("VerifyFailed"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    indexed: true,
                                },
                                ::ethers::core::abi::ethabi::EventParam {
                                    name: ::std::borrow::ToOwned::to_owned("code"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    indexed: true,
                                },
                            ],
                            anonymous: false,
                        },
                    ],
                ),
            ]),
            errors: ::core::convert::From::from([
                (
                    ::std::borrow::ToOwned::to_owned("ACLAdminAlreadyInitialized"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ACLAdminAlreadyInitialized",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ACLNotAdmin"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("ACLNotAdmin"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("account"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ACLNotAllowed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("ACLNotAllowed"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("account"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AggregatorDoesNotExist"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AggregatorDoesNotExist",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AlreadyExecuted"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("AlreadyExecuted"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("txHash"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AttestationQueueAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AttestationQueueAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "attestationQueueId",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("AttestationQueueDoesNotExist"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "AttestationQueueDoesNotExist",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "attestationQueueId",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CallExceededMaxGasCost"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CallExceededMaxGasCost",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("CallIdAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "CallIdAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ECDSAInvalidSignature"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ECDSAInvalidSignature",
                            ),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ECDSAInvalidSignatureLength"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ECDSAInvalidSignatureLength",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("length"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ECDSAInvalidSignatureS"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ECDSAInvalidSignatureS",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("s"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EarlyOracleResponse"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "EarlyOracleResponse",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "EnclaveAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveDoesNotExist"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "EnclaveDoesNotExist",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveExpired"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("EnclaveExpired"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveNotAtQueueIdx"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "EnclaveNotAtQueueIdx",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveNotFullyStaked"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "EnclaveNotFullyStaked",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveNotOnQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("EnclaveNotOnQueue"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveNotReadyForVerification"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "EnclaveNotReadyForVerification",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("EnclaveUnverified"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("EnclaveUnverified"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ExcessiveGasSpent"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("ExcessiveGasSpent"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("gasLimit"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("gasSpent"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("ForceOverrideNotReady"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "ForceOverrideNotReady",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "FunctionAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionCallerNotPermitted"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "FunctionCallerNotPermitted",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("sender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionDoesNotExist"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "FunctionDoesNotExist",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionFeeTooLow"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("FunctionFeeTooLow"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionIncorrectTarget"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "FunctionIncorrectTarget",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionMrEnclaveMismatch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "FunctionMrEnclaveMismatch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("FunctionSignerAlreadySet"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "FunctionSignerAlreadySet",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("current"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("GasLimitExceeded"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("GasLimitExceeded"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("limit"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("used"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("Generic"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("Generic"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("IncorrectFunctionId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "IncorrectFunctionId",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("IncorrectReportedTime"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "IncorrectReportedTime",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("maxExpectedTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("reportedTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("IncorrectToken"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("IncorrectToken"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InitializationFunctionReverted"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InitializationFunctionReverted",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "_initializationContractAddress",
                                    ),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("_calldata"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InsufficientBalance"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InsufficientBalance",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expectedBalance"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("receivedBalance"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InsufficientCallBalance"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InsufficientCallBalance",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InsufficientCallFeePaid"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InsufficientCallFeePaid",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InsufficientNodes"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InsufficientNodes"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InsufficientSamples"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InsufficientSamples",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("IntervalHistoryNotRecorded"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "IntervalHistoryNotRecorded",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregatorId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidArgument"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidArgument"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("argumentIndex"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidAuthority"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidAuthority"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expectedAuthority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("receivedAuthority"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidCallId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidCallId"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidCallbackParams"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "InvalidCallbackParams",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("callId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("hash"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidEnclave"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidEnclave"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("enclaveId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidEntry"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidEntry"),
                            inputs: ::std::vec![],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidRoutineId"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidRoutineId"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidSignature"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidSignature"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expectedSender"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("txHash"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("signature"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Bytes,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidSigner"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidSigner"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expectedSigner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("receivedSigner"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("InvalidStatus"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("InvalidStatus"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("account"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expected"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("received"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("MrEnclaveNotAllowed"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "MrEnclaveNotAllowed",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("mrEnclave"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::FixedBytes(
                                        32usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("bytes32"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleExpired"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("OracleExpired"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleNotAtQueueIdx"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleNotAtQueueIdx",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleIdx"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleNotOnQueue"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("OracleNotOnQueue"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("OracleQueueDoesNotExist"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "OracleQueueDoesNotExist",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("oracleQueueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("PermissionDenied"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("PermissionDenied"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("granter"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("grantee"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("permission"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("QueuesDoNotMatch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("QueuesDoNotMatch"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expectedQueueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("receivedQueueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RequestAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "RequestAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("requestId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RequestIdAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "RequestIdAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("requestId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RoutineIdAlreadyExists"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "RoutineIdAlreadyExists",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("routineId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("RoutinesDisabled"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("RoutinesDisabled"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("functionId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeNotReady"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("StakeNotReady"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("readyAt"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("StakeNotReadyForWithdrawal"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "StakeNotReadyForWithdrawal",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("queueId"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("staker"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("readyAt"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("SubmittedResultsMismatch"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "SubmittedResultsMismatch",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("aggregators"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("results"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("TokenTransferFailure"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned(
                                "TokenTransferFailure",
                            ),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("token"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("to"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Address,
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("address"),
                                    ),
                                },
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("amount"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
                (
                    ::std::borrow::ToOwned::to_owned("TransactionExpired"),
                    ::std::vec![
                        ::ethers::core::abi::ethabi::AbiError {
                            name: ::std::borrow::ToOwned::to_owned("TransactionExpired"),
                            inputs: ::std::vec![
                                ::ethers::core::abi::ethabi::Param {
                                    name: ::std::borrow::ToOwned::to_owned("expirationTime"),
                                    kind: ::ethers::core::abi::ethabi::ParamType::Uint(
                                        256usize,
                                    ),
                                    internal_type: ::core::option::Option::Some(
                                        ::std::borrow::ToOwned::to_owned("uint256"),
                                    ),
                                },
                            ],
                        },
                    ],
                ),
            ]),
            receive: false,
            fallback: false,
        }
    }
    ///The parsed JSON ABI of the contract.
    pub static SWITCHBOARD_ABI: ::ethers::contract::Lazy<::ethers::core::abi::Abi> =
        ::ethers::contract::Lazy::new(__abi);
    pub struct Switchboard<M>(::ethers::contract::Contract<M>);
    impl<M> ::core::clone::Clone for Switchboard<M> {
        fn clone(&self) -> Self {
            Self(::core::clone::Clone::clone(&self.0))
        }
    }
    impl<M> ::core::ops::Deref for Switchboard<M> {
        type Target = ::ethers::contract::Contract<M>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl<M> ::core::ops::DerefMut for Switchboard<M> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }
    impl<M> ::core::fmt::Debug for Switchboard<M> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple(::core::stringify!(Switchboard))
                .field(&self.address())
                .finish()
        }
    }
    impl<M: ::ethers::providers::Middleware> Switchboard<M> {
        /// Creates a new contract instance with the specified `ethers` client at
        /// `address`. The contract derefs to a `ethers::Contract` object.
        pub fn new<T: Into<::ethers::core::types::Address>>(
            address: T,
            client: ::std::sync::Arc<M>,
        ) -> Self {
            Self(::ethers::contract::Contract::new(
                address.into(),
                SWITCHBOARD_ABI.clone(),
                client,
            ))
        }
        ///Calls the contract's `addMrEnclaveToAttestationQueue` (0xad435b9d) function
        pub fn add_mr_enclave_to_attestation_queue(
            &self,
            queue_id: ::ethers::core::types::Address,
            mr_enclave: [u8; 32],
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([173, 67, 91, 157], (queue_id, mr_enclave))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `addMrEnclaveToFunction` (0x45fc160c) function
        pub fn add_mr_enclave_to_function(
            &self,
            function_id: ::ethers::core::types::Address,
            mr_enclave: [u8; 32],
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([69, 252, 22, 12], (function_id, mr_enclave))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `addMrEnclaveToOracleQueue` (0x51a426d8) function
        pub fn add_mr_enclave_to_oracle_queue(
            &self,
            queue_id: ::ethers::core::types::Address,
            mr_enclave: [u8; 32],
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([81, 164, 38, 216], (queue_id, mr_enclave))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `addStake` (0x6374299e) function
        pub fn add_stake(
            &self,
            enclave_id: ::ethers::core::types::Address,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([99, 116, 41, 158], (enclave_id, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `aggregatorEscrowFund` (0xd55dcc5b) function
        pub fn aggregator_escrow_fund(
            &self,
            account_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([213, 93, 204, 91], account_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `aggregatorEscrowWithdraw` (0x202dd499) function
        pub fn aggregator_escrow_withdraw(
            &self,
            recipient: ::ethers::core::types::Address,
            aggregator_id: ::ethers::core::types::Address,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([32, 45, 212, 153], (recipient, aggregator_id, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `aggregatorHistory` (0x8625bd08) function
        pub fn aggregator_history(
            &self,
            aggregator_id: ::ethers::core::types::Address,
            round_id: u128,
        ) -> ::ethers::contract::builders::ContractCall<M, AggregatorHistoryResult> {
            self.0
                .method_hash([134, 37, 189, 8], (aggregator_id, round_id))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `aggregators` (0x112cdab9) function
        pub fn aggregators(
            &self,
            aggregator_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Aggregator> {
            self.0
                .method_hash([17, 44, 218, 185], aggregator_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `allowance` (0xdd62ed3e) function
        pub fn allowance(
            &self,
            owner: ::ethers::core::types::Address,
            spender: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([221, 98, 237, 62], (owner, spender))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `approve` (0x095ea7b3) function
        pub fn approve(
            &self,
            spender: ::ethers::core::types::Address,
            value: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([9, 94, 167, 179], (spender, value))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `attestationQueueHasMrEnclave` (0x63fcd771) function
        pub fn attestation_queue_has_mr_enclave(
            &self,
            queue_id: ::ethers::core::types::Address,
            mr_enclave: [u8; 32],
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([99, 252, 215, 113], (queue_id, mr_enclave))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `attestationQueues` (0x8bb3048c) function
        pub fn attestation_queues(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, AttestationQueue> {
            self.0
                .method_hash([139, 179, 4, 140], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `balanceOf` (0x70a08231) function
        pub fn balance_of(
            &self,
            account: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([112, 160, 130, 49], account)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `callBalances` (0x0aaeffe5) function
        pub fn call_balances(
            &self,
            call_ids: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::U256>,
        > {
            self.0
                .method_hash([10, 174, 255, 229], call_ids)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `callFunction` (0x9c23da50) function
        pub fn call_function(
            &self,
            function_id: ::ethers::core::types::Address,
            params: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::Address> {
            self.0
                .method_hash([156, 35, 218, 80], (function_id, params))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createAggregator` (0x84ed8177) function
        pub fn create_aggregator(
            &self,
            name: ::std::string::String,
            authority: ::ethers::core::types::Address,
            batch_size: ::ethers::core::types::U256,
            min_update_delay_seconds: ::ethers::core::types::U256,
            min_oracle_results: ::ethers::core::types::U256,
            jobs_hash: ::std::string::String,
            queue_id: ::ethers::core::types::Address,
            variance_threshold: ::ethers::core::types::U256,
            min_job_results: ::ethers::core::types::U256,
            force_report_period: ::ethers::core::types::U256,
            enable_history: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [132, 237, 129, 119],
                    (
                        name,
                        authority,
                        batch_size,
                        min_update_delay_seconds,
                        min_oracle_results,
                        jobs_hash,
                        queue_id,
                        variance_threshold,
                        min_job_results,
                        force_report_period,
                        enable_history,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createAttestationQueue` (0xde776851) function
        pub fn create_attestation_queue(
            &self,
            authority: ::ethers::core::types::Address,
            max_size: ::ethers::core::types::U256,
            reward: ::ethers::core::types::U256,
            enclave_timeout: ::ethers::core::types::U256,
            max_enclave_verification_age: ::ethers::core::types::U256,
            allow_authority_override_after: ::ethers::core::types::U256,
            require_authority_heartbeat_permission: bool,
            require_usage_permissions: bool,
            max_consecutive_function_failures: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [222, 119, 104, 81],
                    (
                        authority,
                        max_size,
                        reward,
                        enclave_timeout,
                        max_enclave_verification_age,
                        allow_authority_override_after,
                        require_authority_heartbeat_permission,
                        require_usage_permissions,
                        max_consecutive_function_failures,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createEnclave` (0xcf392e2f) function
        pub fn create_enclave(
            &self,
            signer: ::ethers::core::types::Address,
            queue_id: ::ethers::core::types::Address,
            authority: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([207, 57, 46, 47], (signer, queue_id, authority))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createEnclaveWithId` (0xc7c1143e) function
        pub fn create_enclave_with_id(
            &self,
            enclave_id: ::ethers::core::types::Address,
            signer: ::ethers::core::types::Address,
            queue_id: ::ethers::core::types::Address,
            authority: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [199, 193, 20, 62],
                    (enclave_id, signer, queue_id, authority),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createFunction` (0xc4829580) function
        pub fn create_function(
            &self,
            name: ::std::string::String,
            authority: ::ethers::core::types::Address,
            queue_id: ::ethers::core::types::Address,
            container_registry: ::std::string::String,
            container: ::std::string::String,
            version: ::std::string::String,
            schedule: ::std::string::String,
            params_schema: ::std::string::String,
            permitted_callers: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [196, 130, 149, 128],
                    (
                        name,
                        authority,
                        queue_id,
                        container_registry,
                        container,
                        version,
                        schedule,
                        params_schema,
                        permitted_callers,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createFunctionWithId` (0xcd86c71b) function
        pub fn create_function_with_id(
            &self,
            function_id: ::ethers::core::types::Address,
            name: ::std::string::String,
            authority: ::ethers::core::types::Address,
            queue_id: ::ethers::core::types::Address,
            container_registry: ::std::string::String,
            container: ::std::string::String,
            version: ::std::string::String,
            schedule: ::std::string::String,
            params_schema: ::std::string::String,
            permitted_callers: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [205, 134, 199, 27],
                    (
                        function_id,
                        name,
                        authority,
                        queue_id,
                        container_registry,
                        container,
                        version,
                        schedule,
                        params_schema,
                        permitted_callers,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createOracle` (0xf843b846) function
        pub fn create_oracle(
            &self,
            name: ::std::string::String,
            signer: ::ethers::core::types::Address,
            queue_id: ::ethers::core::types::Address,
            authority: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([248, 67, 184, 70], (name, signer, queue_id, authority))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createOracleQueue` (0xe7675651) function
        pub fn create_oracle_queue(
            &self,
            name: ::std::string::String,
            authority: ::ethers::core::types::Address,
            unpermissioned_feeds_enabled: bool,
            max_size: ::ethers::core::types::U256,
            reward: ::ethers::core::types::U256,
            oracle_timeout: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [231, 103, 86, 81],
                    (
                        name,
                        authority,
                        unpermissioned_feeds_enabled,
                        max_size,
                        reward,
                        oracle_timeout,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createOracleWithId` (0x16703130) function
        pub fn create_oracle_with_id(
            &self,
            oracle_id: ::ethers::core::types::Address,
            name: ::std::string::String,
            signer: ::ethers::core::types::Address,
            queue_id: ::ethers::core::types::Address,
            authority: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [22, 112, 49, 48],
                    (oracle_id, name, signer, queue_id, authority),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `createRoutineWithId` (0x410d3013) function
        pub fn create_routine_with_id(
            &self,
            routine_id: ::ethers::core::types::Address,
            function_id: ::ethers::core::types::Address,
            authority: ::ethers::core::types::Address,
            params: ::ethers::core::types::Bytes,
            schedule: ::std::string::String,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [65, 13, 48, 19],
                    (routine_id, function_id, authority, params, schedule),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `diamondCut` (0x1f931c1c) function
        pub fn diamond_cut(
            &self,
            diamond_cut: ::std::vec::Vec<FacetCut>,
            init: ::ethers::core::types::Address,
            calldata: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([31, 147, 28, 28], (diamond_cut, init, calldata))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `enclaveGarbageCollect` (0xc06e4eda) function
        pub fn enclave_garbage_collect(
            &self,
            enclave_id: ::ethers::core::types::Address,
            enclave_idx: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([192, 110, 78, 218], (enclave_id, enclave_idx))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `enclaveHeartbeat` (0xce834437) function
        pub fn enclave_heartbeat(
            &self,
            enclave_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([206, 131, 68, 55], enclave_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `enclaveSignerToEnclaveId` (0x2ff75ec2) function
        pub fn enclave_signer_to_enclave_id(
            &self,
            signer: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::Address> {
            self.0
                .method_hash([47, 247, 94, 194], signer)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `enclaves` (0xfaeedb07) function
        pub fn enclaves(
            &self,
            enclave_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Enclave> {
            self.0
                .method_hash([250, 238, 219, 7], enclave_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `estimatedRunCost` (0x3da87438) function
        pub fn estimated_run_cost(
            &self,
            function_id: ::ethers::core::types::Address,
            gas_price: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([61, 168, 116, 56], (function_id, gas_price))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `facetAddress` (0xcdffacc6) function
        pub fn facet_address(
            &self,
            function_selector: [u8; 4],
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::Address> {
            self.0
                .method_hash([205, 255, 172, 198], function_selector)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `facetAddresses` (0x52ef6b2c) function
        pub fn facet_addresses(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([82, 239, 107, 44], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `facetFunctionSelectors` (0xadfca15e) function
        pub fn facet_function_selectors(
            &self,
            facet: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<[u8; 4]>> {
            self.0
                .method_hash([173, 252, 161, 94], facet)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `facets` (0x7a0ed627) function
        pub fn facets(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Facet>> {
            self.0
                .method_hash([122, 14, 214, 39], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `failEnclave` (0x39d920e6) function
        pub fn fail_enclave(
            &self,
            verifier_id: ::ethers::core::types::Address,
            enclave_id: ::ethers::core::types::Address,
            verifier_idx: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([57, 217, 32, 230], (verifier_id, enclave_id, verifier_idx))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `failFunctionResult` (0x52c7cc93) function
        pub fn fail_function_result(
            &self,
            params: FunctionFailParams,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([82, 199, 204, 147], (params,))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `forceOverrideVerify` (0xe231b12f) function
        pub fn force_override_verify(
            &self,
            enclave_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([226, 49, 177, 47], enclave_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `forward` (0x7096052c) function
        pub fn forward(
            &self,
            transactions: ::std::vec::Vec<Transaction>,
            signatures: ::std::vec::Vec<::ethers::core::types::Bytes>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([112, 150, 5, 44], (transactions, signatures))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `funcs` (0x8ef92003) function
        pub fn funcs(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, SbFunction> {
            self.0
                .method_hash([142, 249, 32, 3], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `functionCallSettings` (0xa30f8d25) function
        pub fn function_call_settings(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, FunctionCallSettings> {
            self.0
                .method_hash([163, 15, 141, 37], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `functionCalls` (0x826df326) function
        pub fn function_calls(
            &self,
            call_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, FunctionCall> {
            self.0
                .method_hash([130, 109, 243, 38], call_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `functionEscrowFund` (0xba93166c) function
        pub fn function_escrow_fund(
            &self,
            account_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([186, 147, 22, 108], account_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `functionEscrowWithdraw` (0xa29baf1e) function
        pub fn function_escrow_withdraw(
            &self,
            recipient: ::ethers::core::types::Address,
            function_id: ::ethers::core::types::Address,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([162, 155, 175, 30], (recipient, function_id, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `functionExists` (0xa13001c9) function
        pub fn function_exists(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([161, 48, 1, 201], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `functionSettings` (0xce77efa6) function
        pub fn function_settings(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, FunctionSettings> {
            self.0
                .method_hash([206, 119, 239, 166], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `functionVerify` (0xa5625b96) function
        pub fn function_verify(
            &self,
            enclave_idx: ::ethers::core::types::U256,
            function_id: ::ethers::core::types::Address,
            delegated_signer_address: ::ethers::core::types::Address,
            observed_time: ::ethers::core::types::U256,
            next_allowed_timestamp: ::ethers::core::types::U256,
            is_failure: bool,
            mr_enclave: [u8; 32],
            transactions: ::std::vec::Vec<Transaction>,
            signatures: ::std::vec::Vec<::ethers::core::types::Bytes>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [165, 98, 91, 150],
                    (
                        enclave_idx,
                        function_id,
                        delegated_signer_address,
                        observed_time,
                        next_allowed_timestamp,
                        is_failure,
                        mr_enclave,
                        transactions,
                        signatures,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `functionVerifyRequest` (0xb8390a56) function
        pub fn function_verify_request(
            &self,
            enclave_idx: ::ethers::core::types::U256,
            function_id: ::ethers::core::types::Address,
            delegated_signer_address: ::ethers::core::types::Address,
            observed_time: ::ethers::core::types::U256,
            next_allowed_timestamp: ::ethers::core::types::U256,
            is_failure: bool,
            mr_enclave: [u8; 32],
            transactions: ::std::vec::Vec<Transaction>,
            signatures: ::std::vec::Vec<::ethers::core::types::Bytes>,
            function_call_ids: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [184, 57, 10, 86],
                    (
                        enclave_idx,
                        function_id,
                        delegated_signer_address,
                        observed_time,
                        next_allowed_timestamp,
                        is_failure,
                        mr_enclave,
                        transactions,
                        signatures,
                        function_call_ids,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getActiveFunctionCallsByQueue` (0xfa88c651) function
        pub fn get_active_function_calls_by_queue(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<FunctionCall>,
            ),
        > {
            self.0
                .method_hash([250, 136, 198, 81], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getActiveFunctionsByQueue` (0x1fc747b7) function
        pub fn get_active_functions_by_queue(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<SbFunction>,
            ),
        > {
            self.0
                .method_hash([31, 199, 71, 183], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getActiveRequestsByQueue` (0x55c053c3) function
        pub fn get_active_requests_by_queue(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<Request>,
            ),
        > {
            self.0
                .method_hash([85, 192, 83, 195], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getActiveRoutinesByQueue` (0x9da3c6eb) function
        pub fn get_active_routines_by_queue(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<Routine>,
            ),
        > {
            self.0
                .method_hash([157, 163, 198, 235], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getAggregatorsByAuthority` (0x911c30f3) function
        pub fn get_aggregators_by_authority(
            &self,
            user: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<Aggregator>,
            ),
        > {
            self.0
                .method_hash([145, 28, 48, 243], user)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getAllAggregators` (0x465c65dd) function
        pub fn get_all_aggregators(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<Aggregator>,
            ),
        > {
            self.0
                .method_hash([70, 92, 101, 221], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getAllFunctions` (0xab6418b4) function
        pub fn get_all_functions(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<SbFunction>,
            ),
        > {
            self.0
                .method_hash([171, 100, 24, 180], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getAttestationQueueMrEnclaves` (0x0f3bc418) function
        pub fn get_attestation_queue_mr_enclaves(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<[u8; 32]>> {
            self.0
                .method_hash([15, 59, 196, 24], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getCurrentIntervalId` (0x1dc1da86) function
        pub fn get_current_interval_id(
            &self,
            aggregator_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, u128> {
            self.0
                .method_hash([29, 193, 218, 134], aggregator_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getEnclaveIdx` (0x21fb3bbc) function
        pub fn get_enclave_idx(
            &self,
            enclave_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::I256> {
            self.0
                .method_hash([33, 251, 59, 188], enclave_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getEnclaves` (0x340dd88b) function
        pub fn get_enclaves(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([52, 13, 216, 139], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getFunctionMrEnclaves` (0x526112ce) function
        pub fn get_function_mr_enclaves(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<[u8; 32]>> {
            self.0
                .method_hash([82, 97, 18, 206], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getFunctionPermittedCallers` (0xafdcbd6a) function
        pub fn get_function_permitted_callers(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([175, 220, 189, 106], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getFunctionsByAuthority` (0x357f633f) function
        pub fn get_functions_by_authority(
            &self,
            user: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<SbFunction>,
            ),
        > {
            self.0
                .method_hash([53, 127, 99, 63], user)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getIntervalResult` (0x3d24ef6e) function
        pub fn get_interval_result(
            &self,
            aggregator_id: ::ethers::core::types::Address,
            interval_id: u128,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::ethers::core::types::I256,
                ::ethers::core::types::U256,
                ::ethers::core::types::U256,
            ),
        > {
            self.0
                .method_hash([61, 36, 239, 110], (aggregator_id, interval_id))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getOracleIdx` (0xd87dd0ac) function
        pub fn get_oracle_idx(
            &self,
            oracle_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::I256> {
            self.0
                .method_hash([216, 125, 208, 172], oracle_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getOracleQueueAllowedMrEnclaves` (0xf04b0f59) function
        pub fn get_oracle_queue_allowed_mr_enclaves(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<[u8; 32]>> {
            self.0
                .method_hash([240, 75, 15, 89], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getOracles` (0x8e749281) function
        pub fn get_oracles(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            ::std::vec::Vec<::ethers::core::types::Address>,
        > {
            self.0
                .method_hash([142, 116, 146, 129], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getPermission` (0x910185dd) function
        pub fn get_permission(
            &self,
            granter: ::ethers::core::types::Address,
            grantee: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([145, 1, 133, 221], (granter, grantee))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getRequestsByFunctionId` (0xb68e3ace) function
        pub fn get_requests_by_function_id(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<Request>,
            ),
        > {
            self.0
                .method_hash([182, 142, 58, 206], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getRoutinesByAuthority` (0xb36afb5a) function
        pub fn get_routines_by_authority(
            &self,
            authority: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<Routine>,
            ),
        > {
            self.0
                .method_hash([179, 106, 251, 90], authority)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getRoutinesByFunctionId` (0x27c66c0f) function
        pub fn get_routines_by_function_id(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (
                ::std::vec::Vec<::ethers::core::types::Address>,
                ::std::vec::Vec<Routine>,
            ),
        > {
            self.0
                .method_hash([39, 198, 108, 15], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getStakeForEnclave` (0x376d9b41) function
        pub fn get_stake_for_enclave(
            &self,
            enclave_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Stake> {
            self.0
                .method_hash([55, 109, 155, 65], enclave_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getStakeForEnclaveWithToken` (0x3ff8f2af) function
        pub fn get_stake_for_enclave_with_token(
            &self,
            enclave_id: ::ethers::core::types::Address,
            token: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Stake> {
            self.0
                .method_hash([63, 248, 242, 175], (enclave_id, token))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getStakingConfig` (0x5133a68c) function
        pub fn get_staking_config(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, StakingConfig> {
            self.0
                .method_hash([81, 51, 166, 140], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `getTransactionHash` (0xd93f1970) function
        pub fn get_transaction_hash(
            &self,
            expiration_time_seconds: ::ethers::core::types::U256,
            gas_limit: ::ethers::core::types::U256,
            value: ::ethers::core::types::U256,
            to: ::ethers::core::types::Address,
            from: ::ethers::core::types::Address,
            data: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, [u8; 32]> {
            self.0
                .method_hash(
                    [217, 63, 25, 112],
                    (expiration_time_seconds, gas_limit, value, to, from, data),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `hasPermission` (0x8b01813d) function
        pub fn has_permission(
            &self,
            granter: ::ethers::core::types::Address,
            grantee: ::ethers::core::types::Address,
            permission: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([139, 1, 129, 61], (granter, grantee, permission))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `init` (0xe1c7392a) function
        pub fn init(&self) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([225, 199, 57, 42], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `initialize` (0x8129fc1c) function
        pub fn initialize(&self) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([129, 41, 252, 28], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isAdmin` (0x24d7806c) function
        pub fn is_admin(
            &self,
            sender: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([36, 215, 128, 108], sender)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isAllowed` (0xbabcc539) function
        pub fn is_allowed(
            &self,
            sender: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([186, 188, 197, 57], sender)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isEnclaveValid` (0xfb4acdfe) function
        pub fn is_enclave_valid(
            &self,
            enclave_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([251, 74, 205, 254], enclave_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `isTrustedForwarder` (0x572b6c05) function
        pub fn is_trusted_forwarder(
            &self,
            p0: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([87, 43, 108, 5], p0)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `latestResult` (0xfab005a2) function
        pub fn latest_result(
            &self,
            aggregator_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (::ethers::core::types::I256, ::ethers::core::types::U256),
        > {
            self.0
                .method_hash([250, 176, 5, 162], aggregator_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `openInterval` (0x0f2544be) function
        pub fn open_interval(
            &self,
            aggregator_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([15, 37, 68, 190], aggregator_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `oracleGarbageCollect` (0x71da68ff) function
        pub fn oracle_garbage_collect(
            &self,
            oracle_id: ::ethers::core::types::Address,
            oracle_idx: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([113, 218, 104, 255], (oracle_id, oracle_idx))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `oracleHeartbeat` (0xf53b638c) function
        pub fn oracle_heartbeat(
            &self,
            oracle_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([245, 59, 99, 140], oracle_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `oracleQueues` (0xf2378e88) function
        pub fn oracle_queues(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, OracleQueue> {
            self.0
                .method_hash([242, 55, 142, 136], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `oracles` (0xaddd5099) function
        pub fn oracles(
            &self,
            oracle_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Oracle> {
            self.0
                .method_hash([173, 221, 80, 153], oracle_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `owner` (0x8da5cb5b) function
        pub fn owner(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::Address> {
            self.0
                .method_hash([141, 165, 203, 91], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `prepareUnstake` (0xb8d35d6a) function
        pub fn prepare_unstake(
            &self,
            enclave_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([184, 211, 93, 106], enclave_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `queueAttestationConfigs` (0x6ddc9122) function
        pub fn queue_attestation_configs(
            &self,
            queue_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, AttestationConfig> {
            self.0
                .method_hash([109, 220, 145, 34], queue_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `recoverStakeWithToken` (0x5e8e1ad0) function
        pub fn recover_stake_with_token(
            &self,
            enclave_id: ::ethers::core::types::Address,
            token: ::ethers::core::types::Address,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([94, 142, 26, 208], (enclave_id, token, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `removeMrEnclaveFromAttestationQueue` (0x083f30cf) function
        pub fn remove_mr_enclave_from_attestation_queue(
            &self,
            queue_id: ::ethers::core::types::Address,
            mr_enclave: [u8; 32],
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([8, 63, 48, 207], (queue_id, mr_enclave))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `removeMrEnclaveFromFunction` (0xf0184db9) function
        pub fn remove_mr_enclave_from_function(
            &self,
            function_id: ::ethers::core::types::Address,
            mr_enclave: [u8; 32],
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([240, 24, 77, 185], (function_id, mr_enclave))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `removeMrEnclaveFromOracleQueue` (0x262955d8) function
        pub fn remove_mr_enclave_from_oracle_queue(
            &self,
            queue_id: ::ethers::core::types::Address,
            mr_enclave: [u8; 32],
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([38, 41, 85, 216], (queue_id, mr_enclave))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requestFund` (0x52a061d7) function
        pub fn request_fund(
            &self,
            request_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([82, 160, 97, 215], request_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requestWithdrawal` (0x8985646a) function
        pub fn request_withdrawal(
            &self,
            request_id: ::ethers::core::types::Address,
            recipient: ::ethers::core::types::Address,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([137, 133, 100, 106], (request_id, recipient, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `requests` (0x74adad1d) function
        pub fn requests(
            &self,
            request_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Request> {
            self.0
                .method_hash([116, 173, 173, 29], request_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `rotateEnclaveSigner` (0x2628b3a9) function
        pub fn rotate_enclave_signer(
            &self,
            enclave_id: ::ethers::core::types::Address,
            new_signer: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([38, 40, 179, 169], (enclave_id, new_signer))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `rotateOracleSigner` (0x4d1b776d) function
        pub fn rotate_oracle_signer(
            &self,
            oracle_id: ::ethers::core::types::Address,
            new_signer: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([77, 27, 119, 109], (oracle_id, new_signer))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `routineEscrowFund` (0x5d4e4594) function
        pub fn routine_escrow_fund(
            &self,
            routine_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([93, 78, 69, 148], routine_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `routineEscrowWithdraw` (0xfab08683) function
        pub fn routine_escrow_withdraw(
            &self,
            routine_id: ::ethers::core::types::Address,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([250, 176, 134, 131], (routine_id, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `routineExists` (0xc98d9be8) function
        pub fn routine_exists(
            &self,
            routine_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([201, 141, 155, 232], routine_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `routines` (0xfdcc54d2) function
        pub fn routines(
            &self,
            routine_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, Routine> {
            self.0
                .method_hash([253, 204, 84, 210], routine_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `saveResults` (0x735e3555) function
        pub fn save_results(
            &self,
            ids: ::std::vec::Vec<::ethers::core::types::Address>,
            results: ::std::vec::Vec<::ethers::core::types::I256>,
            queue_id: ::ethers::core::types::Address,
            oracle_idx: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([115, 94, 53, 85], (ids, results, queue_id, oracle_idx))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `sendDelayedRequest` (0x80eb181e) function
        pub fn send_delayed_request(
            &self,
            request_id: ::ethers::core::types::Address,
            function_id: ::ethers::core::types::Address,
            params: ::ethers::core::types::Bytes,
            start_after: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [128, 235, 24, 30],
                    (request_id, function_id, params, start_after),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `sendRequest` (0x62d3fe46) function
        pub fn send_request(
            &self,
            function_id: ::ethers::core::types::Address,
            params: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::Address> {
            self.0
                .method_hash([98, 211, 254, 70], (function_id, params))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `sendRequestWithId` (0x264c1450) function
        pub fn send_request_with_id(
            &self,
            request_id: ::ethers::core::types::Address,
            function_id: ::ethers::core::types::Address,
            params: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::Address> {
            self.0
                .method_hash([38, 76, 20, 80], (request_id, function_id, params))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setAdmin` (0x4b0bddd2) function
        pub fn set_admin(
            &self,
            sender: ::ethers::core::types::Address,
            status: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([75, 11, 221, 210], (sender, status))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setAggregatorConfig` (0xdd0ad73a) function
        pub fn set_aggregator_config(
            &self,
            aggregator_id: ::ethers::core::types::Address,
            name: ::std::string::String,
            authority: ::ethers::core::types::Address,
            batch_size: ::ethers::core::types::U256,
            min_update_delay_seconds: ::ethers::core::types::U256,
            min_oracle_results: ::ethers::core::types::U256,
            jobs_hash: ::std::string::String,
            queue_id: ::ethers::core::types::Address,
            variance_threshold: ::ethers::core::types::U256,
            min_job_results: ::ethers::core::types::U256,
            force_report_period: ::ethers::core::types::U256,
            enable_history: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [221, 10, 215, 58],
                    (
                        aggregator_id,
                        name,
                        authority,
                        batch_size,
                        min_update_delay_seconds,
                        min_oracle_results,
                        jobs_hash,
                        queue_id,
                        variance_threshold,
                        min_job_results,
                        force_report_period,
                        enable_history,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setAllowed` (0x4697f05d) function
        pub fn set_allowed(
            &self,
            sender: ::ethers::core::types::Address,
            status: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([70, 151, 240, 93], (sender, status))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setAttestationQueueConfig` (0xf7d48307) function
        pub fn set_attestation_queue_config(
            &self,
            queue_id: ::ethers::core::types::Address,
            authority: ::ethers::core::types::Address,
            max_size: ::ethers::core::types::U256,
            reward: ::ethers::core::types::U256,
            enclave_timeout: ::ethers::core::types::U256,
            max_enclave_verification_age: ::ethers::core::types::U256,
            allow_authority_override_after: ::ethers::core::types::U256,
            require_authority_heartbeat_permission: bool,
            require_usage_permissions: bool,
            max_consecutive_function_failures: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [247, 212, 131, 7],
                    (
                        queue_id,
                        authority,
                        max_size,
                        reward,
                        enclave_timeout,
                        max_enclave_verification_age,
                        allow_authority_override_after,
                        require_authority_heartbeat_permission,
                        require_usage_permissions,
                        max_consecutive_function_failures,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setAttestationQueuePermission` (0xa77a07d3) function
        pub fn set_attestation_queue_permission(
            &self,
            queue_id: ::ethers::core::types::Address,
            grantee: ::ethers::core::types::Address,
            permission: ::ethers::core::types::U256,
            on: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([167, 122, 7, 211], (queue_id, grantee, permission, on))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setFunctionCallSettings` (0x6b7ef38b) function
        pub fn set_function_call_settings(
            &self,
            function_id: ::ethers::core::types::Address,
            require_estimated_run_cost_fee: bool,
            minimum_fee: ::ethers::core::types::U256,
            max_gas_cost: ::ethers::core::types::U256,
            require_caller_pay_full_cost: bool,
            require_sender_be_return_address: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [107, 126, 243, 139],
                    (
                        function_id,
                        require_estimated_run_cost_fee,
                        minimum_fee,
                        max_gas_cost,
                        require_caller_pay_full_cost,
                        require_sender_be_return_address,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setFunctionConfig` (0x822e99d5) function
        pub fn set_function_config(
            &self,
            function_id: ::ethers::core::types::Address,
            name: ::std::string::String,
            authority: ::ethers::core::types::Address,
            container_registry: ::std::string::String,
            container: ::std::string::String,
            version: ::std::string::String,
            schedule: ::std::string::String,
            params_schema: ::std::string::String,
            permitted_callers: ::std::vec::Vec<::ethers::core::types::Address>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [130, 46, 153, 213],
                    (
                        function_id,
                        name,
                        authority,
                        container_registry,
                        container,
                        version,
                        schedule,
                        params_schema,
                        permitted_callers,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setFunctionDeactivated` (0x725483a5) function
        pub fn set_function_deactivated(
            &self,
            function_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([114, 84, 131, 165], function_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setFunctionSettings` (0xfeb0de89) function
        pub fn set_function_settings(
            &self,
            function_id: ::ethers::core::types::Address,
            settings: FunctionSettings,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([254, 176, 222, 137], (function_id, settings))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setOracleConfig` (0xf50b5ed0) function
        pub fn set_oracle_config(
            &self,
            oracle_id: ::ethers::core::types::Address,
            name: ::std::string::String,
            signer: ::ethers::core::types::Address,
            queue_id: ::ethers::core::types::Address,
            authority: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [245, 11, 94, 208],
                    (oracle_id, name, signer, queue_id, authority),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setOracleQueueAttestationConfig` (0x88033af5) function
        pub fn set_oracle_queue_attestation_config(
            &self,
            queue_id: ::ethers::core::types::Address,
            attestation_queue_id: ::ethers::core::types::Address,
            mr_enclaves: ::std::vec::Vec<[u8; 32]>,
            require_valid_enclave: bool,
            require_heartbeat_permission: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [136, 3, 58, 245],
                    (
                        queue_id,
                        attestation_queue_id,
                        mr_enclaves,
                        require_valid_enclave,
                        require_heartbeat_permission,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setOracleQueueConfig` (0xb6590411) function
        pub fn set_oracle_queue_config(
            &self,
            queue_id: ::ethers::core::types::Address,
            name: ::std::string::String,
            authority: ::ethers::core::types::Address,
            unpermissioned_feeds_enabled: bool,
            max_size: ::ethers::core::types::U256,
            reward: ::ethers::core::types::U256,
            oracle_timeout: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [182, 89, 4, 17],
                    (
                        queue_id,
                        name,
                        authority,
                        unpermissioned_feeds_enabled,
                        max_size,
                        reward,
                        oracle_timeout,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setOracleQueuePermission` (0x01fc1ba2) function
        pub fn set_oracle_queue_permission(
            &self,
            queue_id: ::ethers::core::types::Address,
            grantee: ::ethers::core::types::Address,
            permission: ::ethers::core::types::U256,
            on: bool,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([1, 252, 27, 162], (queue_id, grantee, permission, on))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setStakingConfig` (0xf22644c2) function
        pub fn set_staking_config(
            &self,
            queue_id: ::ethers::core::types::Address,
            token: ::ethers::core::types::Address,
            staking_amount: ::ethers::core::types::U256,
            staking_period: ::ethers::core::types::U256,
            unstaking_period: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [242, 38, 68, 194],
                    (
                        queue_id,
                        token,
                        staking_amount,
                        staking_period,
                        unstaking_period,
                    ),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `setToleratedTimestampDiscrepancy` (0x101277b2) function
        pub fn set_tolerated_timestamp_discrepancy(
            &self,
            tolerance: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([16, 18, 119, 178], tolerance)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `slashStake` (0x98d1c5a8) function
        pub fn slash_stake(
            &self,
            enclave_id: ::ethers::core::types::Address,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([152, 209, 197, 168], (enclave_id, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `supportsInterface` (0x01ffc9a7) function
        pub fn supports_interface(
            &self,
            interface_id: [u8; 4],
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([1, 255, 201, 167], interface_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `totalStaked` (0xf21630cb) function
        pub fn total_staked(
            &self,
            queue_id: ::ethers::core::types::Address,
            token: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([242, 22, 48, 203], (queue_id, token))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `totalSupply` (0x18160ddd) function
        pub fn total_supply(
            &self,
        ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> {
            self.0
                .method_hash([24, 22, 13, 221], ())
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `transfer` (0xa9059cbb) function
        pub fn transfer(
            &self,
            to: ::ethers::core::types::Address,
            value: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([169, 5, 156, 187], (to, value))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `transferFrom` (0x23b872dd) function
        pub fn transfer_from(
            &self,
            from: ::ethers::core::types::Address,
            to: ::ethers::core::types::Address,
            value: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, bool> {
            self.0
                .method_hash([35, 184, 114, 221], (from, to, value))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `transferOwnership` (0xf2fde38b) function
        pub fn transfer_ownership(
            &self,
            new_owner: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([242, 253, 227, 139], new_owner)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `unstake` (0xc2a672e0) function
        pub fn unstake(
            &self,
            enclave_id: ::ethers::core::types::Address,
            amount: ::ethers::core::types::U256,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([194, 166, 114, 224], (enclave_id, amount))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `updateEnclave` (0x5cd6ac0c) function
        pub fn update_enclave(
            &self,
            enclave_id: ::ethers::core::types::Address,
            cid: ::ethers::core::types::Bytes,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([92, 214, 172, 12], (enclave_id, cid))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `updateRoutine` (0x9300c999) function
        pub fn update_routine(
            &self,
            routine_id: ::ethers::core::types::Address,
            function_id: ::ethers::core::types::Address,
            authority: ::ethers::core::types::Address,
            params: ::ethers::core::types::Bytes,
            schedule: ::std::string::String,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [147, 0, 201, 153],
                    (routine_id, function_id, authority, params, schedule),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `validate` (0x1755a7f8) function
        pub fn validate(
            &self,
            signer: ::ethers::core::types::Address,
            attestation_queue_id: ::ethers::core::types::Address,
            valid_measurements: ::std::vec::Vec<[u8; 32]>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [23, 85, 167, 248],
                    (signer, attestation_queue_id, valid_measurements),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `verifyCallbackParams` (0x9c5eb6d9) function
        pub fn verify_callback_params(
            &self,
            call_ids: ::std::vec::Vec<::ethers::core::types::Address>,
            hashes: ::std::vec::Vec<[u8; 32]>,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([156, 94, 182, 217], (call_ids, hashes))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `verifyEnclave` (0xef0ebd71) function
        pub fn verify_enclave(
            &self,
            verifier_id: ::ethers::core::types::Address,
            enclave_id: ::ethers::core::types::Address,
            enclave_idx: ::ethers::core::types::U256,
            timestamp: ::ethers::core::types::U256,
            mr_enclave: [u8; 32],
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash(
                    [239, 14, 189, 113],
                    (verifier_id, enclave_id, enclave_idx, timestamp, mr_enclave),
                )
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `verifyFunctionResult` (0x3bd7b617) function
        pub fn verify_function_result(
            &self,
            params: FunctionVerifyParams,
        ) -> ::ethers::contract::builders::ContractCall<M, ()> {
            self.0
                .method_hash([59, 215, 182, 23], (params,))
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `viewAggregatorResults` (0xde866484) function
        pub fn view_aggregator_results(
            &self,
            aggregator_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Result>> {
            self.0
                .method_hash([222, 134, 100, 132], aggregator_id)
                .expect("method not found (this should never happen)")
        }
        ///Calls the contract's `viewLatestResult` (0xbdf5edef) function
        pub fn view_latest_result(
            &self,
            aggregator_id: ::ethers::core::types::Address,
        ) -> ::ethers::contract::builders::ContractCall<
            M,
            (::ethers::core::types::I256, ::ethers::core::types::U256),
        > {
            self.0
                .method_hash([189, 245, 237, 239], aggregator_id)
                .expect("method not found (this should never happen)")
        }
        ///Gets the contract's `AddMrEnclave` event
        pub fn add_mr_enclave_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, AddMrEnclaveFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `AggregatorAccountInit` event
        pub fn aggregator_account_init_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, AggregatorAccountInitFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `AggregatorFundEvent` event
        pub fn aggregator_fund_event_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, AggregatorFundEventFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `AggregatorIntervalRefreshed` event
        pub fn aggregator_interval_refreshed_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            AggregatorIntervalRefreshedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `AggregatorOpenInterval` event
        pub fn aggregator_open_interval_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, AggregatorOpenIntervalFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `AggregatorRead` event
        pub fn aggregator_read_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, AggregatorReadFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `AggregatorSaveResult` event
        pub fn aggregator_save_result_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, AggregatorSaveResultFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `AggregatorSettingsUpdated` event
        pub fn aggregator_settings_updated_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            AggregatorSettingsUpdatedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `AggregatorUpdate` event
        pub fn aggregator_update_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, AggregatorUpdateFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `AggregatorWithdrawEvent` event
        pub fn aggregator_withdraw_event_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            AggregatorWithdrawEventFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `Approval` event
        pub fn approval_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, ApprovalFilter> {
            self.0.event()
        }
        ///Gets the contract's `AttestationQueueAccountInit` event
        pub fn attestation_queue_account_init_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            AttestationQueueAccountInitFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `AttestationQueuePermissionUpdated` event
        pub fn attestation_queue_permission_updated_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            AttestationQueuePermissionUpdatedFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `AttestationQueueSetConfig` event
        pub fn attestation_queue_set_config_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            AttestationQueueSetConfigFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `DiamondCut` event
        pub fn diamond_cut_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, DiamondCutFilter> {
            self.0.event()
        }
        ///Gets the contract's `EnclaveAccountInit` event
        pub fn enclave_account_init_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, EnclaveAccountInitFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `EnclaveGC` event
        pub fn enclave_gc_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, EnclaveGCFilter> {
            self.0.event()
        }
        ///Gets the contract's `EnclaveHeartbeat` event
        pub fn enclave_heartbeat_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, EnclaveHeartbeatFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `EnclavePayoutEvent` event
        pub fn enclave_payout_event_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, EnclavePayoutEventFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `EnclaveRotateSigner` event
        pub fn enclave_rotate_signer_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, EnclaveRotateSignerFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `EnclaveVerifyRequest` event
        pub fn enclave_verify_request_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, EnclaveVerifyRequestFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `FunctionAccountInit` event
        pub fn function_account_init_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, FunctionAccountInitFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `FunctionCallEvent` event
        pub fn function_call_event_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, FunctionCallEventFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `FunctionCallFund` event
        pub fn function_call_fund_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, FunctionCallFundFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `FunctionFund` event
        pub fn function_fund_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, FunctionFundFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `FunctionWithdraw` event
        pub fn function_withdraw_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, FunctionWithdrawFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `OracleAccountInit` event
        pub fn oracle_account_init_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OracleAccountInitFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `OracleGC` event
        pub fn oracle_gc_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OracleGCFilter> {
            self.0.event()
        }
        ///Gets the contract's `OracleHeartbeat` event
        pub fn oracle_heartbeat_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OracleHeartbeatFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `OraclePayoutEvent` event
        pub fn oracle_payout_event_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OraclePayoutEventFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `OracleQueueAccountInit` event
        pub fn oracle_queue_account_init_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OracleQueueAccountInitFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `OracleQueueAddMrEnclave` event
        pub fn oracle_queue_add_mr_enclave_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            OracleQueueAddMrEnclaveFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `OracleQueueRemoveMrEnclave` event
        pub fn oracle_queue_remove_mr_enclave_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            OracleQueueRemoveMrEnclaveFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `OracleQueueSetAttestationConfig` event
        pub fn oracle_queue_set_attestation_config_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            OracleQueueSetAttestationConfigFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `OracleQueueSetConfig` event
        pub fn oracle_queue_set_config_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OracleQueueSetConfigFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `OracleQueueSetPermission` event
        pub fn oracle_queue_set_permission_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<
            ::std::sync::Arc<M>,
            M,
            OracleQueueSetPermissionFilter,
        > {
            self.0.event()
        }
        ///Gets the contract's `OracleRotateSigner` event
        pub fn oracle_rotate_signer_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OracleRotateSignerFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `OracleSetConfig` event
        pub fn oracle_set_config_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OracleSetConfigFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `OwnershipTransferred` event
        pub fn ownership_transferred_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, OwnershipTransferredFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `RemoveMrEnclave` event
        pub fn remove_mr_enclave_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, RemoveMrEnclaveFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `RequestEvent` event
        pub fn request_event_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, RequestEventFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `RequestFund` event
        pub fn request_fund_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, RequestFundFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `RequestWithdraw` event
        pub fn request_withdraw_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, RequestWithdrawFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `RoutineCreated` event
        pub fn routine_created_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, RoutineCreatedFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `RoutineFund` event
        pub fn routine_fund_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, RoutineFundFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `RoutineWithdraw` event
        pub fn routine_withdraw_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, RoutineWithdrawFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `StakeAdded` event
        pub fn stake_added_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, StakeAddedFilter> {
            self.0.event()
        }
        ///Gets the contract's `StakeRemoved` event
        pub fn stake_removed_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, StakeRemovedFilter>
        {
            self.0.event()
        }
        ///Gets the contract's `Transfer` event
        pub fn transfer_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, TransferFilter> {
            self.0.event()
        }
        ///Gets the contract's `Unstaked` event
        pub fn unstaked_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, UnstakedFilter> {
            self.0.event()
        }
        ///Gets the contract's `VerifyFailed` event
        pub fn verify_failed_filter(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, VerifyFailedFilter>
        {
            self.0.event()
        }
        /// Returns an `Event` builder for all the events of this contract.
        pub fn events(
            &self,
        ) -> ::ethers::contract::builders::Event<::std::sync::Arc<M>, M, SwitchboardEvents>
        {
            self.0
                .event_with_filter(::core::default::Default::default())
        }
    }
    impl<M: ::ethers::providers::Middleware> From<::ethers::contract::Contract<M>> for Switchboard<M> {
        fn from(contract: ::ethers::contract::Contract<M>) -> Self {
            Self::new(contract.address(), contract.client())
        }
    }
    ///Custom Error type `ACLAdminAlreadyInitialized` with signature `ACLAdminAlreadyInitialized()` and selector `0x7373cb0d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "ACLAdminAlreadyInitialized",
        abi = "ACLAdminAlreadyInitialized()"
    )]
    pub struct ACLAdminAlreadyInitialized;
    ///Custom Error type `ACLNotAdmin` with signature `ACLNotAdmin(address)` and selector `0x00ea207e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "ACLNotAdmin", abi = "ACLNotAdmin(address)")]
    pub struct ACLNotAdmin {
        pub account: ::ethers::core::types::Address,
    }
    ///Custom Error type `ACLNotAllowed` with signature `ACLNotAllowed(address)` and selector `0xea9a4ba0`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "ACLNotAllowed", abi = "ACLNotAllowed(address)")]
    pub struct ACLNotAllowed {
        pub account: ::ethers::core::types::Address,
    }
    ///Custom Error type `AggregatorAlreadyExists` with signature `AggregatorAlreadyExists(address)` and selector `0xe65d3ee3`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "AggregatorAlreadyExists",
        abi = "AggregatorAlreadyExists(address)"
    )]
    pub struct AggregatorAlreadyExists {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `AggregatorDoesNotExist` with signature `AggregatorDoesNotExist(address)` and selector `0x863b154f`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "AggregatorDoesNotExist",
        abi = "AggregatorDoesNotExist(address)"
    )]
    pub struct AggregatorDoesNotExist {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `AlreadyExecuted` with signature `AlreadyExecuted(bytes32)` and selector `0xd1d36dcd`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "AlreadyExecuted", abi = "AlreadyExecuted(bytes32)")]
    pub struct AlreadyExecuted {
        pub tx_hash: [u8; 32],
    }
    ///Custom Error type `AttestationQueueAlreadyExists` with signature `AttestationQueueAlreadyExists(address)` and selector `0x1179fb25`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "AttestationQueueAlreadyExists",
        abi = "AttestationQueueAlreadyExists(address)"
    )]
    pub struct AttestationQueueAlreadyExists {
        pub attestation_queue_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `AttestationQueueDoesNotExist` with signature `AttestationQueueDoesNotExist(address)` and selector `0x0da329cf`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "AttestationQueueDoesNotExist",
        abi = "AttestationQueueDoesNotExist(address)"
    )]
    pub struct AttestationQueueDoesNotExist {
        pub attestation_queue_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `CallExceededMaxGasCost` with signature `CallExceededMaxGasCost(address,uint256,uint256)` and selector `0x7ec28264`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "CallExceededMaxGasCost",
        abi = "CallExceededMaxGasCost(address,uint256,uint256)"
    )]
    pub struct CallExceededMaxGasCost {
        pub call_id: ::ethers::core::types::Address,
        pub expected: ::ethers::core::types::U256,
        pub received: ::ethers::core::types::U256,
    }
    ///Custom Error type `CallIdAlreadyExists` with signature `CallIdAlreadyExists(address)` and selector `0x2277cabb`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "CallIdAlreadyExists", abi = "CallIdAlreadyExists(address)")]
    pub struct CallIdAlreadyExists {
        pub call_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `ECDSAInvalidSignature` with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "ECDSAInvalidSignature", abi = "ECDSAInvalidSignature()")]
    pub struct ECDSAInvalidSignature;
    ///Custom Error type `ECDSAInvalidSignatureLength` with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "ECDSAInvalidSignatureLength",
        abi = "ECDSAInvalidSignatureLength(uint256)"
    )]
    pub struct ECDSAInvalidSignatureLength {
        pub length: ::ethers::core::types::U256,
    }
    ///Custom Error type `ECDSAInvalidSignatureS` with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "ECDSAInvalidSignatureS",
        abi = "ECDSAInvalidSignatureS(bytes32)"
    )]
    pub struct ECDSAInvalidSignatureS {
        pub s: [u8; 32],
    }
    ///Custom Error type `EarlyOracleResponse` with signature `EarlyOracleResponse(address)` and selector `0x9fcea1ba`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "EarlyOracleResponse", abi = "EarlyOracleResponse(address)")]
    pub struct EarlyOracleResponse {
        pub oracle_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `EnclaveAlreadyExists` with signature `EnclaveAlreadyExists(address)` and selector `0x3af924d6`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "EnclaveAlreadyExists", abi = "EnclaveAlreadyExists(address)")]
    pub struct EnclaveAlreadyExists {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `EnclaveDoesNotExist` with signature `EnclaveDoesNotExist(address)` and selector `0x5c3197cc`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "EnclaveDoesNotExist", abi = "EnclaveDoesNotExist(address)")]
    pub struct EnclaveDoesNotExist {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `EnclaveExpired` with signature `EnclaveExpired(address)` and selector `0xbc41a993`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "EnclaveExpired", abi = "EnclaveExpired(address)")]
    pub struct EnclaveExpired {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `EnclaveNotAtQueueIdx` with signature `EnclaveNotAtQueueIdx(address,address,uint256)` and selector `0x1967584e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "EnclaveNotAtQueueIdx",
        abi = "EnclaveNotAtQueueIdx(address,address,uint256)"
    )]
    pub struct EnclaveNotAtQueueIdx {
        pub queue_id: ::ethers::core::types::Address,
        pub enclave_id: ::ethers::core::types::Address,
        pub enclave_idx: ::ethers::core::types::U256,
    }
    ///Custom Error type `EnclaveNotFullyStaked` with signature `EnclaveNotFullyStaked(address)` and selector `0x784ed478`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "EnclaveNotFullyStaked", abi = "EnclaveNotFullyStaked(address)")]
    pub struct EnclaveNotFullyStaked {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `EnclaveNotOnQueue` with signature `EnclaveNotOnQueue(address,address)` and selector `0x4d7fe4fc`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "EnclaveNotOnQueue", abi = "EnclaveNotOnQueue(address,address)")]
    pub struct EnclaveNotOnQueue {
        pub queue_id: ::ethers::core::types::Address,
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `EnclaveNotReadyForVerification` with signature `EnclaveNotReadyForVerification(address)` and selector `0x089afb2c`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "EnclaveNotReadyForVerification",
        abi = "EnclaveNotReadyForVerification(address)"
    )]
    pub struct EnclaveNotReadyForVerification {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `EnclaveUnverified` with signature `EnclaveUnverified(address)` and selector `0x9eb833a0`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "EnclaveUnverified", abi = "EnclaveUnverified(address)")]
    pub struct EnclaveUnverified {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `ExcessiveGasSpent` with signature `ExcessiveGasSpent(uint256,uint256)` and selector `0x67c42515`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "ExcessiveGasSpent", abi = "ExcessiveGasSpent(uint256,uint256)")]
    pub struct ExcessiveGasSpent {
        pub gas_limit: ::ethers::core::types::U256,
        pub gas_spent: ::ethers::core::types::U256,
    }
    ///Custom Error type `ForceOverrideNotReady` with signature `ForceOverrideNotReady(address)` and selector `0xb209a6cc`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "ForceOverrideNotReady", abi = "ForceOverrideNotReady(address)")]
    pub struct ForceOverrideNotReady {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `FunctionAlreadyExists` with signature `FunctionAlreadyExists(address)` and selector `0x8f939dfd`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "FunctionAlreadyExists", abi = "FunctionAlreadyExists(address)")]
    pub struct FunctionAlreadyExists {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `FunctionCallerNotPermitted` with signature `FunctionCallerNotPermitted(address,address)` and selector `0x3926c8c8`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "FunctionCallerNotPermitted",
        abi = "FunctionCallerNotPermitted(address,address)"
    )]
    pub struct FunctionCallerNotPermitted {
        pub function_id: ::ethers::core::types::Address,
        pub sender: ::ethers::core::types::Address,
    }
    ///Custom Error type `FunctionDoesNotExist` with signature `FunctionDoesNotExist(address)` and selector `0x3c3b1d62`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "FunctionDoesNotExist", abi = "FunctionDoesNotExist(address)")]
    pub struct FunctionDoesNotExist {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `FunctionFeeTooLow` with signature `FunctionFeeTooLow(address,uint256,uint256)` and selector `0xf3663dbf`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "FunctionFeeTooLow",
        abi = "FunctionFeeTooLow(address,uint256,uint256)"
    )]
    pub struct FunctionFeeTooLow {
        pub function_id: ::ethers::core::types::Address,
        pub expected: ::ethers::core::types::U256,
        pub received: ::ethers::core::types::U256,
    }
    ///Custom Error type `FunctionIncorrectTarget` with signature `FunctionIncorrectTarget(address,address)` and selector `0xe726bd72`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "FunctionIncorrectTarget",
        abi = "FunctionIncorrectTarget(address,address)"
    )]
    pub struct FunctionIncorrectTarget {
        pub function_id: ::ethers::core::types::Address,
        pub received: ::ethers::core::types::Address,
    }
    ///Custom Error type `FunctionMrEnclaveMismatch` with signature `FunctionMrEnclaveMismatch(bytes32,bytes32)` and selector `0x552d918e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "FunctionMrEnclaveMismatch",
        abi = "FunctionMrEnclaveMismatch(bytes32,bytes32)"
    )]
    pub struct FunctionMrEnclaveMismatch {
        pub expected: [u8; 32],
        pub received: [u8; 32],
    }
    ///Custom Error type `FunctionSignerAlreadySet` with signature `FunctionSignerAlreadySet(address,address)` and selector `0xe2c62da7`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "FunctionSignerAlreadySet",
        abi = "FunctionSignerAlreadySet(address,address)"
    )]
    pub struct FunctionSignerAlreadySet {
        pub current: ::ethers::core::types::Address,
        pub received: ::ethers::core::types::Address,
    }
    ///Custom Error type `GasLimitExceeded` with signature `GasLimitExceeded(uint256,uint256)` and selector `0x1935f531`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "GasLimitExceeded", abi = "GasLimitExceeded(uint256,uint256)")]
    pub struct GasLimitExceeded {
        pub limit: ::ethers::core::types::U256,
        pub used: ::ethers::core::types::U256,
    }
    ///Custom Error type `Generic` with signature `Generic()` and selector `0xbf25017a`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "Generic", abi = "Generic()")]
    pub struct Generic;
    ///Custom Error type `IncorrectFunctionId` with signature `IncorrectFunctionId(address,address)` and selector `0xcf9ccae6`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "IncorrectFunctionId",
        abi = "IncorrectFunctionId(address,address)"
    )]
    pub struct IncorrectFunctionId {
        pub expected: ::ethers::core::types::Address,
        pub received: ::ethers::core::types::Address,
    }
    ///Custom Error type `IncorrectReportedTime` with signature `IncorrectReportedTime(uint256,uint256)` and selector `0x3ff1de92`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "IncorrectReportedTime",
        abi = "IncorrectReportedTime(uint256,uint256)"
    )]
    pub struct IncorrectReportedTime {
        pub max_expected_time: ::ethers::core::types::U256,
        pub reported_time: ::ethers::core::types::U256,
    }
    ///Custom Error type `IncorrectToken` with signature `IncorrectToken(address,address)` and selector `0x9334834f`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "IncorrectToken", abi = "IncorrectToken(address,address)")]
    pub struct IncorrectToken {
        pub expected: ::ethers::core::types::Address,
        pub received: ::ethers::core::types::Address,
    }
    ///Custom Error type `InitializationFunctionReverted` with signature `InitializationFunctionReverted(address,bytes)` and selector `0x192105d7`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "InitializationFunctionReverted",
        abi = "InitializationFunctionReverted(address,bytes)"
    )]
    pub struct InitializationFunctionReverted {
        pub initialization_contract_address: ::ethers::core::types::Address,
        pub calldata: ::ethers::core::types::Bytes,
    }
    ///Custom Error type `InsufficientBalance` with signature `InsufficientBalance(uint256,uint256)` and selector `0xcf479181`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "InsufficientBalance",
        abi = "InsufficientBalance(uint256,uint256)"
    )]
    pub struct InsufficientBalance {
        pub expected_balance: ::ethers::core::types::U256,
        pub received_balance: ::ethers::core::types::U256,
    }
    ///Custom Error type `InsufficientCallBalance` with signature `InsufficientCallBalance(address,uint256,uint256)` and selector `0x7bfbdd60`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "InsufficientCallBalance",
        abi = "InsufficientCallBalance(address,uint256,uint256)"
    )]
    pub struct InsufficientCallBalance {
        pub call_id: ::ethers::core::types::Address,
        pub expected: ::ethers::core::types::U256,
        pub received: ::ethers::core::types::U256,
    }
    ///Custom Error type `InsufficientCallFeePaid` with signature `InsufficientCallFeePaid(address,uint256,uint256)` and selector `0xc6477cc1`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "InsufficientCallFeePaid",
        abi = "InsufficientCallFeePaid(address,uint256,uint256)"
    )]
    pub struct InsufficientCallFeePaid {
        pub call_id: ::ethers::core::types::Address,
        pub expected: ::ethers::core::types::U256,
        pub received: ::ethers::core::types::U256,
    }
    ///Custom Error type `InsufficientNodes` with signature `InsufficientNodes(uint256,uint256)` and selector `0x3c1222b1`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InsufficientNodes", abi = "InsufficientNodes(uint256,uint256)")]
    pub struct InsufficientNodes {
        pub expected: ::ethers::core::types::U256,
        pub received: ::ethers::core::types::U256,
    }
    ///Custom Error type `InsufficientSamples` with signature `InsufficientSamples(uint256,uint256)` and selector `0x53b15160`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "InsufficientSamples",
        abi = "InsufficientSamples(uint256,uint256)"
    )]
    pub struct InsufficientSamples {
        pub expected: ::ethers::core::types::U256,
        pub received: ::ethers::core::types::U256,
    }
    ///Custom Error type `IntervalHistoryNotRecorded` with signature `IntervalHistoryNotRecorded(address)` and selector `0xedfa5607`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "IntervalHistoryNotRecorded",
        abi = "IntervalHistoryNotRecorded(address)"
    )]
    pub struct IntervalHistoryNotRecorded {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `InvalidArgument` with signature `InvalidArgument(uint256)` and selector `0xd14e7c9b`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InvalidArgument", abi = "InvalidArgument(uint256)")]
    pub struct InvalidArgument {
        pub argument_index: ::ethers::core::types::U256,
    }
    ///Custom Error type `InvalidAuthority` with signature `InvalidAuthority(address,address)` and selector `0xbf89df83`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InvalidAuthority", abi = "InvalidAuthority(address,address)")]
    pub struct InvalidAuthority {
        pub expected_authority: ::ethers::core::types::Address,
        pub received_authority: ::ethers::core::types::Address,
    }
    ///Custom Error type `InvalidCallId` with signature `InvalidCallId(address)` and selector `0xddd63c15`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InvalidCallId", abi = "InvalidCallId(address)")]
    pub struct InvalidCallId {
        pub call_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `InvalidCallbackParams` with signature `InvalidCallbackParams(address,bytes32)` and selector `0x1c6cea40`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "InvalidCallbackParams",
        abi = "InvalidCallbackParams(address,bytes32)"
    )]
    pub struct InvalidCallbackParams {
        pub call_id: ::ethers::core::types::Address,
        pub hash: [u8; 32],
    }
    ///Custom Error type `InvalidEnclave` with signature `InvalidEnclave(address)` and selector `0x8bec1a4e`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InvalidEnclave", abi = "InvalidEnclave(address)")]
    pub struct InvalidEnclave {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `InvalidEntry` with signature `InvalidEntry()` and selector `0x887efaa5`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InvalidEntry", abi = "InvalidEntry()")]
    pub struct InvalidEntry;
    ///Custom Error type `InvalidRoutineId` with signature `InvalidRoutineId(address)` and selector `0x0b532497`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InvalidRoutineId", abi = "InvalidRoutineId(address)")]
    pub struct InvalidRoutineId {
        pub routine_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `InvalidSignature` with signature `InvalidSignature(address,bytes32,bytes)` and selector `0xd491963d`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "InvalidSignature",
        abi = "InvalidSignature(address,bytes32,bytes)"
    )]
    pub struct InvalidSignature {
        pub expected_sender: ::ethers::core::types::Address,
        pub tx_hash: [u8; 32],
        pub signature: ::ethers::core::types::Bytes,
    }
    ///Custom Error type `InvalidSigner` with signature `InvalidSigner(address,address)` and selector `0x7ba5ffb5`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InvalidSigner", abi = "InvalidSigner(address,address)")]
    pub struct InvalidSigner {
        pub expected_signer: ::ethers::core::types::Address,
        pub received_signer: ::ethers::core::types::Address,
    }
    ///Custom Error type `InvalidStatus` with signature `InvalidStatus(address,uint256,uint256)` and selector `0xee56daf8`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "InvalidStatus", abi = "InvalidStatus(address,uint256,uint256)")]
    pub struct InvalidStatus {
        pub account: ::ethers::core::types::Address,
        pub expected: ::ethers::core::types::U256,
        pub received: ::ethers::core::types::U256,
    }
    ///Custom Error type `MrEnclaveNotAllowed` with signature `MrEnclaveNotAllowed(address,bytes32)` and selector `0x93fc1a13`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "MrEnclaveNotAllowed",
        abi = "MrEnclaveNotAllowed(address,bytes32)"
    )]
    pub struct MrEnclaveNotAllowed {
        pub queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    ///Custom Error type `OracleAlreadyExists` with signature `OracleAlreadyExists(address)` and selector `0x07fefd1f`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "OracleAlreadyExists", abi = "OracleAlreadyExists(address)")]
    pub struct OracleAlreadyExists {
        pub oracle_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `OracleExpired` with signature `OracleExpired(address)` and selector `0xf7eac043`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "OracleExpired", abi = "OracleExpired(address)")]
    pub struct OracleExpired {
        pub oracle_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `OracleNotAtQueueIdx` with signature `OracleNotAtQueueIdx(address,address,uint256)` and selector `0x6dddf077`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "OracleNotAtQueueIdx",
        abi = "OracleNotAtQueueIdx(address,address,uint256)"
    )]
    pub struct OracleNotAtQueueIdx {
        pub queue_id: ::ethers::core::types::Address,
        pub oracle_id: ::ethers::core::types::Address,
        pub oracle_idx: ::ethers::core::types::U256,
    }
    ///Custom Error type `OracleNotOnQueue` with signature `OracleNotOnQueue(address,address)` and selector `0xcd5d2b06`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "OracleNotOnQueue", abi = "OracleNotOnQueue(address,address)")]
    pub struct OracleNotOnQueue {
        pub queue_id: ::ethers::core::types::Address,
        pub oracle_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `OracleQueueDoesNotExist` with signature `OracleQueueDoesNotExist(address)` and selector `0xaf9b8e16`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "OracleQueueDoesNotExist",
        abi = "OracleQueueDoesNotExist(address)"
    )]
    pub struct OracleQueueDoesNotExist {
        pub oracle_queue_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `PermissionDenied` with signature `PermissionDenied(address,address,uint256)` and selector `0xe65cb5d3`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "PermissionDenied",
        abi = "PermissionDenied(address,address,uint256)"
    )]
    pub struct PermissionDenied {
        pub granter: ::ethers::core::types::Address,
        pub grantee: ::ethers::core::types::Address,
        pub permission: ::ethers::core::types::U256,
    }
    ///Custom Error type `QueuesDoNotMatch` with signature `QueuesDoNotMatch(address,address)` and selector `0x2b69267c`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "QueuesDoNotMatch", abi = "QueuesDoNotMatch(address,address)")]
    pub struct QueuesDoNotMatch {
        pub expected_queue_id: ::ethers::core::types::Address,
        pub received_queue_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `RequestAlreadyExists` with signature `RequestAlreadyExists(address)` and selector `0x0b5bc361`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "RequestAlreadyExists", abi = "RequestAlreadyExists(address)")]
    pub struct RequestAlreadyExists {
        pub request_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `RequestIdAlreadyExists` with signature `RequestIdAlreadyExists(address)` and selector `0xfefd00d8`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "RequestIdAlreadyExists",
        abi = "RequestIdAlreadyExists(address)"
    )]
    pub struct RequestIdAlreadyExists {
        pub request_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `RoutineIdAlreadyExists` with signature `RoutineIdAlreadyExists(address)` and selector `0x704f61ed`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "RoutineIdAlreadyExists",
        abi = "RoutineIdAlreadyExists(address)"
    )]
    pub struct RoutineIdAlreadyExists {
        pub routine_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `RoutinesDisabled` with signature `RoutinesDisabled(address)` and selector `0xe71fe28b`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "RoutinesDisabled", abi = "RoutinesDisabled(address)")]
    pub struct RoutinesDisabled {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Custom Error type `StakeNotReady` with signature `StakeNotReady(address,address,uint256)` and selector `0x8be9b6b3`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "StakeNotReady", abi = "StakeNotReady(address,address,uint256)")]
    pub struct StakeNotReady {
        pub queue_id: ::ethers::core::types::Address,
        pub staker: ::ethers::core::types::Address,
        pub ready_at: ::ethers::core::types::U256,
    }
    ///Custom Error type `StakeNotReadyForWithdrawal` with signature `StakeNotReadyForWithdrawal(address,address,uint256)` and selector `0xc026a454`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "StakeNotReadyForWithdrawal",
        abi = "StakeNotReadyForWithdrawal(address,address,uint256)"
    )]
    pub struct StakeNotReadyForWithdrawal {
        pub queue_id: ::ethers::core::types::Address,
        pub staker: ::ethers::core::types::Address,
        pub ready_at: ::ethers::core::types::U256,
    }
    ///Custom Error type `SubmittedResultsMismatch` with signature `SubmittedResultsMismatch(uint256,uint256)` and selector `0xc7d91853`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "SubmittedResultsMismatch",
        abi = "SubmittedResultsMismatch(uint256,uint256)"
    )]
    pub struct SubmittedResultsMismatch {
        pub aggregators: ::ethers::core::types::U256,
        pub results: ::ethers::core::types::U256,
    }
    ///Custom Error type `TokenTransferFailure` with signature `TokenTransferFailure(address,address,uint256)` and selector `0x95eb946f`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(
        name = "TokenTransferFailure",
        abi = "TokenTransferFailure(address,address,uint256)"
    )]
    pub struct TokenTransferFailure {
        pub token: ::ethers::core::types::Address,
        pub to: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Custom Error type `TransactionExpired` with signature `TransactionExpired(uint256)` and selector `0x6634e923`
    #[derive(
        Clone,
        ::ethers::contract::EthError,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[etherror(name = "TransactionExpired", abi = "TransactionExpired(uint256)")]
    pub struct TransactionExpired {
        pub expiration_time: ::ethers::core::types::U256,
    }
    ///Container type for all of the contract's custom errors
    #[derive(Clone, ::ethers::contract::EthAbiType, Debug, PartialEq, Eq, Hash)]
    pub enum SwitchboardErrors {
        ACLAdminAlreadyInitialized(ACLAdminAlreadyInitialized),
        ACLNotAdmin(ACLNotAdmin),
        ACLNotAllowed(ACLNotAllowed),
        AggregatorAlreadyExists(AggregatorAlreadyExists),
        AggregatorDoesNotExist(AggregatorDoesNotExist),
        AlreadyExecuted(AlreadyExecuted),
        AttestationQueueAlreadyExists(AttestationQueueAlreadyExists),
        AttestationQueueDoesNotExist(AttestationQueueDoesNotExist),
        CallExceededMaxGasCost(CallExceededMaxGasCost),
        CallIdAlreadyExists(CallIdAlreadyExists),
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        EarlyOracleResponse(EarlyOracleResponse),
        EnclaveAlreadyExists(EnclaveAlreadyExists),
        EnclaveDoesNotExist(EnclaveDoesNotExist),
        EnclaveExpired(EnclaveExpired),
        EnclaveNotAtQueueIdx(EnclaveNotAtQueueIdx),
        EnclaveNotFullyStaked(EnclaveNotFullyStaked),
        EnclaveNotOnQueue(EnclaveNotOnQueue),
        EnclaveNotReadyForVerification(EnclaveNotReadyForVerification),
        EnclaveUnverified(EnclaveUnverified),
        ExcessiveGasSpent(ExcessiveGasSpent),
        ForceOverrideNotReady(ForceOverrideNotReady),
        FunctionAlreadyExists(FunctionAlreadyExists),
        FunctionCallerNotPermitted(FunctionCallerNotPermitted),
        FunctionDoesNotExist(FunctionDoesNotExist),
        FunctionFeeTooLow(FunctionFeeTooLow),
        FunctionIncorrectTarget(FunctionIncorrectTarget),
        FunctionMrEnclaveMismatch(FunctionMrEnclaveMismatch),
        FunctionSignerAlreadySet(FunctionSignerAlreadySet),
        GasLimitExceeded(GasLimitExceeded),
        Generic(Generic),
        IncorrectFunctionId(IncorrectFunctionId),
        IncorrectReportedTime(IncorrectReportedTime),
        IncorrectToken(IncorrectToken),
        InitializationFunctionReverted(InitializationFunctionReverted),
        InsufficientBalance(InsufficientBalance),
        InsufficientCallBalance(InsufficientCallBalance),
        InsufficientCallFeePaid(InsufficientCallFeePaid),
        InsufficientNodes(InsufficientNodes),
        InsufficientSamples(InsufficientSamples),
        IntervalHistoryNotRecorded(IntervalHistoryNotRecorded),
        InvalidArgument(InvalidArgument),
        InvalidAuthority(InvalidAuthority),
        InvalidCallId(InvalidCallId),
        InvalidCallbackParams(InvalidCallbackParams),
        InvalidEnclave(InvalidEnclave),
        InvalidEntry(InvalidEntry),
        InvalidRoutineId(InvalidRoutineId),
        InvalidSignature(InvalidSignature),
        InvalidSigner(InvalidSigner),
        InvalidStatus(InvalidStatus),
        MrEnclaveNotAllowed(MrEnclaveNotAllowed),
        OracleAlreadyExists(OracleAlreadyExists),
        OracleExpired(OracleExpired),
        OracleNotAtQueueIdx(OracleNotAtQueueIdx),
        OracleNotOnQueue(OracleNotOnQueue),
        OracleQueueDoesNotExist(OracleQueueDoesNotExist),
        PermissionDenied(PermissionDenied),
        QueuesDoNotMatch(QueuesDoNotMatch),
        RequestAlreadyExists(RequestAlreadyExists),
        RequestIdAlreadyExists(RequestIdAlreadyExists),
        RoutineIdAlreadyExists(RoutineIdAlreadyExists),
        RoutinesDisabled(RoutinesDisabled),
        StakeNotReady(StakeNotReady),
        StakeNotReadyForWithdrawal(StakeNotReadyForWithdrawal),
        SubmittedResultsMismatch(SubmittedResultsMismatch),
        TokenTransferFailure(TokenTransferFailure),
        TransactionExpired(TransactionExpired),
        /// The standard solidity revert string, with selector
        /// Error(string) -- 0x08c379a0
        RevertString(::std::string::String),
    }
    impl ::ethers::core::abi::AbiDecode for SwitchboardErrors {
        fn decode(
            data: impl AsRef<[u8]>,
        ) -> ::core::result::Result<Self, ::ethers::core::abi::AbiError> {
            let data = data.as_ref();
            if let Ok(decoded) =
                <::std::string::String as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RevertString(decoded));
            }
            if let Ok(decoded) =
                <ACLAdminAlreadyInitialized as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ACLAdminAlreadyInitialized(decoded));
            }
            if let Ok(decoded) = <ACLNotAdmin as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::ACLNotAdmin(decoded));
            }
            if let Ok(decoded) = <ACLNotAllowed as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::ACLNotAllowed(decoded));
            }
            if let Ok(decoded) =
                <AggregatorAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AggregatorAlreadyExists(decoded));
            }
            if let Ok(decoded) =
                <AggregatorDoesNotExist as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AggregatorDoesNotExist(decoded));
            }
            if let Ok(decoded) = <AlreadyExecuted as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::AlreadyExecuted(decoded));
            }
            if let Ok(decoded) =
                <AttestationQueueAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AttestationQueueAlreadyExists(decoded));
            }
            if let Ok(decoded) =
                <AttestationQueueDoesNotExist as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AttestationQueueDoesNotExist(decoded));
            }
            if let Ok(decoded) =
                <CallExceededMaxGasCost as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CallExceededMaxGasCost(decoded));
            }
            if let Ok(decoded) =
                <CallIdAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CallIdAlreadyExists(decoded));
            }
            if let Ok(decoded) =
                <ECDSAInvalidSignature as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ECDSAInvalidSignature(decoded));
            }
            if let Ok(decoded) =
                <ECDSAInvalidSignatureLength as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ECDSAInvalidSignatureLength(decoded));
            }
            if let Ok(decoded) =
                <ECDSAInvalidSignatureS as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ECDSAInvalidSignatureS(decoded));
            }
            if let Ok(decoded) =
                <EarlyOracleResponse as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EarlyOracleResponse(decoded));
            }
            if let Ok(decoded) =
                <EnclaveAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveAlreadyExists(decoded));
            }
            if let Ok(decoded) =
                <EnclaveDoesNotExist as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveDoesNotExist(decoded));
            }
            if let Ok(decoded) = <EnclaveExpired as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::EnclaveExpired(decoded));
            }
            if let Ok(decoded) =
                <EnclaveNotAtQueueIdx as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveNotAtQueueIdx(decoded));
            }
            if let Ok(decoded) =
                <EnclaveNotFullyStaked as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveNotFullyStaked(decoded));
            }
            if let Ok(decoded) = <EnclaveNotOnQueue as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveNotOnQueue(decoded));
            }
            if let Ok(decoded) =
                <EnclaveNotReadyForVerification as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveNotReadyForVerification(decoded));
            }
            if let Ok(decoded) = <EnclaveUnverified as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveUnverified(decoded));
            }
            if let Ok(decoded) = <ExcessiveGasSpent as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ExcessiveGasSpent(decoded));
            }
            if let Ok(decoded) =
                <ForceOverrideNotReady as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ForceOverrideNotReady(decoded));
            }
            if let Ok(decoded) =
                <FunctionAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionAlreadyExists(decoded));
            }
            if let Ok(decoded) =
                <FunctionCallerNotPermitted as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionCallerNotPermitted(decoded));
            }
            if let Ok(decoded) =
                <FunctionDoesNotExist as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionDoesNotExist(decoded));
            }
            if let Ok(decoded) = <FunctionFeeTooLow as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionFeeTooLow(decoded));
            }
            if let Ok(decoded) =
                <FunctionIncorrectTarget as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionIncorrectTarget(decoded));
            }
            if let Ok(decoded) =
                <FunctionMrEnclaveMismatch as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionMrEnclaveMismatch(decoded));
            }
            if let Ok(decoded) =
                <FunctionSignerAlreadySet as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionSignerAlreadySet(decoded));
            }
            if let Ok(decoded) = <GasLimitExceeded as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GasLimitExceeded(decoded));
            }
            if let Ok(decoded) = <Generic as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Generic(decoded));
            }
            if let Ok(decoded) =
                <IncorrectFunctionId as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::IncorrectFunctionId(decoded));
            }
            if let Ok(decoded) =
                <IncorrectReportedTime as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::IncorrectReportedTime(decoded));
            }
            if let Ok(decoded) = <IncorrectToken as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::IncorrectToken(decoded));
            }
            if let Ok(decoded) =
                <InitializationFunctionReverted as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InitializationFunctionReverted(decoded));
            }
            if let Ok(decoded) =
                <InsufficientBalance as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InsufficientBalance(decoded));
            }
            if let Ok(decoded) =
                <InsufficientCallBalance as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InsufficientCallBalance(decoded));
            }
            if let Ok(decoded) =
                <InsufficientCallFeePaid as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InsufficientCallFeePaid(decoded));
            }
            if let Ok(decoded) = <InsufficientNodes as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InsufficientNodes(decoded));
            }
            if let Ok(decoded) =
                <InsufficientSamples as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InsufficientSamples(decoded));
            }
            if let Ok(decoded) =
                <IntervalHistoryNotRecorded as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::IntervalHistoryNotRecorded(decoded));
            }
            if let Ok(decoded) = <InvalidArgument as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::InvalidArgument(decoded));
            }
            if let Ok(decoded) = <InvalidAuthority as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InvalidAuthority(decoded));
            }
            if let Ok(decoded) = <InvalidCallId as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::InvalidCallId(decoded));
            }
            if let Ok(decoded) =
                <InvalidCallbackParams as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InvalidCallbackParams(decoded));
            }
            if let Ok(decoded) = <InvalidEnclave as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::InvalidEnclave(decoded));
            }
            if let Ok(decoded) = <InvalidEntry as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::InvalidEntry(decoded));
            }
            if let Ok(decoded) = <InvalidRoutineId as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InvalidRoutineId(decoded));
            }
            if let Ok(decoded) = <InvalidSignature as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::InvalidSignature(decoded));
            }
            if let Ok(decoded) = <InvalidSigner as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::InvalidSigner(decoded));
            }
            if let Ok(decoded) = <InvalidStatus as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::InvalidStatus(decoded));
            }
            if let Ok(decoded) =
                <MrEnclaveNotAllowed as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::MrEnclaveNotAllowed(decoded));
            }
            if let Ok(decoded) =
                <OracleAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::OracleAlreadyExists(decoded));
            }
            if let Ok(decoded) = <OracleExpired as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::OracleExpired(decoded));
            }
            if let Ok(decoded) =
                <OracleNotAtQueueIdx as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::OracleNotAtQueueIdx(decoded));
            }
            if let Ok(decoded) = <OracleNotOnQueue as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::OracleNotOnQueue(decoded));
            }
            if let Ok(decoded) =
                <OracleQueueDoesNotExist as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::OracleQueueDoesNotExist(decoded));
            }
            if let Ok(decoded) = <PermissionDenied as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::PermissionDenied(decoded));
            }
            if let Ok(decoded) = <QueuesDoNotMatch as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::QueuesDoNotMatch(decoded));
            }
            if let Ok(decoded) =
                <RequestAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RequestAlreadyExists(decoded));
            }
            if let Ok(decoded) =
                <RequestIdAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RequestIdAlreadyExists(decoded));
            }
            if let Ok(decoded) =
                <RoutineIdAlreadyExists as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RoutineIdAlreadyExists(decoded));
            }
            if let Ok(decoded) = <RoutinesDisabled as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RoutinesDisabled(decoded));
            }
            if let Ok(decoded) = <StakeNotReady as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::StakeNotReady(decoded));
            }
            if let Ok(decoded) =
                <StakeNotReadyForWithdrawal as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::StakeNotReadyForWithdrawal(decoded));
            }
            if let Ok(decoded) =
                <SubmittedResultsMismatch as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SubmittedResultsMismatch(decoded));
            }
            if let Ok(decoded) =
                <TokenTransferFailure as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::TokenTransferFailure(decoded));
            }
            if let Ok(decoded) =
                <TransactionExpired as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::TransactionExpired(decoded));
            }
            Err(::ethers::core::abi::Error::InvalidData.into())
        }
    }
    impl ::ethers::core::abi::AbiEncode for SwitchboardErrors {
        fn encode(self) -> ::std::vec::Vec<u8> {
            match self {
                Self::ACLAdminAlreadyInitialized(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ACLNotAdmin(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::ACLNotAllowed(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::AggregatorAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AggregatorDoesNotExist(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AlreadyExecuted(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::AttestationQueueAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AttestationQueueDoesNotExist(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CallExceededMaxGasCost(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CallIdAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ECDSAInvalidSignature(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ECDSAInvalidSignatureLength(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ECDSAInvalidSignatureS(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EarlyOracleResponse(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EnclaveAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EnclaveDoesNotExist(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EnclaveExpired(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::EnclaveNotAtQueueIdx(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EnclaveNotFullyStaked(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EnclaveNotOnQueue(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::EnclaveNotReadyForVerification(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EnclaveUnverified(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::ExcessiveGasSpent(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::ForceOverrideNotReady(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionCallerNotPermitted(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionDoesNotExist(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionFeeTooLow(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FunctionIncorrectTarget(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionMrEnclaveMismatch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionSignerAlreadySet(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GasLimitExceeded(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Generic(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::IncorrectFunctionId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IncorrectReportedTime(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IncorrectToken(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InitializationFunctionReverted(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InsufficientBalance(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InsufficientCallBalance(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InsufficientCallFeePaid(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InsufficientNodes(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InsufficientSamples(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::IntervalHistoryNotRecorded(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InvalidArgument(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InvalidAuthority(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InvalidCallId(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InvalidCallbackParams(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::InvalidEnclave(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InvalidEntry(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InvalidRoutineId(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InvalidSignature(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InvalidSigner(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::InvalidStatus(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::MrEnclaveNotAllowed(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::OracleAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::OracleExpired(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::OracleNotAtQueueIdx(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::OracleNotOnQueue(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::OracleQueueDoesNotExist(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::PermissionDenied(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::QueuesDoNotMatch(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::RequestAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RequestIdAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RoutineIdAlreadyExists(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RoutinesDisabled(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::StakeNotReady(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::StakeNotReadyForWithdrawal(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SubmittedResultsMismatch(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TokenTransferFailure(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::TransactionExpired(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RevertString(s) => ::ethers::core::abi::AbiEncode::encode(s),
            }
        }
    }
    impl ::ethers::contract::ContractRevert for SwitchboardErrors {
        fn valid_selector(selector: [u8; 4]) -> bool {
            match selector {
                [0x08, 0xc3, 0x79, 0xa0] => true,
                _ if selector
                    == <ACLAdminAlreadyInitialized as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ACLNotAdmin as ::ethers::contract::EthError>::selector() => true,
                _ if selector
                    == <ACLNotAllowed as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <AggregatorAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <AggregatorDoesNotExist as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <AlreadyExecuted as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <AttestationQueueAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <AttestationQueueDoesNotExist as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CallExceededMaxGasCost as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <CallIdAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ECDSAInvalidSignature as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ECDSAInvalidSignatureLength as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ECDSAInvalidSignatureS as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EarlyOracleResponse as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EnclaveAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EnclaveDoesNotExist as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EnclaveExpired as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EnclaveNotAtQueueIdx as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EnclaveNotFullyStaked as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EnclaveNotOnQueue as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EnclaveNotReadyForVerification as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <EnclaveUnverified as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ExcessiveGasSpent as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <ForceOverrideNotReady as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <FunctionAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <FunctionCallerNotPermitted as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <FunctionDoesNotExist as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <FunctionFeeTooLow as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <FunctionIncorrectTarget as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <FunctionMrEnclaveMismatch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <FunctionSignerAlreadySet as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <GasLimitExceeded as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <Generic as ::ethers::contract::EthError>::selector() => true,
                _ if selector
                    == <IncorrectFunctionId as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <IncorrectReportedTime as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <IncorrectToken as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InitializationFunctionReverted as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InsufficientBalance as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InsufficientCallBalance as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InsufficientCallFeePaid as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InsufficientNodes as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InsufficientSamples as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <IntervalHistoryNotRecorded as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidArgument as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidAuthority as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidCallId as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidCallbackParams as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidEnclave as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidEntry as ::ethers::contract::EthError>::selector() => true,
                _ if selector
                    == <InvalidRoutineId as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidSignature as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidSigner as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <InvalidStatus as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <MrEnclaveNotAllowed as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <OracleAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <OracleExpired as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <OracleNotAtQueueIdx as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <OracleNotOnQueue as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <OracleQueueDoesNotExist as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <PermissionDenied as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <QueuesDoNotMatch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <RequestAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <RequestIdAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <RoutineIdAlreadyExists as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <RoutinesDisabled as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <StakeNotReady as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <StakeNotReadyForWithdrawal as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <SubmittedResultsMismatch as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <TokenTransferFailure as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ if selector
                    == <TransactionExpired as ::ethers::contract::EthError>::selector() => {
                    true
                }
                _ => false,
            }
        }
    }
    impl ::core::fmt::Display for SwitchboardErrors {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
                Self::ACLAdminAlreadyInitialized(element) => ::core::fmt::Display::fmt(element, f),
                Self::ACLNotAdmin(element) => ::core::fmt::Display::fmt(element, f),
                Self::ACLNotAllowed(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorAlreadyExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorDoesNotExist(element) => ::core::fmt::Display::fmt(element, f),
                Self::AlreadyExecuted(element) => ::core::fmt::Display::fmt(element, f),
                Self::AttestationQueueAlreadyExists(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AttestationQueueDoesNotExist(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::CallExceededMaxGasCost(element) => ::core::fmt::Display::fmt(element, f),
                Self::CallIdAlreadyExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::ECDSAInvalidSignature(element) => ::core::fmt::Display::fmt(element, f),
                Self::ECDSAInvalidSignatureLength(element) => ::core::fmt::Display::fmt(element, f),
                Self::ECDSAInvalidSignatureS(element) => ::core::fmt::Display::fmt(element, f),
                Self::EarlyOracleResponse(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveAlreadyExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveDoesNotExist(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveExpired(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveNotAtQueueIdx(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveNotFullyStaked(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveNotOnQueue(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveNotReadyForVerification(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::EnclaveUnverified(element) => ::core::fmt::Display::fmt(element, f),
                Self::ExcessiveGasSpent(element) => ::core::fmt::Display::fmt(element, f),
                Self::ForceOverrideNotReady(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionAlreadyExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionCallerNotPermitted(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionDoesNotExist(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionFeeTooLow(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionIncorrectTarget(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionMrEnclaveMismatch(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionSignerAlreadySet(element) => ::core::fmt::Display::fmt(element, f),
                Self::GasLimitExceeded(element) => ::core::fmt::Display::fmt(element, f),
                Self::Generic(element) => ::core::fmt::Display::fmt(element, f),
                Self::IncorrectFunctionId(element) => ::core::fmt::Display::fmt(element, f),
                Self::IncorrectReportedTime(element) => ::core::fmt::Display::fmt(element, f),
                Self::IncorrectToken(element) => ::core::fmt::Display::fmt(element, f),
                Self::InitializationFunctionReverted(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::InsufficientBalance(element) => ::core::fmt::Display::fmt(element, f),
                Self::InsufficientCallBalance(element) => ::core::fmt::Display::fmt(element, f),
                Self::InsufficientCallFeePaid(element) => ::core::fmt::Display::fmt(element, f),
                Self::InsufficientNodes(element) => ::core::fmt::Display::fmt(element, f),
                Self::InsufficientSamples(element) => ::core::fmt::Display::fmt(element, f),
                Self::IntervalHistoryNotRecorded(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidArgument(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidAuthority(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidCallId(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidCallbackParams(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidEnclave(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidEntry(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidRoutineId(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidSignature(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidSigner(element) => ::core::fmt::Display::fmt(element, f),
                Self::InvalidStatus(element) => ::core::fmt::Display::fmt(element, f),
                Self::MrEnclaveNotAllowed(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleAlreadyExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleExpired(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleNotAtQueueIdx(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleNotOnQueue(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleQueueDoesNotExist(element) => ::core::fmt::Display::fmt(element, f),
                Self::PermissionDenied(element) => ::core::fmt::Display::fmt(element, f),
                Self::QueuesDoNotMatch(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestAlreadyExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestIdAlreadyExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::RoutineIdAlreadyExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::RoutinesDisabled(element) => ::core::fmt::Display::fmt(element, f),
                Self::StakeNotReady(element) => ::core::fmt::Display::fmt(element, f),
                Self::StakeNotReadyForWithdrawal(element) => ::core::fmt::Display::fmt(element, f),
                Self::SubmittedResultsMismatch(element) => ::core::fmt::Display::fmt(element, f),
                Self::TokenTransferFailure(element) => ::core::fmt::Display::fmt(element, f),
                Self::TransactionExpired(element) => ::core::fmt::Display::fmt(element, f),
                Self::RevertString(s) => ::core::fmt::Display::fmt(s, f),
            }
        }
    }
    impl ::core::convert::From<::std::string::String> for SwitchboardErrors {
        fn from(value: String) -> Self {
            Self::RevertString(value)
        }
    }
    impl ::core::convert::From<ACLAdminAlreadyInitialized> for SwitchboardErrors {
        fn from(value: ACLAdminAlreadyInitialized) -> Self {
            Self::ACLAdminAlreadyInitialized(value)
        }
    }
    impl ::core::convert::From<ACLNotAdmin> for SwitchboardErrors {
        fn from(value: ACLNotAdmin) -> Self {
            Self::ACLNotAdmin(value)
        }
    }
    impl ::core::convert::From<ACLNotAllowed> for SwitchboardErrors {
        fn from(value: ACLNotAllowed) -> Self {
            Self::ACLNotAllowed(value)
        }
    }
    impl ::core::convert::From<AggregatorAlreadyExists> for SwitchboardErrors {
        fn from(value: AggregatorAlreadyExists) -> Self {
            Self::AggregatorAlreadyExists(value)
        }
    }
    impl ::core::convert::From<AggregatorDoesNotExist> for SwitchboardErrors {
        fn from(value: AggregatorDoesNotExist) -> Self {
            Self::AggregatorDoesNotExist(value)
        }
    }
    impl ::core::convert::From<AlreadyExecuted> for SwitchboardErrors {
        fn from(value: AlreadyExecuted) -> Self {
            Self::AlreadyExecuted(value)
        }
    }
    impl ::core::convert::From<AttestationQueueAlreadyExists> for SwitchboardErrors {
        fn from(value: AttestationQueueAlreadyExists) -> Self {
            Self::AttestationQueueAlreadyExists(value)
        }
    }
    impl ::core::convert::From<AttestationQueueDoesNotExist> for SwitchboardErrors {
        fn from(value: AttestationQueueDoesNotExist) -> Self {
            Self::AttestationQueueDoesNotExist(value)
        }
    }
    impl ::core::convert::From<CallExceededMaxGasCost> for SwitchboardErrors {
        fn from(value: CallExceededMaxGasCost) -> Self {
            Self::CallExceededMaxGasCost(value)
        }
    }
    impl ::core::convert::From<CallIdAlreadyExists> for SwitchboardErrors {
        fn from(value: CallIdAlreadyExists) -> Self {
            Self::CallIdAlreadyExists(value)
        }
    }
    impl ::core::convert::From<ECDSAInvalidSignature> for SwitchboardErrors {
        fn from(value: ECDSAInvalidSignature) -> Self {
            Self::ECDSAInvalidSignature(value)
        }
    }
    impl ::core::convert::From<ECDSAInvalidSignatureLength> for SwitchboardErrors {
        fn from(value: ECDSAInvalidSignatureLength) -> Self {
            Self::ECDSAInvalidSignatureLength(value)
        }
    }
    impl ::core::convert::From<ECDSAInvalidSignatureS> for SwitchboardErrors {
        fn from(value: ECDSAInvalidSignatureS) -> Self {
            Self::ECDSAInvalidSignatureS(value)
        }
    }
    impl ::core::convert::From<EarlyOracleResponse> for SwitchboardErrors {
        fn from(value: EarlyOracleResponse) -> Self {
            Self::EarlyOracleResponse(value)
        }
    }
    impl ::core::convert::From<EnclaveAlreadyExists> for SwitchboardErrors {
        fn from(value: EnclaveAlreadyExists) -> Self {
            Self::EnclaveAlreadyExists(value)
        }
    }
    impl ::core::convert::From<EnclaveDoesNotExist> for SwitchboardErrors {
        fn from(value: EnclaveDoesNotExist) -> Self {
            Self::EnclaveDoesNotExist(value)
        }
    }
    impl ::core::convert::From<EnclaveExpired> for SwitchboardErrors {
        fn from(value: EnclaveExpired) -> Self {
            Self::EnclaveExpired(value)
        }
    }
    impl ::core::convert::From<EnclaveNotAtQueueIdx> for SwitchboardErrors {
        fn from(value: EnclaveNotAtQueueIdx) -> Self {
            Self::EnclaveNotAtQueueIdx(value)
        }
    }
    impl ::core::convert::From<EnclaveNotFullyStaked> for SwitchboardErrors {
        fn from(value: EnclaveNotFullyStaked) -> Self {
            Self::EnclaveNotFullyStaked(value)
        }
    }
    impl ::core::convert::From<EnclaveNotOnQueue> for SwitchboardErrors {
        fn from(value: EnclaveNotOnQueue) -> Self {
            Self::EnclaveNotOnQueue(value)
        }
    }
    impl ::core::convert::From<EnclaveNotReadyForVerification> for SwitchboardErrors {
        fn from(value: EnclaveNotReadyForVerification) -> Self {
            Self::EnclaveNotReadyForVerification(value)
        }
    }
    impl ::core::convert::From<EnclaveUnverified> for SwitchboardErrors {
        fn from(value: EnclaveUnverified) -> Self {
            Self::EnclaveUnverified(value)
        }
    }
    impl ::core::convert::From<ExcessiveGasSpent> for SwitchboardErrors {
        fn from(value: ExcessiveGasSpent) -> Self {
            Self::ExcessiveGasSpent(value)
        }
    }
    impl ::core::convert::From<ForceOverrideNotReady> for SwitchboardErrors {
        fn from(value: ForceOverrideNotReady) -> Self {
            Self::ForceOverrideNotReady(value)
        }
    }
    impl ::core::convert::From<FunctionAlreadyExists> for SwitchboardErrors {
        fn from(value: FunctionAlreadyExists) -> Self {
            Self::FunctionAlreadyExists(value)
        }
    }
    impl ::core::convert::From<FunctionCallerNotPermitted> for SwitchboardErrors {
        fn from(value: FunctionCallerNotPermitted) -> Self {
            Self::FunctionCallerNotPermitted(value)
        }
    }
    impl ::core::convert::From<FunctionDoesNotExist> for SwitchboardErrors {
        fn from(value: FunctionDoesNotExist) -> Self {
            Self::FunctionDoesNotExist(value)
        }
    }
    impl ::core::convert::From<FunctionFeeTooLow> for SwitchboardErrors {
        fn from(value: FunctionFeeTooLow) -> Self {
            Self::FunctionFeeTooLow(value)
        }
    }
    impl ::core::convert::From<FunctionIncorrectTarget> for SwitchboardErrors {
        fn from(value: FunctionIncorrectTarget) -> Self {
            Self::FunctionIncorrectTarget(value)
        }
    }
    impl ::core::convert::From<FunctionMrEnclaveMismatch> for SwitchboardErrors {
        fn from(value: FunctionMrEnclaveMismatch) -> Self {
            Self::FunctionMrEnclaveMismatch(value)
        }
    }
    impl ::core::convert::From<FunctionSignerAlreadySet> for SwitchboardErrors {
        fn from(value: FunctionSignerAlreadySet) -> Self {
            Self::FunctionSignerAlreadySet(value)
        }
    }
    impl ::core::convert::From<GasLimitExceeded> for SwitchboardErrors {
        fn from(value: GasLimitExceeded) -> Self {
            Self::GasLimitExceeded(value)
        }
    }
    impl ::core::convert::From<Generic> for SwitchboardErrors {
        fn from(value: Generic) -> Self {
            Self::Generic(value)
        }
    }
    impl ::core::convert::From<IncorrectFunctionId> for SwitchboardErrors {
        fn from(value: IncorrectFunctionId) -> Self {
            Self::IncorrectFunctionId(value)
        }
    }
    impl ::core::convert::From<IncorrectReportedTime> for SwitchboardErrors {
        fn from(value: IncorrectReportedTime) -> Self {
            Self::IncorrectReportedTime(value)
        }
    }
    impl ::core::convert::From<IncorrectToken> for SwitchboardErrors {
        fn from(value: IncorrectToken) -> Self {
            Self::IncorrectToken(value)
        }
    }
    impl ::core::convert::From<InitializationFunctionReverted> for SwitchboardErrors {
        fn from(value: InitializationFunctionReverted) -> Self {
            Self::InitializationFunctionReverted(value)
        }
    }
    impl ::core::convert::From<InsufficientBalance> for SwitchboardErrors {
        fn from(value: InsufficientBalance) -> Self {
            Self::InsufficientBalance(value)
        }
    }
    impl ::core::convert::From<InsufficientCallBalance> for SwitchboardErrors {
        fn from(value: InsufficientCallBalance) -> Self {
            Self::InsufficientCallBalance(value)
        }
    }
    impl ::core::convert::From<InsufficientCallFeePaid> for SwitchboardErrors {
        fn from(value: InsufficientCallFeePaid) -> Self {
            Self::InsufficientCallFeePaid(value)
        }
    }
    impl ::core::convert::From<InsufficientNodes> for SwitchboardErrors {
        fn from(value: InsufficientNodes) -> Self {
            Self::InsufficientNodes(value)
        }
    }
    impl ::core::convert::From<InsufficientSamples> for SwitchboardErrors {
        fn from(value: InsufficientSamples) -> Self {
            Self::InsufficientSamples(value)
        }
    }
    impl ::core::convert::From<IntervalHistoryNotRecorded> for SwitchboardErrors {
        fn from(value: IntervalHistoryNotRecorded) -> Self {
            Self::IntervalHistoryNotRecorded(value)
        }
    }
    impl ::core::convert::From<InvalidArgument> for SwitchboardErrors {
        fn from(value: InvalidArgument) -> Self {
            Self::InvalidArgument(value)
        }
    }
    impl ::core::convert::From<InvalidAuthority> for SwitchboardErrors {
        fn from(value: InvalidAuthority) -> Self {
            Self::InvalidAuthority(value)
        }
    }
    impl ::core::convert::From<InvalidCallId> for SwitchboardErrors {
        fn from(value: InvalidCallId) -> Self {
            Self::InvalidCallId(value)
        }
    }
    impl ::core::convert::From<InvalidCallbackParams> for SwitchboardErrors {
        fn from(value: InvalidCallbackParams) -> Self {
            Self::InvalidCallbackParams(value)
        }
    }
    impl ::core::convert::From<InvalidEnclave> for SwitchboardErrors {
        fn from(value: InvalidEnclave) -> Self {
            Self::InvalidEnclave(value)
        }
    }
    impl ::core::convert::From<InvalidEntry> for SwitchboardErrors {
        fn from(value: InvalidEntry) -> Self {
            Self::InvalidEntry(value)
        }
    }
    impl ::core::convert::From<InvalidRoutineId> for SwitchboardErrors {
        fn from(value: InvalidRoutineId) -> Self {
            Self::InvalidRoutineId(value)
        }
    }
    impl ::core::convert::From<InvalidSignature> for SwitchboardErrors {
        fn from(value: InvalidSignature) -> Self {
            Self::InvalidSignature(value)
        }
    }
    impl ::core::convert::From<InvalidSigner> for SwitchboardErrors {
        fn from(value: InvalidSigner) -> Self {
            Self::InvalidSigner(value)
        }
    }
    impl ::core::convert::From<InvalidStatus> for SwitchboardErrors {
        fn from(value: InvalidStatus) -> Self {
            Self::InvalidStatus(value)
        }
    }
    impl ::core::convert::From<MrEnclaveNotAllowed> for SwitchboardErrors {
        fn from(value: MrEnclaveNotAllowed) -> Self {
            Self::MrEnclaveNotAllowed(value)
        }
    }
    impl ::core::convert::From<OracleAlreadyExists> for SwitchboardErrors {
        fn from(value: OracleAlreadyExists) -> Self {
            Self::OracleAlreadyExists(value)
        }
    }
    impl ::core::convert::From<OracleExpired> for SwitchboardErrors {
        fn from(value: OracleExpired) -> Self {
            Self::OracleExpired(value)
        }
    }
    impl ::core::convert::From<OracleNotAtQueueIdx> for SwitchboardErrors {
        fn from(value: OracleNotAtQueueIdx) -> Self {
            Self::OracleNotAtQueueIdx(value)
        }
    }
    impl ::core::convert::From<OracleNotOnQueue> for SwitchboardErrors {
        fn from(value: OracleNotOnQueue) -> Self {
            Self::OracleNotOnQueue(value)
        }
    }
    impl ::core::convert::From<OracleQueueDoesNotExist> for SwitchboardErrors {
        fn from(value: OracleQueueDoesNotExist) -> Self {
            Self::OracleQueueDoesNotExist(value)
        }
    }
    impl ::core::convert::From<PermissionDenied> for SwitchboardErrors {
        fn from(value: PermissionDenied) -> Self {
            Self::PermissionDenied(value)
        }
    }
    impl ::core::convert::From<QueuesDoNotMatch> for SwitchboardErrors {
        fn from(value: QueuesDoNotMatch) -> Self {
            Self::QueuesDoNotMatch(value)
        }
    }
    impl ::core::convert::From<RequestAlreadyExists> for SwitchboardErrors {
        fn from(value: RequestAlreadyExists) -> Self {
            Self::RequestAlreadyExists(value)
        }
    }
    impl ::core::convert::From<RequestIdAlreadyExists> for SwitchboardErrors {
        fn from(value: RequestIdAlreadyExists) -> Self {
            Self::RequestIdAlreadyExists(value)
        }
    }
    impl ::core::convert::From<RoutineIdAlreadyExists> for SwitchboardErrors {
        fn from(value: RoutineIdAlreadyExists) -> Self {
            Self::RoutineIdAlreadyExists(value)
        }
    }
    impl ::core::convert::From<RoutinesDisabled> for SwitchboardErrors {
        fn from(value: RoutinesDisabled) -> Self {
            Self::RoutinesDisabled(value)
        }
    }
    impl ::core::convert::From<StakeNotReady> for SwitchboardErrors {
        fn from(value: StakeNotReady) -> Self {
            Self::StakeNotReady(value)
        }
    }
    impl ::core::convert::From<StakeNotReadyForWithdrawal> for SwitchboardErrors {
        fn from(value: StakeNotReadyForWithdrawal) -> Self {
            Self::StakeNotReadyForWithdrawal(value)
        }
    }
    impl ::core::convert::From<SubmittedResultsMismatch> for SwitchboardErrors {
        fn from(value: SubmittedResultsMismatch) -> Self {
            Self::SubmittedResultsMismatch(value)
        }
    }
    impl ::core::convert::From<TokenTransferFailure> for SwitchboardErrors {
        fn from(value: TokenTransferFailure) -> Self {
            Self::TokenTransferFailure(value)
        }
    }
    impl ::core::convert::From<TransactionExpired> for SwitchboardErrors {
        fn from(value: TransactionExpired) -> Self {
            Self::TransactionExpired(value)
        }
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "AddMrEnclave", abi = "AddMrEnclave(address,bytes32)")]
    pub struct AddMrEnclaveFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorAccountInit",
        abi = "AggregatorAccountInit(address,address,uint256)"
    )]
    pub struct AggregatorAccountInitFilter {
        #[ethevent(indexed)]
        pub authority: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub account_id: ::ethers::core::types::Address,
        pub timestamp: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorFundEvent",
        abi = "AggregatorFundEvent(address,address,uint256)"
    )]
    pub struct AggregatorFundEventFilter {
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub funder: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorIntervalRefreshed",
        abi = "AggregatorIntervalRefreshed(address,uint256,uint256)"
    )]
    pub struct AggregatorIntervalRefreshedFilter {
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub interval_id: ::ethers::core::types::U256,
        #[ethevent(indexed)]
        pub balance_left_for_interval: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorOpenInterval",
        abi = "AggregatorOpenInterval(address,uint256)"
    )]
    pub struct AggregatorOpenIntervalFilter {
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub interval_id: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorRead",
        abi = "AggregatorRead(address,address,int256)"
    )]
    pub struct AggregatorReadFilter {
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub reader: ::ethers::core::types::Address,
        pub value: ::ethers::core::types::I256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorSaveResult",
        abi = "AggregatorSaveResult(address,address,int256)"
    )]
    pub struct AggregatorSaveResultFilter {
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub oracle: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub value: ::ethers::core::types::I256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorSettingsUpdated",
        abi = "AggregatorSettingsUpdated(address,uint256,uint256,uint256,uint256,uint256)"
    )]
    pub struct AggregatorSettingsUpdatedFilter {
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        pub min_update_delay_seconds: ::ethers::core::types::U256,
        pub min_oracle_results: ::ethers::core::types::U256,
        pub variance_threshold: ::ethers::core::types::U256,
        pub min_job_results: ::ethers::core::types::U256,
        pub force_report_period: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorUpdate",
        abi = "AggregatorUpdate(address,int256,uint256)"
    )]
    pub struct AggregatorUpdateFilter {
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub value: ::ethers::core::types::I256,
        pub timestamp: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AggregatorWithdrawEvent",
        abi = "AggregatorWithdrawEvent(address,address,uint256)"
    )]
    pub struct AggregatorWithdrawEventFilter {
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub funder: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "Approval", abi = "Approval(address,address,uint256)")]
    pub struct ApprovalFilter {
        #[ethevent(indexed)]
        pub owner: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub spender: ::ethers::core::types::Address,
        pub value: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AttestationQueueAccountInit",
        abi = "AttestationQueueAccountInit(address,address)"
    )]
    pub struct AttestationQueueAccountInitFilter {
        #[ethevent(indexed)]
        pub authority: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub account_id: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AttestationQueuePermissionUpdated",
        abi = "AttestationQueuePermissionUpdated(address,address,address,uint256)"
    )]
    pub struct AttestationQueuePermissionUpdatedFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub granter: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub grantee: ::ethers::core::types::Address,
        pub permission: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "AttestationQueueSetConfig",
        abi = "AttestationQueueSetConfig(address,address)"
    )]
    pub struct AttestationQueueSetConfigFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub authority: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "DiamondCut",
        abi = "DiamondCut((address,uint8,bytes4[])[],address,bytes)"
    )]
    pub struct DiamondCutFilter {
        pub diamond_cut: ::std::vec::Vec<FacetCut>,
        pub init: ::ethers::core::types::Address,
        pub calldata: ::ethers::core::types::Bytes,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "EnclaveAccountInit",
        abi = "EnclaveAccountInit(address,address)"
    )]
    pub struct EnclaveAccountInitFilter {
        #[ethevent(indexed)]
        pub signer: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub account_id: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "EnclaveGC", abi = "EnclaveGC(address,address)")]
    pub struct EnclaveGCFilter {
        #[ethevent(indexed)]
        pub enclave_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub queue: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "EnclaveHeartbeat", abi = "EnclaveHeartbeat(address,address)")]
    pub struct EnclaveHeartbeatFilter {
        #[ethevent(indexed)]
        pub enclave_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub signer: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "EnclavePayoutEvent",
        abi = "EnclavePayoutEvent(address,address,uint256)"
    )]
    pub struct EnclavePayoutEventFilter {
        #[ethevent(indexed)]
        pub node_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub enclave_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "EnclaveRotateSigner",
        abi = "EnclaveRotateSigner(address,address,address)"
    )]
    pub struct EnclaveRotateSignerFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub old_signer: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub new_signer: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "EnclaveVerifyRequest",
        abi = "EnclaveVerifyRequest(address,address,address)"
    )]
    pub struct EnclaveVerifyRequestFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub verifier: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub verifiee: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "FunctionAccountInit",
        abi = "FunctionAccountInit(address,address)"
    )]
    pub struct FunctionAccountInitFilter {
        #[ethevent(indexed)]
        pub authority: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub account_id: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "FunctionCallEvent",
        abi = "FunctionCallEvent(address,address,address,bytes)"
    )]
    pub struct FunctionCallEventFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub sender: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub call_id: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "FunctionCallFund",
        abi = "FunctionCallFund(address,address,uint256)"
    )]
    pub struct FunctionCallFundFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub funder: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "FunctionFund", abi = "FunctionFund(address,address,uint256)")]
    pub struct FunctionFundFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub funder: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "FunctionWithdraw",
        abi = "FunctionWithdraw(address,address,uint256)"
    )]
    pub struct FunctionWithdrawFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub withdrawer: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "OracleAccountInit", abi = "OracleAccountInit(address,address)")]
    pub struct OracleAccountInitFilter {
        #[ethevent(indexed)]
        pub signer: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub account_id: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "OracleGC", abi = "OracleGC(address,address)")]
    pub struct OracleGCFilter {
        #[ethevent(indexed)]
        pub oracle_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "OracleHeartbeat", abi = "OracleHeartbeat(address)")]
    pub struct OracleHeartbeatFilter {
        #[ethevent(indexed)]
        pub oracle_id: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OraclePayoutEvent",
        abi = "OraclePayoutEvent(address,address,uint256)"
    )]
    pub struct OraclePayoutEventFilter {
        #[ethevent(indexed)]
        pub oracle_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub aggregator_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OracleQueueAccountInit",
        abi = "OracleQueueAccountInit(address,address)"
    )]
    pub struct OracleQueueAccountInitFilter {
        #[ethevent(indexed)]
        pub authority: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub account_id: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OracleQueueAddMrEnclave",
        abi = "OracleQueueAddMrEnclave(address,address,bytes32)"
    )]
    pub struct OracleQueueAddMrEnclaveFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub attestation_queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OracleQueueRemoveMrEnclave",
        abi = "OracleQueueRemoveMrEnclave(address,address,bytes32)"
    )]
    pub struct OracleQueueRemoveMrEnclaveFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub attestation_queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OracleQueueSetAttestationConfig",
        abi = "OracleQueueSetAttestationConfig(address,address)"
    )]
    pub struct OracleQueueSetAttestationConfigFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub attestation_queue_id: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OracleQueueSetConfig",
        abi = "OracleQueueSetConfig(address,address)"
    )]
    pub struct OracleQueueSetConfigFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub authority: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OracleQueueSetPermission",
        abi = "OracleQueueSetPermission(address,address,address,uint256)"
    )]
    pub struct OracleQueueSetPermissionFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub granter: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub grantee: ::ethers::core::types::Address,
        pub permission: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OracleRotateSigner",
        abi = "OracleRotateSigner(address,address,address)"
    )]
    pub struct OracleRotateSignerFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub old_signer: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub new_signer: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OracleSetConfig",
        abi = "OracleSetConfig(address,string,address,address,address)"
    )]
    pub struct OracleSetConfigFilter {
        #[ethevent(indexed)]
        pub oracle_id: ::ethers::core::types::Address,
        pub name: ::std::string::String,
        #[ethevent(indexed)]
        pub signer: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "OwnershipTransferred",
        abi = "OwnershipTransferred(address,address)"
    )]
    pub struct OwnershipTransferredFilter {
        #[ethevent(indexed)]
        pub previous_owner: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub new_owner: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "RemoveMrEnclave", abi = "RemoveMrEnclave(address,bytes32)")]
    pub struct RemoveMrEnclaveFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "RequestEvent",
        abi = "RequestEvent(address,address,address,bytes)"
    )]
    pub struct RequestEventFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub sender: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub request_id: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "RequestFund", abi = "RequestFund(address,address,uint256)")]
    pub struct RequestFundFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub funder: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "RequestWithdraw",
        abi = "RequestWithdraw(address,address,uint256)"
    )]
    pub struct RequestWithdrawFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub funder: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "RoutineCreated",
        abi = "RoutineCreated(address,address,address,bytes)"
    )]
    pub struct RoutineCreatedFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub sender: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub routine_id: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "RoutineFund", abi = "RoutineFund(address,address,uint256)")]
    pub struct RoutineFundFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub funder: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "RoutineWithdraw",
        abi = "RoutineWithdraw(address,address,uint256)"
    )]
    pub struct RoutineWithdrawFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub funder: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "StakeAdded",
        abi = "StakeAdded(address,address,uint256,address)"
    )]
    pub struct StakeAddedFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
        pub sender: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(
        name = "StakeRemoved",
        abi = "StakeRemoved(address,address,uint256,address)"
    )]
    pub struct StakeRemovedFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
        pub sender: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "Transfer", abi = "Transfer(address,address,uint256)")]
    pub struct TransferFilter {
        #[ethevent(indexed)]
        pub from: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub to: ::ethers::core::types::Address,
        pub value: ::ethers::core::types::U256,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "Unstaked", abi = "Unstaked(address,address,uint256,address)")]
    pub struct UnstakedFilter {
        #[ethevent(indexed)]
        pub queue_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub staker: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
        pub sender: ::ethers::core::types::Address,
    }
    #[derive(
        Clone,
        ::ethers::contract::EthEvent,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethevent(name = "VerifyFailed", abi = "VerifyFailed(address,address,uint256)")]
    pub struct VerifyFailedFilter {
        #[ethevent(indexed)]
        pub function_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub call_id: ::ethers::core::types::Address,
        #[ethevent(indexed)]
        pub code: ::ethers::core::types::U256,
    }
    ///Container type for all of the contract's events
    #[derive(Clone, ::ethers::contract::EthAbiType, Debug, PartialEq, Eq, Hash)]
    pub enum SwitchboardEvents {
        AddMrEnclaveFilter(AddMrEnclaveFilter),
        AggregatorAccountInitFilter(AggregatorAccountInitFilter),
        AggregatorFundEventFilter(AggregatorFundEventFilter),
        AggregatorIntervalRefreshedFilter(AggregatorIntervalRefreshedFilter),
        AggregatorOpenIntervalFilter(AggregatorOpenIntervalFilter),
        AggregatorReadFilter(AggregatorReadFilter),
        AggregatorSaveResultFilter(AggregatorSaveResultFilter),
        AggregatorSettingsUpdatedFilter(AggregatorSettingsUpdatedFilter),
        AggregatorUpdateFilter(AggregatorUpdateFilter),
        AggregatorWithdrawEventFilter(AggregatorWithdrawEventFilter),
        ApprovalFilter(ApprovalFilter),
        AttestationQueueAccountInitFilter(AttestationQueueAccountInitFilter),
        AttestationQueuePermissionUpdatedFilter(AttestationQueuePermissionUpdatedFilter),
        AttestationQueueSetConfigFilter(AttestationQueueSetConfigFilter),
        DiamondCutFilter(DiamondCutFilter),
        EnclaveAccountInitFilter(EnclaveAccountInitFilter),
        EnclaveGCFilter(EnclaveGCFilter),
        EnclaveHeartbeatFilter(EnclaveHeartbeatFilter),
        EnclavePayoutEventFilter(EnclavePayoutEventFilter),
        EnclaveRotateSignerFilter(EnclaveRotateSignerFilter),
        EnclaveVerifyRequestFilter(EnclaveVerifyRequestFilter),
        FunctionAccountInitFilter(FunctionAccountInitFilter),
        FunctionCallEventFilter(FunctionCallEventFilter),
        FunctionCallFundFilter(FunctionCallFundFilter),
        FunctionFundFilter(FunctionFundFilter),
        FunctionWithdrawFilter(FunctionWithdrawFilter),
        OracleAccountInitFilter(OracleAccountInitFilter),
        OracleGCFilter(OracleGCFilter),
        OracleHeartbeatFilter(OracleHeartbeatFilter),
        OraclePayoutEventFilter(OraclePayoutEventFilter),
        OracleQueueAccountInitFilter(OracleQueueAccountInitFilter),
        OracleQueueAddMrEnclaveFilter(OracleQueueAddMrEnclaveFilter),
        OracleQueueRemoveMrEnclaveFilter(OracleQueueRemoveMrEnclaveFilter),
        OracleQueueSetAttestationConfigFilter(OracleQueueSetAttestationConfigFilter),
        OracleQueueSetConfigFilter(OracleQueueSetConfigFilter),
        OracleQueueSetPermissionFilter(OracleQueueSetPermissionFilter),
        OracleRotateSignerFilter(OracleRotateSignerFilter),
        OracleSetConfigFilter(OracleSetConfigFilter),
        OwnershipTransferredFilter(OwnershipTransferredFilter),
        RemoveMrEnclaveFilter(RemoveMrEnclaveFilter),
        RequestEventFilter(RequestEventFilter),
        RequestFundFilter(RequestFundFilter),
        RequestWithdrawFilter(RequestWithdrawFilter),
        RoutineCreatedFilter(RoutineCreatedFilter),
        RoutineFundFilter(RoutineFundFilter),
        RoutineWithdrawFilter(RoutineWithdrawFilter),
        StakeAddedFilter(StakeAddedFilter),
        StakeRemovedFilter(StakeRemovedFilter),
        TransferFilter(TransferFilter),
        UnstakedFilter(UnstakedFilter),
        VerifyFailedFilter(VerifyFailedFilter),
    }
    impl ::ethers::contract::EthLogDecode for SwitchboardEvents {
        fn decode_log(
            log: &::ethers::core::abi::RawLog,
        ) -> ::core::result::Result<Self, ::ethers::core::abi::Error> {
            if let Ok(decoded) = AddMrEnclaveFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AddMrEnclaveFilter(decoded));
            }
            if let Ok(decoded) = AggregatorAccountInitFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorAccountInitFilter(decoded));
            }
            if let Ok(decoded) = AggregatorFundEventFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorFundEventFilter(decoded));
            }
            if let Ok(decoded) = AggregatorIntervalRefreshedFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorIntervalRefreshedFilter(
                    decoded,
                ));
            }
            if let Ok(decoded) = AggregatorOpenIntervalFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorOpenIntervalFilter(decoded));
            }
            if let Ok(decoded) = AggregatorReadFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorReadFilter(decoded));
            }
            if let Ok(decoded) = AggregatorSaveResultFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorSaveResultFilter(decoded));
            }
            if let Ok(decoded) = AggregatorSettingsUpdatedFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorSettingsUpdatedFilter(decoded));
            }
            if let Ok(decoded) = AggregatorUpdateFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorUpdateFilter(decoded));
            }
            if let Ok(decoded) = AggregatorWithdrawEventFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AggregatorWithdrawEventFilter(decoded));
            }
            if let Ok(decoded) = ApprovalFilter::decode_log(log) {
                return Ok(SwitchboardEvents::ApprovalFilter(decoded));
            }
            if let Ok(decoded) = AttestationQueueAccountInitFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AttestationQueueAccountInitFilter(
                    decoded,
                ));
            }
            if let Ok(decoded) = AttestationQueuePermissionUpdatedFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AttestationQueuePermissionUpdatedFilter(
                    decoded,
                ));
            }
            if let Ok(decoded) = AttestationQueueSetConfigFilter::decode_log(log) {
                return Ok(SwitchboardEvents::AttestationQueueSetConfigFilter(decoded));
            }
            if let Ok(decoded) = DiamondCutFilter::decode_log(log) {
                return Ok(SwitchboardEvents::DiamondCutFilter(decoded));
            }
            if let Ok(decoded) = EnclaveAccountInitFilter::decode_log(log) {
                return Ok(SwitchboardEvents::EnclaveAccountInitFilter(decoded));
            }
            if let Ok(decoded) = EnclaveGCFilter::decode_log(log) {
                return Ok(SwitchboardEvents::EnclaveGCFilter(decoded));
            }
            if let Ok(decoded) = EnclaveHeartbeatFilter::decode_log(log) {
                return Ok(SwitchboardEvents::EnclaveHeartbeatFilter(decoded));
            }
            if let Ok(decoded) = EnclavePayoutEventFilter::decode_log(log) {
                return Ok(SwitchboardEvents::EnclavePayoutEventFilter(decoded));
            }
            if let Ok(decoded) = EnclaveRotateSignerFilter::decode_log(log) {
                return Ok(SwitchboardEvents::EnclaveRotateSignerFilter(decoded));
            }
            if let Ok(decoded) = EnclaveVerifyRequestFilter::decode_log(log) {
                return Ok(SwitchboardEvents::EnclaveVerifyRequestFilter(decoded));
            }
            if let Ok(decoded) = FunctionAccountInitFilter::decode_log(log) {
                return Ok(SwitchboardEvents::FunctionAccountInitFilter(decoded));
            }
            if let Ok(decoded) = FunctionCallEventFilter::decode_log(log) {
                return Ok(SwitchboardEvents::FunctionCallEventFilter(decoded));
            }
            if let Ok(decoded) = FunctionCallFundFilter::decode_log(log) {
                return Ok(SwitchboardEvents::FunctionCallFundFilter(decoded));
            }
            if let Ok(decoded) = FunctionFundFilter::decode_log(log) {
                return Ok(SwitchboardEvents::FunctionFundFilter(decoded));
            }
            if let Ok(decoded) = FunctionWithdrawFilter::decode_log(log) {
                return Ok(SwitchboardEvents::FunctionWithdrawFilter(decoded));
            }
            if let Ok(decoded) = OracleAccountInitFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleAccountInitFilter(decoded));
            }
            if let Ok(decoded) = OracleGCFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleGCFilter(decoded));
            }
            if let Ok(decoded) = OracleHeartbeatFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleHeartbeatFilter(decoded));
            }
            if let Ok(decoded) = OraclePayoutEventFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OraclePayoutEventFilter(decoded));
            }
            if let Ok(decoded) = OracleQueueAccountInitFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleQueueAccountInitFilter(decoded));
            }
            if let Ok(decoded) = OracleQueueAddMrEnclaveFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleQueueAddMrEnclaveFilter(decoded));
            }
            if let Ok(decoded) = OracleQueueRemoveMrEnclaveFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleQueueRemoveMrEnclaveFilter(decoded));
            }
            if let Ok(decoded) = OracleQueueSetAttestationConfigFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleQueueSetAttestationConfigFilter(
                    decoded,
                ));
            }
            if let Ok(decoded) = OracleQueueSetConfigFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleQueueSetConfigFilter(decoded));
            }
            if let Ok(decoded) = OracleQueueSetPermissionFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleQueueSetPermissionFilter(decoded));
            }
            if let Ok(decoded) = OracleRotateSignerFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleRotateSignerFilter(decoded));
            }
            if let Ok(decoded) = OracleSetConfigFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OracleSetConfigFilter(decoded));
            }
            if let Ok(decoded) = OwnershipTransferredFilter::decode_log(log) {
                return Ok(SwitchboardEvents::OwnershipTransferredFilter(decoded));
            }
            if let Ok(decoded) = RemoveMrEnclaveFilter::decode_log(log) {
                return Ok(SwitchboardEvents::RemoveMrEnclaveFilter(decoded));
            }
            if let Ok(decoded) = RequestEventFilter::decode_log(log) {
                return Ok(SwitchboardEvents::RequestEventFilter(decoded));
            }
            if let Ok(decoded) = RequestFundFilter::decode_log(log) {
                return Ok(SwitchboardEvents::RequestFundFilter(decoded));
            }
            if let Ok(decoded) = RequestWithdrawFilter::decode_log(log) {
                return Ok(SwitchboardEvents::RequestWithdrawFilter(decoded));
            }
            if let Ok(decoded) = RoutineCreatedFilter::decode_log(log) {
                return Ok(SwitchboardEvents::RoutineCreatedFilter(decoded));
            }
            if let Ok(decoded) = RoutineFundFilter::decode_log(log) {
                return Ok(SwitchboardEvents::RoutineFundFilter(decoded));
            }
            if let Ok(decoded) = RoutineWithdrawFilter::decode_log(log) {
                return Ok(SwitchboardEvents::RoutineWithdrawFilter(decoded));
            }
            if let Ok(decoded) = StakeAddedFilter::decode_log(log) {
                return Ok(SwitchboardEvents::StakeAddedFilter(decoded));
            }
            if let Ok(decoded) = StakeRemovedFilter::decode_log(log) {
                return Ok(SwitchboardEvents::StakeRemovedFilter(decoded));
            }
            if let Ok(decoded) = TransferFilter::decode_log(log) {
                return Ok(SwitchboardEvents::TransferFilter(decoded));
            }
            if let Ok(decoded) = UnstakedFilter::decode_log(log) {
                return Ok(SwitchboardEvents::UnstakedFilter(decoded));
            }
            if let Ok(decoded) = VerifyFailedFilter::decode_log(log) {
                return Ok(SwitchboardEvents::VerifyFailedFilter(decoded));
            }
            Err(::ethers::core::abi::Error::InvalidData)
        }
    }
    impl ::core::fmt::Display for SwitchboardEvents {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
                Self::AddMrEnclaveFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorAccountInitFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorFundEventFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorIntervalRefreshedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AggregatorOpenIntervalFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AggregatorReadFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorSaveResultFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorSettingsUpdatedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AggregatorUpdateFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorWithdrawEventFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::ApprovalFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::AttestationQueueAccountInitFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AttestationQueuePermissionUpdatedFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AttestationQueueSetConfigFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::DiamondCutFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveAccountInitFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveGCFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveHeartbeatFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclavePayoutEventFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveRotateSignerFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveVerifyRequestFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionAccountInitFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionCallEventFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionCallFundFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionFundFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionWithdrawFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleAccountInitFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleGCFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleHeartbeatFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::OraclePayoutEventFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleQueueAccountInitFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::OracleQueueAddMrEnclaveFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::OracleQueueRemoveMrEnclaveFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::OracleQueueSetAttestationConfigFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::OracleQueueSetConfigFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleQueueSetPermissionFilter(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::OracleRotateSignerFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleSetConfigFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::OwnershipTransferredFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::RemoveMrEnclaveFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestEventFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestFundFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestWithdrawFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::RoutineCreatedFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::RoutineFundFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::RoutineWithdrawFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::StakeAddedFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::StakeRemovedFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::TransferFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::UnstakedFilter(element) => ::core::fmt::Display::fmt(element, f),
                Self::VerifyFailedFilter(element) => ::core::fmt::Display::fmt(element, f),
            }
        }
    }
    impl ::core::convert::From<AddMrEnclaveFilter> for SwitchboardEvents {
        fn from(value: AddMrEnclaveFilter) -> Self {
            Self::AddMrEnclaveFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorAccountInitFilter> for SwitchboardEvents {
        fn from(value: AggregatorAccountInitFilter) -> Self {
            Self::AggregatorAccountInitFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorFundEventFilter> for SwitchboardEvents {
        fn from(value: AggregatorFundEventFilter) -> Self {
            Self::AggregatorFundEventFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorIntervalRefreshedFilter> for SwitchboardEvents {
        fn from(value: AggregatorIntervalRefreshedFilter) -> Self {
            Self::AggregatorIntervalRefreshedFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorOpenIntervalFilter> for SwitchboardEvents {
        fn from(value: AggregatorOpenIntervalFilter) -> Self {
            Self::AggregatorOpenIntervalFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorReadFilter> for SwitchboardEvents {
        fn from(value: AggregatorReadFilter) -> Self {
            Self::AggregatorReadFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorSaveResultFilter> for SwitchboardEvents {
        fn from(value: AggregatorSaveResultFilter) -> Self {
            Self::AggregatorSaveResultFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorSettingsUpdatedFilter> for SwitchboardEvents {
        fn from(value: AggregatorSettingsUpdatedFilter) -> Self {
            Self::AggregatorSettingsUpdatedFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorUpdateFilter> for SwitchboardEvents {
        fn from(value: AggregatorUpdateFilter) -> Self {
            Self::AggregatorUpdateFilter(value)
        }
    }
    impl ::core::convert::From<AggregatorWithdrawEventFilter> for SwitchboardEvents {
        fn from(value: AggregatorWithdrawEventFilter) -> Self {
            Self::AggregatorWithdrawEventFilter(value)
        }
    }
    impl ::core::convert::From<ApprovalFilter> for SwitchboardEvents {
        fn from(value: ApprovalFilter) -> Self {
            Self::ApprovalFilter(value)
        }
    }
    impl ::core::convert::From<AttestationQueueAccountInitFilter> for SwitchboardEvents {
        fn from(value: AttestationQueueAccountInitFilter) -> Self {
            Self::AttestationQueueAccountInitFilter(value)
        }
    }
    impl ::core::convert::From<AttestationQueuePermissionUpdatedFilter> for SwitchboardEvents {
        fn from(value: AttestationQueuePermissionUpdatedFilter) -> Self {
            Self::AttestationQueuePermissionUpdatedFilter(value)
        }
    }
    impl ::core::convert::From<AttestationQueueSetConfigFilter> for SwitchboardEvents {
        fn from(value: AttestationQueueSetConfigFilter) -> Self {
            Self::AttestationQueueSetConfigFilter(value)
        }
    }
    impl ::core::convert::From<DiamondCutFilter> for SwitchboardEvents {
        fn from(value: DiamondCutFilter) -> Self {
            Self::DiamondCutFilter(value)
        }
    }
    impl ::core::convert::From<EnclaveAccountInitFilter> for SwitchboardEvents {
        fn from(value: EnclaveAccountInitFilter) -> Self {
            Self::EnclaveAccountInitFilter(value)
        }
    }
    impl ::core::convert::From<EnclaveGCFilter> for SwitchboardEvents {
        fn from(value: EnclaveGCFilter) -> Self {
            Self::EnclaveGCFilter(value)
        }
    }
    impl ::core::convert::From<EnclaveHeartbeatFilter> for SwitchboardEvents {
        fn from(value: EnclaveHeartbeatFilter) -> Self {
            Self::EnclaveHeartbeatFilter(value)
        }
    }
    impl ::core::convert::From<EnclavePayoutEventFilter> for SwitchboardEvents {
        fn from(value: EnclavePayoutEventFilter) -> Self {
            Self::EnclavePayoutEventFilter(value)
        }
    }
    impl ::core::convert::From<EnclaveRotateSignerFilter> for SwitchboardEvents {
        fn from(value: EnclaveRotateSignerFilter) -> Self {
            Self::EnclaveRotateSignerFilter(value)
        }
    }
    impl ::core::convert::From<EnclaveVerifyRequestFilter> for SwitchboardEvents {
        fn from(value: EnclaveVerifyRequestFilter) -> Self {
            Self::EnclaveVerifyRequestFilter(value)
        }
    }
    impl ::core::convert::From<FunctionAccountInitFilter> for SwitchboardEvents {
        fn from(value: FunctionAccountInitFilter) -> Self {
            Self::FunctionAccountInitFilter(value)
        }
    }
    impl ::core::convert::From<FunctionCallEventFilter> for SwitchboardEvents {
        fn from(value: FunctionCallEventFilter) -> Self {
            Self::FunctionCallEventFilter(value)
        }
    }
    impl ::core::convert::From<FunctionCallFundFilter> for SwitchboardEvents {
        fn from(value: FunctionCallFundFilter) -> Self {
            Self::FunctionCallFundFilter(value)
        }
    }
    impl ::core::convert::From<FunctionFundFilter> for SwitchboardEvents {
        fn from(value: FunctionFundFilter) -> Self {
            Self::FunctionFundFilter(value)
        }
    }
    impl ::core::convert::From<FunctionWithdrawFilter> for SwitchboardEvents {
        fn from(value: FunctionWithdrawFilter) -> Self {
            Self::FunctionWithdrawFilter(value)
        }
    }
    impl ::core::convert::From<OracleAccountInitFilter> for SwitchboardEvents {
        fn from(value: OracleAccountInitFilter) -> Self {
            Self::OracleAccountInitFilter(value)
        }
    }
    impl ::core::convert::From<OracleGCFilter> for SwitchboardEvents {
        fn from(value: OracleGCFilter) -> Self {
            Self::OracleGCFilter(value)
        }
    }
    impl ::core::convert::From<OracleHeartbeatFilter> for SwitchboardEvents {
        fn from(value: OracleHeartbeatFilter) -> Self {
            Self::OracleHeartbeatFilter(value)
        }
    }
    impl ::core::convert::From<OraclePayoutEventFilter> for SwitchboardEvents {
        fn from(value: OraclePayoutEventFilter) -> Self {
            Self::OraclePayoutEventFilter(value)
        }
    }
    impl ::core::convert::From<OracleQueueAccountInitFilter> for SwitchboardEvents {
        fn from(value: OracleQueueAccountInitFilter) -> Self {
            Self::OracleQueueAccountInitFilter(value)
        }
    }
    impl ::core::convert::From<OracleQueueAddMrEnclaveFilter> for SwitchboardEvents {
        fn from(value: OracleQueueAddMrEnclaveFilter) -> Self {
            Self::OracleQueueAddMrEnclaveFilter(value)
        }
    }
    impl ::core::convert::From<OracleQueueRemoveMrEnclaveFilter> for SwitchboardEvents {
        fn from(value: OracleQueueRemoveMrEnclaveFilter) -> Self {
            Self::OracleQueueRemoveMrEnclaveFilter(value)
        }
    }
    impl ::core::convert::From<OracleQueueSetAttestationConfigFilter> for SwitchboardEvents {
        fn from(value: OracleQueueSetAttestationConfigFilter) -> Self {
            Self::OracleQueueSetAttestationConfigFilter(value)
        }
    }
    impl ::core::convert::From<OracleQueueSetConfigFilter> for SwitchboardEvents {
        fn from(value: OracleQueueSetConfigFilter) -> Self {
            Self::OracleQueueSetConfigFilter(value)
        }
    }
    impl ::core::convert::From<OracleQueueSetPermissionFilter> for SwitchboardEvents {
        fn from(value: OracleQueueSetPermissionFilter) -> Self {
            Self::OracleQueueSetPermissionFilter(value)
        }
    }
    impl ::core::convert::From<OracleRotateSignerFilter> for SwitchboardEvents {
        fn from(value: OracleRotateSignerFilter) -> Self {
            Self::OracleRotateSignerFilter(value)
        }
    }
    impl ::core::convert::From<OracleSetConfigFilter> for SwitchboardEvents {
        fn from(value: OracleSetConfigFilter) -> Self {
            Self::OracleSetConfigFilter(value)
        }
    }
    impl ::core::convert::From<OwnershipTransferredFilter> for SwitchboardEvents {
        fn from(value: OwnershipTransferredFilter) -> Self {
            Self::OwnershipTransferredFilter(value)
        }
    }
    impl ::core::convert::From<RemoveMrEnclaveFilter> for SwitchboardEvents {
        fn from(value: RemoveMrEnclaveFilter) -> Self {
            Self::RemoveMrEnclaveFilter(value)
        }
    }
    impl ::core::convert::From<RequestEventFilter> for SwitchboardEvents {
        fn from(value: RequestEventFilter) -> Self {
            Self::RequestEventFilter(value)
        }
    }
    impl ::core::convert::From<RequestFundFilter> for SwitchboardEvents {
        fn from(value: RequestFundFilter) -> Self {
            Self::RequestFundFilter(value)
        }
    }
    impl ::core::convert::From<RequestWithdrawFilter> for SwitchboardEvents {
        fn from(value: RequestWithdrawFilter) -> Self {
            Self::RequestWithdrawFilter(value)
        }
    }
    impl ::core::convert::From<RoutineCreatedFilter> for SwitchboardEvents {
        fn from(value: RoutineCreatedFilter) -> Self {
            Self::RoutineCreatedFilter(value)
        }
    }
    impl ::core::convert::From<RoutineFundFilter> for SwitchboardEvents {
        fn from(value: RoutineFundFilter) -> Self {
            Self::RoutineFundFilter(value)
        }
    }
    impl ::core::convert::From<RoutineWithdrawFilter> for SwitchboardEvents {
        fn from(value: RoutineWithdrawFilter) -> Self {
            Self::RoutineWithdrawFilter(value)
        }
    }
    impl ::core::convert::From<StakeAddedFilter> for SwitchboardEvents {
        fn from(value: StakeAddedFilter) -> Self {
            Self::StakeAddedFilter(value)
        }
    }
    impl ::core::convert::From<StakeRemovedFilter> for SwitchboardEvents {
        fn from(value: StakeRemovedFilter) -> Self {
            Self::StakeRemovedFilter(value)
        }
    }
    impl ::core::convert::From<TransferFilter> for SwitchboardEvents {
        fn from(value: TransferFilter) -> Self {
            Self::TransferFilter(value)
        }
    }
    impl ::core::convert::From<UnstakedFilter> for SwitchboardEvents {
        fn from(value: UnstakedFilter) -> Self {
            Self::UnstakedFilter(value)
        }
    }
    impl ::core::convert::From<VerifyFailedFilter> for SwitchboardEvents {
        fn from(value: VerifyFailedFilter) -> Self {
            Self::VerifyFailedFilter(value)
        }
    }
    ///Container type for all input parameters for the `addMrEnclaveToAttestationQueue` function with signature `addMrEnclaveToAttestationQueue(address,bytes32)` and selector `0xad435b9d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "addMrEnclaveToAttestationQueue",
        abi = "addMrEnclaveToAttestationQueue(address,bytes32)"
    )]
    pub struct AddMrEnclaveToAttestationQueueCall {
        pub queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    ///Container type for all input parameters for the `addMrEnclaveToFunction` function with signature `addMrEnclaveToFunction(address,bytes32)` and selector `0x45fc160c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "addMrEnclaveToFunction",
        abi = "addMrEnclaveToFunction(address,bytes32)"
    )]
    pub struct AddMrEnclaveToFunctionCall {
        pub function_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    ///Container type for all input parameters for the `addMrEnclaveToOracleQueue` function with signature `addMrEnclaveToOracleQueue(address,bytes32)` and selector `0x51a426d8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "addMrEnclaveToOracleQueue",
        abi = "addMrEnclaveToOracleQueue(address,bytes32)"
    )]
    pub struct AddMrEnclaveToOracleQueueCall {
        pub queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    ///Container type for all input parameters for the `addStake` function with signature `addStake(address,uint256)` and selector `0x6374299e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "addStake", abi = "addStake(address,uint256)")]
    pub struct AddStakeCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `aggregatorEscrowFund` function with signature `aggregatorEscrowFund(address)` and selector `0xd55dcc5b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "aggregatorEscrowFund", abi = "aggregatorEscrowFund(address)")]
    pub struct AggregatorEscrowFundCall {
        pub account_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `aggregatorEscrowWithdraw` function with signature `aggregatorEscrowWithdraw(address,address,uint256)` and selector `0x202dd499`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "aggregatorEscrowWithdraw",
        abi = "aggregatorEscrowWithdraw(address,address,uint256)"
    )]
    pub struct AggregatorEscrowWithdrawCall {
        pub recipient: ::ethers::core::types::Address,
        pub aggregator_id: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `aggregatorHistory` function with signature `aggregatorHistory(address,uint80)` and selector `0x8625bd08`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "aggregatorHistory", abi = "aggregatorHistory(address,uint80)")]
    pub struct AggregatorHistoryCall {
        pub aggregator_id: ::ethers::core::types::Address,
        pub round_id: u128,
    }
    ///Container type for all input parameters for the `aggregators` function with signature `aggregators(address)` and selector `0x112cdab9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "aggregators", abi = "aggregators(address)")]
    pub struct AggregatorsCall {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `allowance` function with signature `allowance(address,address)` and selector `0xdd62ed3e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "allowance", abi = "allowance(address,address)")]
    pub struct AllowanceCall {
        pub owner: ::ethers::core::types::Address,
        pub spender: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `approve` function with signature `approve(address,uint256)` and selector `0x095ea7b3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "approve", abi = "approve(address,uint256)")]
    pub struct ApproveCall {
        pub spender: ::ethers::core::types::Address,
        pub value: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `attestationQueueHasMrEnclave` function with signature `attestationQueueHasMrEnclave(address,bytes32)` and selector `0x63fcd771`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "attestationQueueHasMrEnclave",
        abi = "attestationQueueHasMrEnclave(address,bytes32)"
    )]
    pub struct AttestationQueueHasMrEnclaveCall {
        pub queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    ///Container type for all input parameters for the `attestationQueues` function with signature `attestationQueues(address)` and selector `0x8bb3048c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "attestationQueues", abi = "attestationQueues(address)")]
    pub struct AttestationQueuesCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `balanceOf` function with signature `balanceOf(address)` and selector `0x70a08231`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "balanceOf", abi = "balanceOf(address)")]
    pub struct BalanceOfCall {
        pub account: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `callBalances` function with signature `callBalances(address[])` and selector `0x0aaeffe5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "callBalances", abi = "callBalances(address[])")]
    pub struct CallBalancesCall {
        pub call_ids: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `callFunction` function with signature `callFunction(address,bytes)` and selector `0x9c23da50`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "callFunction", abi = "callFunction(address,bytes)")]
    pub struct CallFunctionCall {
        pub function_id: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `createAggregator` function with signature `createAggregator(string,address,uint256,uint256,uint256,string,address,uint256,uint256,uint256,bool)` and selector `0x84ed8177`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createAggregator",
        abi = "createAggregator(string,address,uint256,uint256,uint256,string,address,uint256,uint256,uint256,bool)"
    )]
    pub struct CreateAggregatorCall {
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub batch_size: ::ethers::core::types::U256,
        pub min_update_delay_seconds: ::ethers::core::types::U256,
        pub min_oracle_results: ::ethers::core::types::U256,
        pub jobs_hash: ::std::string::String,
        pub queue_id: ::ethers::core::types::Address,
        pub variance_threshold: ::ethers::core::types::U256,
        pub min_job_results: ::ethers::core::types::U256,
        pub force_report_period: ::ethers::core::types::U256,
        pub enable_history: bool,
    }
    ///Container type for all input parameters for the `createAttestationQueue` function with signature `createAttestationQueue(address,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256)` and selector `0xde776851`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createAttestationQueue",
        abi = "createAttestationQueue(address,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256)"
    )]
    pub struct CreateAttestationQueueCall {
        pub authority: ::ethers::core::types::Address,
        pub max_size: ::ethers::core::types::U256,
        pub reward: ::ethers::core::types::U256,
        pub enclave_timeout: ::ethers::core::types::U256,
        pub max_enclave_verification_age: ::ethers::core::types::U256,
        pub allow_authority_override_after: ::ethers::core::types::U256,
        pub require_authority_heartbeat_permission: bool,
        pub require_usage_permissions: bool,
        pub max_consecutive_function_failures: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `createEnclave` function with signature `createEnclave(address,address,address)` and selector `0xcf392e2f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "createEnclave", abi = "createEnclave(address,address,address)")]
    pub struct CreateEnclaveCall {
        pub signer: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `createEnclaveWithId` function with signature `createEnclaveWithId(address,address,address,address)` and selector `0xc7c1143e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createEnclaveWithId",
        abi = "createEnclaveWithId(address,address,address,address)"
    )]
    pub struct CreateEnclaveWithIdCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub signer: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `createFunction` function with signature `createFunction(string,address,address,string,string,string,string,string,address[])` and selector `0xc4829580`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createFunction",
        abi = "createFunction(string,address,address,string,string,string,string,string,address[])"
    )]
    pub struct CreateFunctionCall {
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub container_registry: ::std::string::String,
        pub container: ::std::string::String,
        pub version: ::std::string::String,
        pub schedule: ::std::string::String,
        pub params_schema: ::std::string::String,
        pub permitted_callers: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `createFunctionWithId` function with signature `createFunctionWithId(address,string,address,address,string,string,string,string,string,address[])` and selector `0xcd86c71b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createFunctionWithId",
        abi = "createFunctionWithId(address,string,address,address,string,string,string,string,string,address[])"
    )]
    pub struct CreateFunctionWithIdCall {
        pub function_id: ::ethers::core::types::Address,
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub container_registry: ::std::string::String,
        pub container: ::std::string::String,
        pub version: ::std::string::String,
        pub schedule: ::std::string::String,
        pub params_schema: ::std::string::String,
        pub permitted_callers: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `createOracle` function with signature `createOracle(string,address,address,address)` and selector `0xf843b846`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createOracle",
        abi = "createOracle(string,address,address,address)"
    )]
    pub struct CreateOracleCall {
        pub name: ::std::string::String,
        pub signer: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `createOracleQueue` function with signature `createOracleQueue(string,address,bool,uint256,uint256,uint256)` and selector `0xe7675651`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createOracleQueue",
        abi = "createOracleQueue(string,address,bool,uint256,uint256,uint256)"
    )]
    pub struct CreateOracleQueueCall {
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub unpermissioned_feeds_enabled: bool,
        pub max_size: ::ethers::core::types::U256,
        pub reward: ::ethers::core::types::U256,
        pub oracle_timeout: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `createOracleWithId` function with signature `createOracleWithId(address,string,address,address,address)` and selector `0x16703130`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createOracleWithId",
        abi = "createOracleWithId(address,string,address,address,address)"
    )]
    pub struct CreateOracleWithIdCall {
        pub oracle_id: ::ethers::core::types::Address,
        pub name: ::std::string::String,
        pub signer: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `createRoutineWithId` function with signature `createRoutineWithId(address,address,address,bytes,string)` and selector `0x410d3013`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "createRoutineWithId",
        abi = "createRoutineWithId(address,address,address,bytes,string)"
    )]
    pub struct CreateRoutineWithIdCall {
        pub routine_id: ::ethers::core::types::Address,
        pub function_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
        pub schedule: ::std::string::String,
    }
    ///Container type for all input parameters for the `diamondCut` function with signature `diamondCut((address,uint8,bytes4[])[],address,bytes)` and selector `0x1f931c1c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "diamondCut",
        abi = "diamondCut((address,uint8,bytes4[])[],address,bytes)"
    )]
    pub struct DiamondCutCall {
        pub diamond_cut: ::std::vec::Vec<FacetCut>,
        pub init: ::ethers::core::types::Address,
        pub calldata: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `enclaveGarbageCollect` function with signature `enclaveGarbageCollect(address,uint256)` and selector `0xc06e4eda`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "enclaveGarbageCollect",
        abi = "enclaveGarbageCollect(address,uint256)"
    )]
    pub struct EnclaveGarbageCollectCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub enclave_idx: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `enclaveHeartbeat` function with signature `enclaveHeartbeat(address)` and selector `0xce834437`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "enclaveHeartbeat", abi = "enclaveHeartbeat(address)")]
    pub struct EnclaveHeartbeatCall {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `enclaveSignerToEnclaveId` function with signature `enclaveSignerToEnclaveId(address)` and selector `0x2ff75ec2`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "enclaveSignerToEnclaveId",
        abi = "enclaveSignerToEnclaveId(address)"
    )]
    pub struct EnclaveSignerToEnclaveIdCall {
        pub signer: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `enclaves` function with signature `enclaves(address)` and selector `0xfaeedb07`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "enclaves", abi = "enclaves(address)")]
    pub struct EnclavesCall {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `estimatedRunCost` function with signature `estimatedRunCost(address,uint256)` and selector `0x3da87438`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "estimatedRunCost", abi = "estimatedRunCost(address,uint256)")]
    pub struct EstimatedRunCostCall {
        pub function_id: ::ethers::core::types::Address,
        pub gas_price: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `facetAddress` function with signature `facetAddress(bytes4)` and selector `0xcdffacc6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "facetAddress", abi = "facetAddress(bytes4)")]
    pub struct FacetAddressCall {
        pub function_selector: [u8; 4],
    }
    ///Container type for all input parameters for the `facetAddresses` function with signature `facetAddresses()` and selector `0x52ef6b2c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "facetAddresses", abi = "facetAddresses()")]
    pub struct FacetAddressesCall;
    ///Container type for all input parameters for the `facetFunctionSelectors` function with signature `facetFunctionSelectors(address)` and selector `0xadfca15e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "facetFunctionSelectors",
        abi = "facetFunctionSelectors(address)"
    )]
    pub struct FacetFunctionSelectorsCall {
        pub facet: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `facets` function with signature `facets()` and selector `0x7a0ed627`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "facets", abi = "facets()")]
    pub struct FacetsCall;
    ///Container type for all input parameters for the `failEnclave` function with signature `failEnclave(address,address,uint256)` and selector `0x39d920e6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "failEnclave", abi = "failEnclave(address,address,uint256)")]
    pub struct FailEnclaveCall {
        pub verifier_id: ::ethers::core::types::Address,
        pub enclave_id: ::ethers::core::types::Address,
        pub verifier_idx: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `failFunctionResult` function with signature `failFunctionResult((uint256,address,uint256,uint256,uint8,address[],bytes32[],uint8[]))` and selector `0x52c7cc93`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "failFunctionResult",
        abi = "failFunctionResult((uint256,address,uint256,uint256,uint8,address[],bytes32[],uint8[]))"
    )]
    pub struct FailFunctionResultCall {
        pub params: FunctionFailParams,
    }
    ///Container type for all input parameters for the `forceOverrideVerify` function with signature `forceOverrideVerify(address)` and selector `0xe231b12f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "forceOverrideVerify", abi = "forceOverrideVerify(address)")]
    pub struct ForceOverrideVerifyCall {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `forward` function with signature `forward((uint256,uint256,uint256,address,address,bytes)[],bytes[])` and selector `0x7096052c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "forward",
        abi = "forward((uint256,uint256,uint256,address,address,bytes)[],bytes[])"
    )]
    pub struct ForwardCall {
        pub transactions: ::std::vec::Vec<Transaction>,
        pub signatures: ::std::vec::Vec<::ethers::core::types::Bytes>,
    }
    ///Container type for all input parameters for the `funcs` function with signature `funcs(address)` and selector `0x8ef92003`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "funcs", abi = "funcs(address)")]
    pub struct FuncsCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `functionCallSettings` function with signature `functionCallSettings(address)` and selector `0xa30f8d25`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "functionCallSettings", abi = "functionCallSettings(address)")]
    pub struct FunctionCallSettingsCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `functionCalls` function with signature `functionCalls(address)` and selector `0x826df326`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "functionCalls", abi = "functionCalls(address)")]
    pub struct FunctionCallsCall {
        pub call_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `functionEscrowFund` function with signature `functionEscrowFund(address)` and selector `0xba93166c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "functionEscrowFund", abi = "functionEscrowFund(address)")]
    pub struct FunctionEscrowFundCall {
        pub account_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `functionEscrowWithdraw` function with signature `functionEscrowWithdraw(address,address,uint256)` and selector `0xa29baf1e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "functionEscrowWithdraw",
        abi = "functionEscrowWithdraw(address,address,uint256)"
    )]
    pub struct FunctionEscrowWithdrawCall {
        pub recipient: ::ethers::core::types::Address,
        pub function_id: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `functionExists` function with signature `functionExists(address)` and selector `0xa13001c9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "functionExists", abi = "functionExists(address)")]
    pub struct FunctionExistsCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `functionSettings` function with signature `functionSettings(address)` and selector `0xce77efa6`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "functionSettings", abi = "functionSettings(address)")]
    pub struct FunctionSettingsCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `functionVerify` function with signature `functionVerify(uint256,address,address,uint256,uint256,bool,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[])` and selector `0xa5625b96`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "functionVerify",
        abi = "functionVerify(uint256,address,address,uint256,uint256,bool,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[])"
    )]
    pub struct FunctionVerifyCall {
        pub enclave_idx: ::ethers::core::types::U256,
        pub function_id: ::ethers::core::types::Address,
        pub delegated_signer_address: ::ethers::core::types::Address,
        pub observed_time: ::ethers::core::types::U256,
        pub next_allowed_timestamp: ::ethers::core::types::U256,
        pub is_failure: bool,
        pub mr_enclave: [u8; 32],
        pub transactions: ::std::vec::Vec<Transaction>,
        pub signatures: ::std::vec::Vec<::ethers::core::types::Bytes>,
    }
    ///Container type for all input parameters for the `functionVerifyRequest` function with signature `functionVerifyRequest(uint256,address,address,uint256,uint256,bool,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[],address[])` and selector `0xb8390a56`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "functionVerifyRequest",
        abi = "functionVerifyRequest(uint256,address,address,uint256,uint256,bool,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[],address[])"
    )]
    pub struct FunctionVerifyRequestCall {
        pub enclave_idx: ::ethers::core::types::U256,
        pub function_id: ::ethers::core::types::Address,
        pub delegated_signer_address: ::ethers::core::types::Address,
        pub observed_time: ::ethers::core::types::U256,
        pub next_allowed_timestamp: ::ethers::core::types::U256,
        pub is_failure: bool,
        pub mr_enclave: [u8; 32],
        pub transactions: ::std::vec::Vec<Transaction>,
        pub signatures: ::std::vec::Vec<::ethers::core::types::Bytes>,
        pub function_call_ids: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `getActiveFunctionCallsByQueue` function with signature `getActiveFunctionCallsByQueue(address)` and selector `0xfa88c651`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getActiveFunctionCallsByQueue",
        abi = "getActiveFunctionCallsByQueue(address)"
    )]
    pub struct GetActiveFunctionCallsByQueueCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getActiveFunctionsByQueue` function with signature `getActiveFunctionsByQueue(address)` and selector `0x1fc747b7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getActiveFunctionsByQueue",
        abi = "getActiveFunctionsByQueue(address)"
    )]
    pub struct GetActiveFunctionsByQueueCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getActiveRequestsByQueue` function with signature `getActiveRequestsByQueue(address)` and selector `0x55c053c3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getActiveRequestsByQueue",
        abi = "getActiveRequestsByQueue(address)"
    )]
    pub struct GetActiveRequestsByQueueCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getActiveRoutinesByQueue` function with signature `getActiveRoutinesByQueue(address)` and selector `0x9da3c6eb`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getActiveRoutinesByQueue",
        abi = "getActiveRoutinesByQueue(address)"
    )]
    pub struct GetActiveRoutinesByQueueCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getAggregatorsByAuthority` function with signature `getAggregatorsByAuthority(address)` and selector `0x911c30f3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getAggregatorsByAuthority",
        abi = "getAggregatorsByAuthority(address)"
    )]
    pub struct GetAggregatorsByAuthorityCall {
        pub user: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getAllAggregators` function with signature `getAllAggregators()` and selector `0x465c65dd`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getAllAggregators", abi = "getAllAggregators()")]
    pub struct GetAllAggregatorsCall;
    ///Container type for all input parameters for the `getAllFunctions` function with signature `getAllFunctions()` and selector `0xab6418b4`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getAllFunctions", abi = "getAllFunctions()")]
    pub struct GetAllFunctionsCall;
    ///Container type for all input parameters for the `getAttestationQueueMrEnclaves` function with signature `getAttestationQueueMrEnclaves(address)` and selector `0x0f3bc418`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getAttestationQueueMrEnclaves",
        abi = "getAttestationQueueMrEnclaves(address)"
    )]
    pub struct GetAttestationQueueMrEnclavesCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getCurrentIntervalId` function with signature `getCurrentIntervalId(address)` and selector `0x1dc1da86`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getCurrentIntervalId", abi = "getCurrentIntervalId(address)")]
    pub struct GetCurrentIntervalIdCall {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getEnclaveIdx` function with signature `getEnclaveIdx(address)` and selector `0x21fb3bbc`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getEnclaveIdx", abi = "getEnclaveIdx(address)")]
    pub struct GetEnclaveIdxCall {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getEnclaves` function with signature `getEnclaves(address)` and selector `0x340dd88b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getEnclaves", abi = "getEnclaves(address)")]
    pub struct GetEnclavesCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getFunctionMrEnclaves` function with signature `getFunctionMrEnclaves(address)` and selector `0x526112ce`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getFunctionMrEnclaves", abi = "getFunctionMrEnclaves(address)")]
    pub struct GetFunctionMrEnclavesCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getFunctionPermittedCallers` function with signature `getFunctionPermittedCallers(address)` and selector `0xafdcbd6a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getFunctionPermittedCallers",
        abi = "getFunctionPermittedCallers(address)"
    )]
    pub struct GetFunctionPermittedCallersCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getFunctionsByAuthority` function with signature `getFunctionsByAuthority(address)` and selector `0x357f633f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getFunctionsByAuthority",
        abi = "getFunctionsByAuthority(address)"
    )]
    pub struct GetFunctionsByAuthorityCall {
        pub user: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getIntervalResult` function with signature `getIntervalResult(address,uint80)` and selector `0x3d24ef6e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getIntervalResult", abi = "getIntervalResult(address,uint80)")]
    pub struct GetIntervalResultCall {
        pub aggregator_id: ::ethers::core::types::Address,
        pub interval_id: u128,
    }
    ///Container type for all input parameters for the `getOracleIdx` function with signature `getOracleIdx(address)` and selector `0xd87dd0ac`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getOracleIdx", abi = "getOracleIdx(address)")]
    pub struct GetOracleIdxCall {
        pub oracle_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getOracleQueueAllowedMrEnclaves` function with signature `getOracleQueueAllowedMrEnclaves(address)` and selector `0xf04b0f59`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getOracleQueueAllowedMrEnclaves",
        abi = "getOracleQueueAllowedMrEnclaves(address)"
    )]
    pub struct GetOracleQueueAllowedMrEnclavesCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getOracles` function with signature `getOracles(address)` and selector `0x8e749281`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getOracles", abi = "getOracles(address)")]
    pub struct GetOraclesCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getPermission` function with signature `getPermission(address,address)` and selector `0x910185dd`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getPermission", abi = "getPermission(address,address)")]
    pub struct GetPermissionCall {
        pub granter: ::ethers::core::types::Address,
        pub grantee: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getRequestsByFunctionId` function with signature `getRequestsByFunctionId(address)` and selector `0xb68e3ace`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getRequestsByFunctionId",
        abi = "getRequestsByFunctionId(address)"
    )]
    pub struct GetRequestsByFunctionIdCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getRoutinesByAuthority` function with signature `getRoutinesByAuthority(address)` and selector `0xb36afb5a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getRoutinesByAuthority",
        abi = "getRoutinesByAuthority(address)"
    )]
    pub struct GetRoutinesByAuthorityCall {
        pub authority: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getRoutinesByFunctionId` function with signature `getRoutinesByFunctionId(address)` and selector `0x27c66c0f`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getRoutinesByFunctionId",
        abi = "getRoutinesByFunctionId(address)"
    )]
    pub struct GetRoutinesByFunctionIdCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getStakeForEnclave` function with signature `getStakeForEnclave(address)` and selector `0x376d9b41`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getStakeForEnclave", abi = "getStakeForEnclave(address)")]
    pub struct GetStakeForEnclaveCall {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getStakeForEnclaveWithToken` function with signature `getStakeForEnclaveWithToken(address,address)` and selector `0x3ff8f2af`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getStakeForEnclaveWithToken",
        abi = "getStakeForEnclaveWithToken(address,address)"
    )]
    pub struct GetStakeForEnclaveWithTokenCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub token: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getStakingConfig` function with signature `getStakingConfig(address)` and selector `0x5133a68c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "getStakingConfig", abi = "getStakingConfig(address)")]
    pub struct GetStakingConfigCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `getTransactionHash` function with signature `getTransactionHash(uint256,uint256,uint256,address,address,bytes)` and selector `0xd93f1970`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "getTransactionHash",
        abi = "getTransactionHash(uint256,uint256,uint256,address,address,bytes)"
    )]
    pub struct GetTransactionHashCall {
        pub expiration_time_seconds: ::ethers::core::types::U256,
        pub gas_limit: ::ethers::core::types::U256,
        pub value: ::ethers::core::types::U256,
        pub to: ::ethers::core::types::Address,
        pub from: ::ethers::core::types::Address,
        pub data: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `hasPermission` function with signature `hasPermission(address,address,uint256)` and selector `0x8b01813d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "hasPermission", abi = "hasPermission(address,address,uint256)")]
    pub struct HasPermissionCall {
        pub granter: ::ethers::core::types::Address,
        pub grantee: ::ethers::core::types::Address,
        pub permission: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `init` function with signature `init()` and selector `0xe1c7392a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "init", abi = "init()")]
    pub struct InitCall;
    ///Container type for all input parameters for the `initialize` function with signature `initialize()` and selector `0x8129fc1c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "initialize", abi = "initialize()")]
    pub struct InitializeCall;
    ///Container type for all input parameters for the `isAdmin` function with signature `isAdmin(address)` and selector `0x24d7806c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "isAdmin", abi = "isAdmin(address)")]
    pub struct IsAdminCall {
        pub sender: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isAllowed` function with signature `isAllowed(address)` and selector `0xbabcc539`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "isAllowed", abi = "isAllowed(address)")]
    pub struct IsAllowedCall {
        pub sender: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isEnclaveValid` function with signature `isEnclaveValid(address)` and selector `0xfb4acdfe`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "isEnclaveValid", abi = "isEnclaveValid(address)")]
    pub struct IsEnclaveValidCall {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `isTrustedForwarder` function with signature `isTrustedForwarder(address)` and selector `0x572b6c05`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "isTrustedForwarder", abi = "isTrustedForwarder(address)")]
    pub struct IsTrustedForwarderCall(pub ::ethers::core::types::Address);
    ///Container type for all input parameters for the `latestResult` function with signature `latestResult(address)` and selector `0xfab005a2`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "latestResult", abi = "latestResult(address)")]
    pub struct LatestResultCall {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `openInterval` function with signature `openInterval(address)` and selector `0x0f2544be`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "openInterval", abi = "openInterval(address)")]
    pub struct OpenIntervalCall {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `oracleGarbageCollect` function with signature `oracleGarbageCollect(address,uint256)` and selector `0x71da68ff`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "oracleGarbageCollect",
        abi = "oracleGarbageCollect(address,uint256)"
    )]
    pub struct OracleGarbageCollectCall {
        pub oracle_id: ::ethers::core::types::Address,
        pub oracle_idx: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `oracleHeartbeat` function with signature `oracleHeartbeat(address)` and selector `0xf53b638c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "oracleHeartbeat", abi = "oracleHeartbeat(address)")]
    pub struct OracleHeartbeatCall {
        pub oracle_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `oracleQueues` function with signature `oracleQueues(address)` and selector `0xf2378e88`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "oracleQueues", abi = "oracleQueues(address)")]
    pub struct OracleQueuesCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `oracles` function with signature `oracles(address)` and selector `0xaddd5099`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "oracles", abi = "oracles(address)")]
    pub struct OraclesCall {
        pub oracle_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `owner` function with signature `owner()` and selector `0x8da5cb5b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "owner", abi = "owner()")]
    pub struct OwnerCall;
    ///Container type for all input parameters for the `prepareUnstake` function with signature `prepareUnstake(address)` and selector `0xb8d35d6a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "prepareUnstake", abi = "prepareUnstake(address)")]
    pub struct PrepareUnstakeCall {
        pub enclave_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `queueAttestationConfigs` function with signature `queueAttestationConfigs(address)` and selector `0x6ddc9122`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "queueAttestationConfigs",
        abi = "queueAttestationConfigs(address)"
    )]
    pub struct QueueAttestationConfigsCall {
        pub queue_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `recoverStakeWithToken` function with signature `recoverStakeWithToken(address,address,uint256)` and selector `0x5e8e1ad0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "recoverStakeWithToken",
        abi = "recoverStakeWithToken(address,address,uint256)"
    )]
    pub struct RecoverStakeWithTokenCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub token: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `removeMrEnclaveFromAttestationQueue` function with signature `removeMrEnclaveFromAttestationQueue(address,bytes32)` and selector `0x083f30cf`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "removeMrEnclaveFromAttestationQueue",
        abi = "removeMrEnclaveFromAttestationQueue(address,bytes32)"
    )]
    pub struct RemoveMrEnclaveFromAttestationQueueCall {
        pub queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    ///Container type for all input parameters for the `removeMrEnclaveFromFunction` function with signature `removeMrEnclaveFromFunction(address,bytes32)` and selector `0xf0184db9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "removeMrEnclaveFromFunction",
        abi = "removeMrEnclaveFromFunction(address,bytes32)"
    )]
    pub struct RemoveMrEnclaveFromFunctionCall {
        pub function_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    ///Container type for all input parameters for the `removeMrEnclaveFromOracleQueue` function with signature `removeMrEnclaveFromOracleQueue(address,bytes32)` and selector `0x262955d8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "removeMrEnclaveFromOracleQueue",
        abi = "removeMrEnclaveFromOracleQueue(address,bytes32)"
    )]
    pub struct RemoveMrEnclaveFromOracleQueueCall {
        pub queue_id: ::ethers::core::types::Address,
        pub mr_enclave: [u8; 32],
    }
    ///Container type for all input parameters for the `requestFund` function with signature `requestFund(address)` and selector `0x52a061d7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "requestFund", abi = "requestFund(address)")]
    pub struct RequestFundCall {
        pub request_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `requestWithdrawal` function with signature `requestWithdrawal(address,address,uint256)` and selector `0x8985646a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "requestWithdrawal",
        abi = "requestWithdrawal(address,address,uint256)"
    )]
    pub struct RequestWithdrawalCall {
        pub request_id: ::ethers::core::types::Address,
        pub recipient: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `requests` function with signature `requests(address)` and selector `0x74adad1d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "requests", abi = "requests(address)")]
    pub struct RequestsCall {
        pub request_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `rotateEnclaveSigner` function with signature `rotateEnclaveSigner(address,address)` and selector `0x2628b3a9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "rotateEnclaveSigner",
        abi = "rotateEnclaveSigner(address,address)"
    )]
    pub struct RotateEnclaveSignerCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub new_signer: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `rotateOracleSigner` function with signature `rotateOracleSigner(address,address)` and selector `0x4d1b776d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "rotateOracleSigner",
        abi = "rotateOracleSigner(address,address)"
    )]
    pub struct RotateOracleSignerCall {
        pub oracle_id: ::ethers::core::types::Address,
        pub new_signer: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `routineEscrowFund` function with signature `routineEscrowFund(address)` and selector `0x5d4e4594`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "routineEscrowFund", abi = "routineEscrowFund(address)")]
    pub struct RoutineEscrowFundCall {
        pub routine_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `routineEscrowWithdraw` function with signature `routineEscrowWithdraw(address,uint256)` and selector `0xfab08683`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "routineEscrowWithdraw",
        abi = "routineEscrowWithdraw(address,uint256)"
    )]
    pub struct RoutineEscrowWithdrawCall {
        pub routine_id: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `routineExists` function with signature `routineExists(address)` and selector `0xc98d9be8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "routineExists", abi = "routineExists(address)")]
    pub struct RoutineExistsCall {
        pub routine_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `routines` function with signature `routines(address)` and selector `0xfdcc54d2`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "routines", abi = "routines(address)")]
    pub struct RoutinesCall {
        pub routine_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `saveResults` function with signature `saveResults(address[],int256[],address,uint256)` and selector `0x735e3555`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "saveResults",
        abi = "saveResults(address[],int256[],address,uint256)"
    )]
    pub struct SaveResultsCall {
        pub ids: ::std::vec::Vec<::ethers::core::types::Address>,
        pub results: ::std::vec::Vec<::ethers::core::types::I256>,
        pub queue_id: ::ethers::core::types::Address,
        pub oracle_idx: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `sendDelayedRequest` function with signature `sendDelayedRequest(address,address,bytes,uint256)` and selector `0x80eb181e`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "sendDelayedRequest",
        abi = "sendDelayedRequest(address,address,bytes,uint256)"
    )]
    pub struct SendDelayedRequestCall {
        pub request_id: ::ethers::core::types::Address,
        pub function_id: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
        pub start_after: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `sendRequest` function with signature `sendRequest(address,bytes)` and selector `0x62d3fe46`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "sendRequest", abi = "sendRequest(address,bytes)")]
    pub struct SendRequestCall {
        pub function_id: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `sendRequestWithId` function with signature `sendRequestWithId(address,address,bytes)` and selector `0x264c1450`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "sendRequestWithId",
        abi = "sendRequestWithId(address,address,bytes)"
    )]
    pub struct SendRequestWithIdCall {
        pub request_id: ::ethers::core::types::Address,
        pub function_id: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `setAdmin` function with signature `setAdmin(address,bool)` and selector `0x4b0bddd2`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "setAdmin", abi = "setAdmin(address,bool)")]
    pub struct SetAdminCall {
        pub sender: ::ethers::core::types::Address,
        pub status: bool,
    }
    ///Container type for all input parameters for the `setAggregatorConfig` function with signature `setAggregatorConfig(address,string,address,uint256,uint256,uint256,string,address,uint256,uint256,uint256,bool)` and selector `0xdd0ad73a`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setAggregatorConfig",
        abi = "setAggregatorConfig(address,string,address,uint256,uint256,uint256,string,address,uint256,uint256,uint256,bool)"
    )]
    pub struct SetAggregatorConfigCall {
        pub aggregator_id: ::ethers::core::types::Address,
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub batch_size: ::ethers::core::types::U256,
        pub min_update_delay_seconds: ::ethers::core::types::U256,
        pub min_oracle_results: ::ethers::core::types::U256,
        pub jobs_hash: ::std::string::String,
        pub queue_id: ::ethers::core::types::Address,
        pub variance_threshold: ::ethers::core::types::U256,
        pub min_job_results: ::ethers::core::types::U256,
        pub force_report_period: ::ethers::core::types::U256,
        pub enable_history: bool,
    }
    ///Container type for all input parameters for the `setAllowed` function with signature `setAllowed(address,bool)` and selector `0x4697f05d`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "setAllowed", abi = "setAllowed(address,bool)")]
    pub struct SetAllowedCall {
        pub sender: ::ethers::core::types::Address,
        pub status: bool,
    }
    ///Container type for all input parameters for the `setAttestationQueueConfig` function with signature `setAttestationQueueConfig(address,address,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256)` and selector `0xf7d48307`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setAttestationQueueConfig",
        abi = "setAttestationQueueConfig(address,address,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256)"
    )]
    pub struct SetAttestationQueueConfigCall {
        pub queue_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
        pub max_size: ::ethers::core::types::U256,
        pub reward: ::ethers::core::types::U256,
        pub enclave_timeout: ::ethers::core::types::U256,
        pub max_enclave_verification_age: ::ethers::core::types::U256,
        pub allow_authority_override_after: ::ethers::core::types::U256,
        pub require_authority_heartbeat_permission: bool,
        pub require_usage_permissions: bool,
        pub max_consecutive_function_failures: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setAttestationQueuePermission` function with signature `setAttestationQueuePermission(address,address,uint256,bool)` and selector `0xa77a07d3`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setAttestationQueuePermission",
        abi = "setAttestationQueuePermission(address,address,uint256,bool)"
    )]
    pub struct SetAttestationQueuePermissionCall {
        pub queue_id: ::ethers::core::types::Address,
        pub grantee: ::ethers::core::types::Address,
        pub permission: ::ethers::core::types::U256,
        pub on: bool,
    }
    ///Container type for all input parameters for the `setFunctionCallSettings` function with signature `setFunctionCallSettings(address,bool,uint256,uint256,bool,bool)` and selector `0x6b7ef38b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setFunctionCallSettings",
        abi = "setFunctionCallSettings(address,bool,uint256,uint256,bool,bool)"
    )]
    pub struct SetFunctionCallSettingsCall {
        pub function_id: ::ethers::core::types::Address,
        pub require_estimated_run_cost_fee: bool,
        pub minimum_fee: ::ethers::core::types::U256,
        pub max_gas_cost: ::ethers::core::types::U256,
        pub require_caller_pay_full_cost: bool,
        pub require_sender_be_return_address: bool,
    }
    ///Container type for all input parameters for the `setFunctionConfig` function with signature `setFunctionConfig(address,string,address,string,string,string,string,string,address[])` and selector `0x822e99d5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setFunctionConfig",
        abi = "setFunctionConfig(address,string,address,string,string,string,string,string,address[])"
    )]
    pub struct SetFunctionConfigCall {
        pub function_id: ::ethers::core::types::Address,
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub container_registry: ::std::string::String,
        pub container: ::std::string::String,
        pub version: ::std::string::String,
        pub schedule: ::std::string::String,
        pub params_schema: ::std::string::String,
        pub permitted_callers: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all input parameters for the `setFunctionDeactivated` function with signature `setFunctionDeactivated(address)` and selector `0x725483a5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setFunctionDeactivated",
        abi = "setFunctionDeactivated(address)"
    )]
    pub struct SetFunctionDeactivatedCall {
        pub function_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `setFunctionSettings` function with signature `setFunctionSettings(address,(uint256,bool,bool,bool,uint256,bool,uint256,bool))` and selector `0xfeb0de89`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setFunctionSettings",
        abi = "setFunctionSettings(address,(uint256,bool,bool,bool,uint256,bool,uint256,bool))"
    )]
    pub struct SetFunctionSettingsCall {
        pub function_id: ::ethers::core::types::Address,
        pub settings: FunctionSettings,
    }
    ///Container type for all input parameters for the `setOracleConfig` function with signature `setOracleConfig(address,string,address,address,address)` and selector `0xf50b5ed0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setOracleConfig",
        abi = "setOracleConfig(address,string,address,address,address)"
    )]
    pub struct SetOracleConfigCall {
        pub oracle_id: ::ethers::core::types::Address,
        pub name: ::std::string::String,
        pub signer: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `setOracleQueueAttestationConfig` function with signature `setOracleQueueAttestationConfig(address,address,bytes32[],bool,bool)` and selector `0x88033af5`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setOracleQueueAttestationConfig",
        abi = "setOracleQueueAttestationConfig(address,address,bytes32[],bool,bool)"
    )]
    pub struct SetOracleQueueAttestationConfigCall {
        pub queue_id: ::ethers::core::types::Address,
        pub attestation_queue_id: ::ethers::core::types::Address,
        pub mr_enclaves: ::std::vec::Vec<[u8; 32]>,
        pub require_valid_enclave: bool,
        pub require_heartbeat_permission: bool,
    }
    ///Container type for all input parameters for the `setOracleQueueConfig` function with signature `setOracleQueueConfig(address,string,address,bool,uint256,uint256,uint256)` and selector `0xb6590411`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setOracleQueueConfig",
        abi = "setOracleQueueConfig(address,string,address,bool,uint256,uint256,uint256)"
    )]
    pub struct SetOracleQueueConfigCall {
        pub queue_id: ::ethers::core::types::Address,
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub unpermissioned_feeds_enabled: bool,
        pub max_size: ::ethers::core::types::U256,
        pub reward: ::ethers::core::types::U256,
        pub oracle_timeout: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setOracleQueuePermission` function with signature `setOracleQueuePermission(address,address,uint256,bool)` and selector `0x01fc1ba2`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setOracleQueuePermission",
        abi = "setOracleQueuePermission(address,address,uint256,bool)"
    )]
    pub struct SetOracleQueuePermissionCall {
        pub queue_id: ::ethers::core::types::Address,
        pub grantee: ::ethers::core::types::Address,
        pub permission: ::ethers::core::types::U256,
        pub on: bool,
    }
    ///Container type for all input parameters for the `setStakingConfig` function with signature `setStakingConfig(address,address,uint256,uint256,uint256)` and selector `0xf22644c2`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setStakingConfig",
        abi = "setStakingConfig(address,address,uint256,uint256,uint256)"
    )]
    pub struct SetStakingConfigCall {
        pub queue_id: ::ethers::core::types::Address,
        pub token: ::ethers::core::types::Address,
        pub staking_amount: ::ethers::core::types::U256,
        pub staking_period: ::ethers::core::types::U256,
        pub unstaking_period: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `setToleratedTimestampDiscrepancy` function with signature `setToleratedTimestampDiscrepancy(uint256)` and selector `0x101277b2`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "setToleratedTimestampDiscrepancy",
        abi = "setToleratedTimestampDiscrepancy(uint256)"
    )]
    pub struct SetToleratedTimestampDiscrepancyCall {
        pub tolerance: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `slashStake` function with signature `slashStake(address,uint256)` and selector `0x98d1c5a8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "slashStake", abi = "slashStake(address,uint256)")]
    pub struct SlashStakeCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `supportsInterface` function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "supportsInterface", abi = "supportsInterface(bytes4)")]
    pub struct SupportsInterfaceCall {
        pub interface_id: [u8; 4],
    }
    ///Container type for all input parameters for the `totalStaked` function with signature `totalStaked(address,address)` and selector `0xf21630cb`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "totalStaked", abi = "totalStaked(address,address)")]
    pub struct TotalStakedCall {
        pub queue_id: ::ethers::core::types::Address,
        pub token: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `totalSupply` function with signature `totalSupply()` and selector `0x18160ddd`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "totalSupply", abi = "totalSupply()")]
    pub struct TotalSupplyCall;
    ///Container type for all input parameters for the `transfer` function with signature `transfer(address,uint256)` and selector `0xa9059cbb`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "transfer", abi = "transfer(address,uint256)")]
    pub struct TransferCall {
        pub to: ::ethers::core::types::Address,
        pub value: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `transferFrom` function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "transferFrom", abi = "transferFrom(address,address,uint256)")]
    pub struct TransferFromCall {
        pub from: ::ethers::core::types::Address,
        pub to: ::ethers::core::types::Address,
        pub value: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `transferOwnership` function with signature `transferOwnership(address)` and selector `0xf2fde38b`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "transferOwnership", abi = "transferOwnership(address)")]
    pub struct TransferOwnershipCall {
        pub new_owner: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `unstake` function with signature `unstake(address,uint256)` and selector `0xc2a672e0`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "unstake", abi = "unstake(address,uint256)")]
    pub struct UnstakeCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub amount: ::ethers::core::types::U256,
    }
    ///Container type for all input parameters for the `updateEnclave` function with signature `updateEnclave(address,bytes)` and selector `0x5cd6ac0c`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "updateEnclave", abi = "updateEnclave(address,bytes)")]
    pub struct UpdateEnclaveCall {
        pub enclave_id: ::ethers::core::types::Address,
        pub cid: ::ethers::core::types::Bytes,
    }
    ///Container type for all input parameters for the `updateRoutine` function with signature `updateRoutine(address,address,address,bytes,string)` and selector `0x9300c999`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "updateRoutine",
        abi = "updateRoutine(address,address,address,bytes,string)"
    )]
    pub struct UpdateRoutineCall {
        pub routine_id: ::ethers::core::types::Address,
        pub function_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
        pub params: ::ethers::core::types::Bytes,
        pub schedule: ::std::string::String,
    }
    ///Container type for all input parameters for the `validate` function with signature `validate(address,address,bytes32[])` and selector `0x1755a7f8`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "validate", abi = "validate(address,address,bytes32[])")]
    pub struct ValidateCall {
        pub signer: ::ethers::core::types::Address,
        pub attestation_queue_id: ::ethers::core::types::Address,
        pub valid_measurements: ::std::vec::Vec<[u8; 32]>,
    }
    ///Container type for all input parameters for the `verifyCallbackParams` function with signature `verifyCallbackParams(address[],bytes32[])` and selector `0x9c5eb6d9`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "verifyCallbackParams",
        abi = "verifyCallbackParams(address[],bytes32[])"
    )]
    pub struct VerifyCallbackParamsCall {
        pub call_ids: ::std::vec::Vec<::ethers::core::types::Address>,
        pub hashes: ::std::vec::Vec<[u8; 32]>,
    }
    ///Container type for all input parameters for the `verifyEnclave` function with signature `verifyEnclave(address,address,uint256,uint256,bytes32)` and selector `0xef0ebd71`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "verifyEnclave",
        abi = "verifyEnclave(address,address,uint256,uint256,bytes32)"
    )]
    pub struct VerifyEnclaveCall {
        pub verifier_id: ::ethers::core::types::Address,
        pub enclave_id: ::ethers::core::types::Address,
        pub enclave_idx: ::ethers::core::types::U256,
        pub timestamp: ::ethers::core::types::U256,
        pub mr_enclave: [u8; 32],
    }
    ///Container type for all input parameters for the `verifyFunctionResult` function with signature `verifyFunctionResult((uint256,address,address,uint256,uint256,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[],address[],bytes32[],uint8[]))` and selector `0x3bd7b617`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(
        name = "verifyFunctionResult",
        abi = "verifyFunctionResult((uint256,address,address,uint256,uint256,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[],address[],bytes32[],uint8[]))"
    )]
    pub struct VerifyFunctionResultCall {
        pub params: FunctionVerifyParams,
    }
    ///Container type for all input parameters for the `viewAggregatorResults` function with signature `viewAggregatorResults(address)` and selector `0xde866484`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "viewAggregatorResults", abi = "viewAggregatorResults(address)")]
    pub struct ViewAggregatorResultsCall {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Container type for all input parameters for the `viewLatestResult` function with signature `viewLatestResult(address)` and selector `0xbdf5edef`
    #[derive(
        Clone,
        ::ethers::contract::EthCall,
        ::ethers::contract::EthDisplay,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    #[ethcall(name = "viewLatestResult", abi = "viewLatestResult(address)")]
    pub struct ViewLatestResultCall {
        pub aggregator_id: ::ethers::core::types::Address,
    }
    ///Container type for all of the contract's call
    #[derive(Clone, ::ethers::contract::EthAbiType, Debug, PartialEq, Eq, Hash)]
    pub enum SwitchboardCalls {
        AddMrEnclaveToAttestationQueue(AddMrEnclaveToAttestationQueueCall),
        AddMrEnclaveToFunction(AddMrEnclaveToFunctionCall),
        AddMrEnclaveToOracleQueue(AddMrEnclaveToOracleQueueCall),
        AddStake(AddStakeCall),
        AggregatorEscrowFund(AggregatorEscrowFundCall),
        AggregatorEscrowWithdraw(AggregatorEscrowWithdrawCall),
        AggregatorHistory(AggregatorHistoryCall),
        Aggregators(AggregatorsCall),
        Allowance(AllowanceCall),
        Approve(ApproveCall),
        AttestationQueueHasMrEnclave(AttestationQueueHasMrEnclaveCall),
        AttestationQueues(AttestationQueuesCall),
        BalanceOf(BalanceOfCall),
        CallBalances(CallBalancesCall),
        CallFunction(CallFunctionCall),
        CreateAggregator(CreateAggregatorCall),
        CreateAttestationQueue(CreateAttestationQueueCall),
        CreateEnclave(CreateEnclaveCall),
        CreateEnclaveWithId(CreateEnclaveWithIdCall),
        CreateFunction(CreateFunctionCall),
        CreateFunctionWithId(CreateFunctionWithIdCall),
        CreateOracle(CreateOracleCall),
        CreateOracleQueue(CreateOracleQueueCall),
        CreateOracleWithId(CreateOracleWithIdCall),
        CreateRoutineWithId(CreateRoutineWithIdCall),
        DiamondCut(DiamondCutCall),
        EnclaveGarbageCollect(EnclaveGarbageCollectCall),
        EnclaveHeartbeat(EnclaveHeartbeatCall),
        EnclaveSignerToEnclaveId(EnclaveSignerToEnclaveIdCall),
        Enclaves(EnclavesCall),
        EstimatedRunCost(EstimatedRunCostCall),
        FacetAddress(FacetAddressCall),
        FacetAddresses(FacetAddressesCall),
        FacetFunctionSelectors(FacetFunctionSelectorsCall),
        Facets(FacetsCall),
        FailEnclave(FailEnclaveCall),
        FailFunctionResult(FailFunctionResultCall),
        ForceOverrideVerify(ForceOverrideVerifyCall),
        Forward(ForwardCall),
        Funcs(FuncsCall),
        FunctionCallSettings(FunctionCallSettingsCall),
        FunctionCalls(FunctionCallsCall),
        FunctionEscrowFund(FunctionEscrowFundCall),
        FunctionEscrowWithdraw(FunctionEscrowWithdrawCall),
        FunctionExists(FunctionExistsCall),
        FunctionSettings(FunctionSettingsCall),
        FunctionVerify(FunctionVerifyCall),
        FunctionVerifyRequest(FunctionVerifyRequestCall),
        GetActiveFunctionCallsByQueue(GetActiveFunctionCallsByQueueCall),
        GetActiveFunctionsByQueue(GetActiveFunctionsByQueueCall),
        GetActiveRequestsByQueue(GetActiveRequestsByQueueCall),
        GetActiveRoutinesByQueue(GetActiveRoutinesByQueueCall),
        GetAggregatorsByAuthority(GetAggregatorsByAuthorityCall),
        GetAllAggregators(GetAllAggregatorsCall),
        GetAllFunctions(GetAllFunctionsCall),
        GetAttestationQueueMrEnclaves(GetAttestationQueueMrEnclavesCall),
        GetCurrentIntervalId(GetCurrentIntervalIdCall),
        GetEnclaveIdx(GetEnclaveIdxCall),
        GetEnclaves(GetEnclavesCall),
        GetFunctionMrEnclaves(GetFunctionMrEnclavesCall),
        GetFunctionPermittedCallers(GetFunctionPermittedCallersCall),
        GetFunctionsByAuthority(GetFunctionsByAuthorityCall),
        GetIntervalResult(GetIntervalResultCall),
        GetOracleIdx(GetOracleIdxCall),
        GetOracleQueueAllowedMrEnclaves(GetOracleQueueAllowedMrEnclavesCall),
        GetOracles(GetOraclesCall),
        GetPermission(GetPermissionCall),
        GetRequestsByFunctionId(GetRequestsByFunctionIdCall),
        GetRoutinesByAuthority(GetRoutinesByAuthorityCall),
        GetRoutinesByFunctionId(GetRoutinesByFunctionIdCall),
        GetStakeForEnclave(GetStakeForEnclaveCall),
        GetStakeForEnclaveWithToken(GetStakeForEnclaveWithTokenCall),
        GetStakingConfig(GetStakingConfigCall),
        GetTransactionHash(GetTransactionHashCall),
        HasPermission(HasPermissionCall),
        Init(InitCall),
        Initialize(InitializeCall),
        IsAdmin(IsAdminCall),
        IsAllowed(IsAllowedCall),
        IsEnclaveValid(IsEnclaveValidCall),
        IsTrustedForwarder(IsTrustedForwarderCall),
        LatestResult(LatestResultCall),
        OpenInterval(OpenIntervalCall),
        OracleGarbageCollect(OracleGarbageCollectCall),
        OracleHeartbeat(OracleHeartbeatCall),
        OracleQueues(OracleQueuesCall),
        Oracles(OraclesCall),
        Owner(OwnerCall),
        PrepareUnstake(PrepareUnstakeCall),
        QueueAttestationConfigs(QueueAttestationConfigsCall),
        RecoverStakeWithToken(RecoverStakeWithTokenCall),
        RemoveMrEnclaveFromAttestationQueue(RemoveMrEnclaveFromAttestationQueueCall),
        RemoveMrEnclaveFromFunction(RemoveMrEnclaveFromFunctionCall),
        RemoveMrEnclaveFromOracleQueue(RemoveMrEnclaveFromOracleQueueCall),
        RequestFund(RequestFundCall),
        RequestWithdrawal(RequestWithdrawalCall),
        Requests(RequestsCall),
        RotateEnclaveSigner(RotateEnclaveSignerCall),
        RotateOracleSigner(RotateOracleSignerCall),
        RoutineEscrowFund(RoutineEscrowFundCall),
        RoutineEscrowWithdraw(RoutineEscrowWithdrawCall),
        RoutineExists(RoutineExistsCall),
        Routines(RoutinesCall),
        SaveResults(SaveResultsCall),
        SendDelayedRequest(SendDelayedRequestCall),
        SendRequest(SendRequestCall),
        SendRequestWithId(SendRequestWithIdCall),
        SetAdmin(SetAdminCall),
        SetAggregatorConfig(SetAggregatorConfigCall),
        SetAllowed(SetAllowedCall),
        SetAttestationQueueConfig(SetAttestationQueueConfigCall),
        SetAttestationQueuePermission(SetAttestationQueuePermissionCall),
        SetFunctionCallSettings(SetFunctionCallSettingsCall),
        SetFunctionConfig(SetFunctionConfigCall),
        SetFunctionDeactivated(SetFunctionDeactivatedCall),
        SetFunctionSettings(SetFunctionSettingsCall),
        SetOracleConfig(SetOracleConfigCall),
        SetOracleQueueAttestationConfig(SetOracleQueueAttestationConfigCall),
        SetOracleQueueConfig(SetOracleQueueConfigCall),
        SetOracleQueuePermission(SetOracleQueuePermissionCall),
        SetStakingConfig(SetStakingConfigCall),
        SetToleratedTimestampDiscrepancy(SetToleratedTimestampDiscrepancyCall),
        SlashStake(SlashStakeCall),
        SupportsInterface(SupportsInterfaceCall),
        TotalStaked(TotalStakedCall),
        TotalSupply(TotalSupplyCall),
        Transfer(TransferCall),
        TransferFrom(TransferFromCall),
        TransferOwnership(TransferOwnershipCall),
        Unstake(UnstakeCall),
        UpdateEnclave(UpdateEnclaveCall),
        UpdateRoutine(UpdateRoutineCall),
        Validate(ValidateCall),
        VerifyCallbackParams(VerifyCallbackParamsCall),
        VerifyEnclave(VerifyEnclaveCall),
        VerifyFunctionResult(VerifyFunctionResultCall),
        ViewAggregatorResults(ViewAggregatorResultsCall),
        ViewLatestResult(ViewLatestResultCall),
    }
    impl ::ethers::core::abi::AbiDecode for SwitchboardCalls {
        fn decode(
            data: impl AsRef<[u8]>,
        ) -> ::core::result::Result<Self, ::ethers::core::abi::AbiError> {
            let data = data.as_ref();
            if let Ok(decoded) =
                <AddMrEnclaveToAttestationQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AddMrEnclaveToAttestationQueue(decoded));
            }
            if let Ok(decoded) =
                <AddMrEnclaveToFunctionCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AddMrEnclaveToFunction(decoded));
            }
            if let Ok(decoded) =
                <AddMrEnclaveToOracleQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AddMrEnclaveToOracleQueue(decoded));
            }
            if let Ok(decoded) = <AddStakeCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::AddStake(decoded));
            }
            if let Ok(decoded) =
                <AggregatorEscrowFundCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AggregatorEscrowFund(decoded));
            }
            if let Ok(decoded) =
                <AggregatorEscrowWithdrawCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AggregatorEscrowWithdraw(decoded));
            }
            if let Ok(decoded) =
                <AggregatorHistoryCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AggregatorHistory(decoded));
            }
            if let Ok(decoded) = <AggregatorsCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Aggregators(decoded));
            }
            if let Ok(decoded) = <AllowanceCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Allowance(decoded));
            }
            if let Ok(decoded) = <ApproveCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Approve(decoded));
            }
            if let Ok(decoded) =
                <AttestationQueueHasMrEnclaveCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AttestationQueueHasMrEnclave(decoded));
            }
            if let Ok(decoded) =
                <AttestationQueuesCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::AttestationQueues(decoded));
            }
            if let Ok(decoded) = <BalanceOfCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::BalanceOf(decoded));
            }
            if let Ok(decoded) = <CallBalancesCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CallBalances(decoded));
            }
            if let Ok(decoded) = <CallFunctionCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CallFunction(decoded));
            }
            if let Ok(decoded) =
                <CreateAggregatorCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateAggregator(decoded));
            }
            if let Ok(decoded) =
                <CreateAttestationQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateAttestationQueue(decoded));
            }
            if let Ok(decoded) = <CreateEnclaveCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateEnclave(decoded));
            }
            if let Ok(decoded) =
                <CreateEnclaveWithIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateEnclaveWithId(decoded));
            }
            if let Ok(decoded) =
                <CreateFunctionCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateFunction(decoded));
            }
            if let Ok(decoded) =
                <CreateFunctionWithIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateFunctionWithId(decoded));
            }
            if let Ok(decoded) = <CreateOracleCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateOracle(decoded));
            }
            if let Ok(decoded) =
                <CreateOracleQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateOracleQueue(decoded));
            }
            if let Ok(decoded) =
                <CreateOracleWithIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateOracleWithId(decoded));
            }
            if let Ok(decoded) =
                <CreateRoutineWithIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::CreateRoutineWithId(decoded));
            }
            if let Ok(decoded) = <DiamondCutCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::DiamondCut(decoded));
            }
            if let Ok(decoded) =
                <EnclaveGarbageCollectCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveGarbageCollect(decoded));
            }
            if let Ok(decoded) =
                <EnclaveHeartbeatCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveHeartbeat(decoded));
            }
            if let Ok(decoded) =
                <EnclaveSignerToEnclaveIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EnclaveSignerToEnclaveId(decoded));
            }
            if let Ok(decoded) = <EnclavesCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Enclaves(decoded));
            }
            if let Ok(decoded) =
                <EstimatedRunCostCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::EstimatedRunCost(decoded));
            }
            if let Ok(decoded) = <FacetAddressCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FacetAddress(decoded));
            }
            if let Ok(decoded) =
                <FacetAddressesCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FacetAddresses(decoded));
            }
            if let Ok(decoded) =
                <FacetFunctionSelectorsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FacetFunctionSelectors(decoded));
            }
            if let Ok(decoded) = <FacetsCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Facets(decoded));
            }
            if let Ok(decoded) = <FailEnclaveCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::FailEnclave(decoded));
            }
            if let Ok(decoded) =
                <FailFunctionResultCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FailFunctionResult(decoded));
            }
            if let Ok(decoded) =
                <ForceOverrideVerifyCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ForceOverrideVerify(decoded));
            }
            if let Ok(decoded) = <ForwardCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Forward(decoded));
            }
            if let Ok(decoded) = <FuncsCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Funcs(decoded));
            }
            if let Ok(decoded) =
                <FunctionCallSettingsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionCallSettings(decoded));
            }
            if let Ok(decoded) = <FunctionCallsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionCalls(decoded));
            }
            if let Ok(decoded) =
                <FunctionEscrowFundCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionEscrowFund(decoded));
            }
            if let Ok(decoded) =
                <FunctionEscrowWithdrawCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionEscrowWithdraw(decoded));
            }
            if let Ok(decoded) =
                <FunctionExistsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionExists(decoded));
            }
            if let Ok(decoded) =
                <FunctionSettingsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionSettings(decoded));
            }
            if let Ok(decoded) =
                <FunctionVerifyCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionVerify(decoded));
            }
            if let Ok(decoded) =
                <FunctionVerifyRequestCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::FunctionVerifyRequest(decoded));
            }
            if let Ok(decoded) =
                <GetActiveFunctionCallsByQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetActiveFunctionCallsByQueue(decoded));
            }
            if let Ok(decoded) =
                <GetActiveFunctionsByQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetActiveFunctionsByQueue(decoded));
            }
            if let Ok(decoded) =
                <GetActiveRequestsByQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetActiveRequestsByQueue(decoded));
            }
            if let Ok(decoded) =
                <GetActiveRoutinesByQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetActiveRoutinesByQueue(decoded));
            }
            if let Ok(decoded) =
                <GetAggregatorsByAuthorityCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetAggregatorsByAuthority(decoded));
            }
            if let Ok(decoded) =
                <GetAllAggregatorsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetAllAggregators(decoded));
            }
            if let Ok(decoded) =
                <GetAllFunctionsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetAllFunctions(decoded));
            }
            if let Ok(decoded) =
                <GetAttestationQueueMrEnclavesCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetAttestationQueueMrEnclaves(decoded));
            }
            if let Ok(decoded) =
                <GetCurrentIntervalIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetCurrentIntervalId(decoded));
            }
            if let Ok(decoded) = <GetEnclaveIdxCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetEnclaveIdx(decoded));
            }
            if let Ok(decoded) = <GetEnclavesCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::GetEnclaves(decoded));
            }
            if let Ok(decoded) =
                <GetFunctionMrEnclavesCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetFunctionMrEnclaves(decoded));
            }
            if let Ok(decoded) =
                <GetFunctionPermittedCallersCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetFunctionPermittedCallers(decoded));
            }
            if let Ok(decoded) =
                <GetFunctionsByAuthorityCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetFunctionsByAuthority(decoded));
            }
            if let Ok(decoded) =
                <GetIntervalResultCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetIntervalResult(decoded));
            }
            if let Ok(decoded) = <GetOracleIdxCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetOracleIdx(decoded));
            }
            if let Ok(decoded) =
                <GetOracleQueueAllowedMrEnclavesCall as ::ethers::core::abi::AbiDecode>::decode(
                    data,
                )
            {
                return Ok(Self::GetOracleQueueAllowedMrEnclaves(decoded));
            }
            if let Ok(decoded) = <GetOraclesCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::GetOracles(decoded));
            }
            if let Ok(decoded) = <GetPermissionCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetPermission(decoded));
            }
            if let Ok(decoded) =
                <GetRequestsByFunctionIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetRequestsByFunctionId(decoded));
            }
            if let Ok(decoded) =
                <GetRoutinesByAuthorityCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetRoutinesByAuthority(decoded));
            }
            if let Ok(decoded) =
                <GetRoutinesByFunctionIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetRoutinesByFunctionId(decoded));
            }
            if let Ok(decoded) =
                <GetStakeForEnclaveCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetStakeForEnclave(decoded));
            }
            if let Ok(decoded) =
                <GetStakeForEnclaveWithTokenCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetStakeForEnclaveWithToken(decoded));
            }
            if let Ok(decoded) =
                <GetStakingConfigCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetStakingConfig(decoded));
            }
            if let Ok(decoded) =
                <GetTransactionHashCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::GetTransactionHash(decoded));
            }
            if let Ok(decoded) = <HasPermissionCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::HasPermission(decoded));
            }
            if let Ok(decoded) = <InitCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Init(decoded));
            }
            if let Ok(decoded) = <InitializeCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Initialize(decoded));
            }
            if let Ok(decoded) = <IsAdminCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::IsAdmin(decoded));
            }
            if let Ok(decoded) = <IsAllowedCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::IsAllowed(decoded));
            }
            if let Ok(decoded) =
                <IsEnclaveValidCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::IsEnclaveValid(decoded));
            }
            if let Ok(decoded) =
                <IsTrustedForwarderCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::IsTrustedForwarder(decoded));
            }
            if let Ok(decoded) = <LatestResultCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::LatestResult(decoded));
            }
            if let Ok(decoded) = <OpenIntervalCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::OpenInterval(decoded));
            }
            if let Ok(decoded) =
                <OracleGarbageCollectCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::OracleGarbageCollect(decoded));
            }
            if let Ok(decoded) =
                <OracleHeartbeatCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::OracleHeartbeat(decoded));
            }
            if let Ok(decoded) = <OracleQueuesCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::OracleQueues(decoded));
            }
            if let Ok(decoded) = <OraclesCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Oracles(decoded));
            }
            if let Ok(decoded) = <OwnerCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Owner(decoded));
            }
            if let Ok(decoded) =
                <PrepareUnstakeCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::PrepareUnstake(decoded));
            }
            if let Ok(decoded) =
                <QueueAttestationConfigsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::QueueAttestationConfigs(decoded));
            }
            if let Ok(decoded) =
                <RecoverStakeWithTokenCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RecoverStakeWithToken(decoded));
            }
            if let Ok(decoded) =
                <RemoveMrEnclaveFromAttestationQueueCall as ::ethers::core::abi::AbiDecode>::decode(
                    data,
                )
            {
                return Ok(Self::RemoveMrEnclaveFromAttestationQueue(decoded));
            }
            if let Ok(decoded) =
                <RemoveMrEnclaveFromFunctionCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RemoveMrEnclaveFromFunction(decoded));
            }
            if let Ok(decoded) =
                <RemoveMrEnclaveFromOracleQueueCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RemoveMrEnclaveFromOracleQueue(decoded));
            }
            if let Ok(decoded) = <RequestFundCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::RequestFund(decoded));
            }
            if let Ok(decoded) =
                <RequestWithdrawalCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RequestWithdrawal(decoded));
            }
            if let Ok(decoded) = <RequestsCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Requests(decoded));
            }
            if let Ok(decoded) =
                <RotateEnclaveSignerCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RotateEnclaveSigner(decoded));
            }
            if let Ok(decoded) =
                <RotateOracleSignerCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RotateOracleSigner(decoded));
            }
            if let Ok(decoded) =
                <RoutineEscrowFundCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RoutineEscrowFund(decoded));
            }
            if let Ok(decoded) =
                <RoutineEscrowWithdrawCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RoutineEscrowWithdraw(decoded));
            }
            if let Ok(decoded) = <RoutineExistsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::RoutineExists(decoded));
            }
            if let Ok(decoded) = <RoutinesCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Routines(decoded));
            }
            if let Ok(decoded) = <SaveResultsCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::SaveResults(decoded));
            }
            if let Ok(decoded) =
                <SendDelayedRequestCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SendDelayedRequest(decoded));
            }
            if let Ok(decoded) = <SendRequestCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::SendRequest(decoded));
            }
            if let Ok(decoded) =
                <SendRequestWithIdCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SendRequestWithId(decoded));
            }
            if let Ok(decoded) = <SetAdminCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::SetAdmin(decoded));
            }
            if let Ok(decoded) =
                <SetAggregatorConfigCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetAggregatorConfig(decoded));
            }
            if let Ok(decoded) = <SetAllowedCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::SetAllowed(decoded));
            }
            if let Ok(decoded) =
                <SetAttestationQueueConfigCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetAttestationQueueConfig(decoded));
            }
            if let Ok(decoded) =
                <SetAttestationQueuePermissionCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetAttestationQueuePermission(decoded));
            }
            if let Ok(decoded) =
                <SetFunctionCallSettingsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetFunctionCallSettings(decoded));
            }
            if let Ok(decoded) =
                <SetFunctionConfigCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetFunctionConfig(decoded));
            }
            if let Ok(decoded) =
                <SetFunctionDeactivatedCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetFunctionDeactivated(decoded));
            }
            if let Ok(decoded) =
                <SetFunctionSettingsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetFunctionSettings(decoded));
            }
            if let Ok(decoded) =
                <SetOracleConfigCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetOracleConfig(decoded));
            }
            if let Ok(decoded) =
                <SetOracleQueueAttestationConfigCall as ::ethers::core::abi::AbiDecode>::decode(
                    data,
                )
            {
                return Ok(Self::SetOracleQueueAttestationConfig(decoded));
            }
            if let Ok(decoded) =
                <SetOracleQueueConfigCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetOracleQueueConfig(decoded));
            }
            if let Ok(decoded) =
                <SetOracleQueuePermissionCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetOracleQueuePermission(decoded));
            }
            if let Ok(decoded) =
                <SetStakingConfigCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SetStakingConfig(decoded));
            }
            if let Ok(decoded) =
                <SetToleratedTimestampDiscrepancyCall as ::ethers::core::abi::AbiDecode>::decode(
                    data,
                )
            {
                return Ok(Self::SetToleratedTimestampDiscrepancy(decoded));
            }
            if let Ok(decoded) = <SlashStakeCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::SlashStake(decoded));
            }
            if let Ok(decoded) =
                <SupportsInterfaceCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::SupportsInterface(decoded));
            }
            if let Ok(decoded) = <TotalStakedCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::TotalStaked(decoded));
            }
            if let Ok(decoded) = <TotalSupplyCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::TotalSupply(decoded));
            }
            if let Ok(decoded) = <TransferCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Transfer(decoded));
            }
            if let Ok(decoded) = <TransferFromCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::TransferFrom(decoded));
            }
            if let Ok(decoded) =
                <TransferOwnershipCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::TransferOwnership(decoded));
            }
            if let Ok(decoded) = <UnstakeCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Unstake(decoded));
            }
            if let Ok(decoded) = <UpdateEnclaveCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::UpdateEnclave(decoded));
            }
            if let Ok(decoded) = <UpdateRoutineCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::UpdateRoutine(decoded));
            }
            if let Ok(decoded) = <ValidateCall as ::ethers::core::abi::AbiDecode>::decode(data) {
                return Ok(Self::Validate(decoded));
            }
            if let Ok(decoded) =
                <VerifyCallbackParamsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::VerifyCallbackParams(decoded));
            }
            if let Ok(decoded) = <VerifyEnclaveCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::VerifyEnclave(decoded));
            }
            if let Ok(decoded) =
                <VerifyFunctionResultCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::VerifyFunctionResult(decoded));
            }
            if let Ok(decoded) =
                <ViewAggregatorResultsCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ViewAggregatorResults(decoded));
            }
            if let Ok(decoded) =
                <ViewLatestResultCall as ::ethers::core::abi::AbiDecode>::decode(data)
            {
                return Ok(Self::ViewLatestResult(decoded));
            }
            Err(::ethers::core::abi::Error::InvalidData.into())
        }
    }
    impl ::ethers::core::abi::AbiEncode for SwitchboardCalls {
        fn encode(self) -> Vec<u8> {
            match self {
                Self::AddMrEnclaveToAttestationQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AddMrEnclaveToFunction(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AddMrEnclaveToOracleQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AddStake(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::AggregatorEscrowFund(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AggregatorEscrowWithdraw(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AggregatorHistory(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Aggregators(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Allowance(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Approve(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::AttestationQueueHasMrEnclave(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::AttestationQueues(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::BalanceOf(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CallBalances(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CallFunction(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CreateAggregator(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CreateAttestationQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CreateEnclave(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CreateEnclaveWithId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CreateFunction(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CreateFunctionWithId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CreateOracle(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CreateOracleQueue(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::CreateOracleWithId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::CreateRoutineWithId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::DiamondCut(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::EnclaveGarbageCollect(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::EnclaveHeartbeat(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::EnclaveSignerToEnclaveId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Enclaves(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::EstimatedRunCost(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FacetAddress(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FacetAddresses(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FacetFunctionSelectors(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Facets(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FailEnclave(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FailFunctionResult(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ForceOverrideVerify(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::Forward(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Funcs(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FunctionCallSettings(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionCalls(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FunctionEscrowFund(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionEscrowWithdraw(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::FunctionExists(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FunctionSettings(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FunctionVerify(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::FunctionVerifyRequest(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetActiveFunctionCallsByQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetActiveFunctionsByQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetActiveRequestsByQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetActiveRoutinesByQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetAggregatorsByAuthority(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetAllAggregators(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetAllFunctions(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetAttestationQueueMrEnclaves(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetCurrentIntervalId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetEnclaveIdx(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetEnclaves(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetFunctionMrEnclaves(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetFunctionPermittedCallers(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetFunctionsByAuthority(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetIntervalResult(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetOracleIdx(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetOracleQueueAllowedMrEnclaves(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetOracles(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetPermission(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetRequestsByFunctionId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRoutinesByAuthority(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRequestsByFunctionId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRoutinesByAuthority(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetRoutinesByFunctionId(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetStakeForEnclave(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetStakeForEnclaveWithToken(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::GetStakingConfig(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::GetTransactionHash(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::HasPermission(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Init(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Initialize(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::IsAdmin(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::IsAllowed(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::IsEnclaveValid(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::IsTrustedForwarder(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::LatestResult(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::OpenInterval(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::OracleGarbageCollect(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::OracleHeartbeat(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::OracleQueues(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Oracles(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Owner(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::PrepareUnstake(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::QueueAttestationConfigs(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RecoverStakeWithToken(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RemoveMrEnclaveFromAttestationQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RemoveMrEnclaveFromFunction(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RemoveMrEnclaveFromOracleQueue(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RequestFund(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::RequestWithdrawal(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Requests(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::RotateEnclaveSigner(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RotateOracleSigner(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RoutineEscrowFund(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::RoutineEscrowWithdraw(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::RoutineExists(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Routines(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SaveResults(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SendDelayedRequest(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SendRequest(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SendRequestWithId(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SetAdmin(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SetAggregatorConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetAllowed(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SetAttestationQueueConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetAttestationQueuePermission(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetFunctionCallSettings(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetFunctionConfig(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SetFunctionDeactivated(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetFunctionSettings(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetOracleConfig(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SetOracleQueueAttestationConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetOracleQueueConfig(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetOracleQueuePermission(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SetStakingConfig(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SetToleratedTimestampDiscrepancy(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::SlashStake(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::SupportsInterface(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::TotalStaked(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::TotalSupply(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Transfer(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::TransferFrom(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::TransferOwnership(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Unstake(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::UpdateEnclave(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::UpdateRoutine(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::Validate(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::VerifyCallbackParams(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::VerifyEnclave(element) => ::ethers::core::abi::AbiEncode::encode(element),
                Self::VerifyFunctionResult(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ViewAggregatorResults(element) => {
                    ::ethers::core::abi::AbiEncode::encode(element)
                }
                Self::ViewLatestResult(element) => ::ethers::core::abi::AbiEncode::encode(element),
            }
        }
    }
    impl ::core::fmt::Display for SwitchboardCalls {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
                Self::AddMrEnclaveToAttestationQueue(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AddMrEnclaveToFunction(element) => ::core::fmt::Display::fmt(element, f),
                Self::AddMrEnclaveToOracleQueue(element) => ::core::fmt::Display::fmt(element, f),
                Self::AddStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorEscrowFund(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorEscrowWithdraw(element) => ::core::fmt::Display::fmt(element, f),
                Self::AggregatorHistory(element) => ::core::fmt::Display::fmt(element, f),
                Self::Aggregators(element) => ::core::fmt::Display::fmt(element, f),
                Self::Allowance(element) => ::core::fmt::Display::fmt(element, f),
                Self::Approve(element) => ::core::fmt::Display::fmt(element, f),
                Self::AttestationQueueHasMrEnclave(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::AttestationQueues(element) => ::core::fmt::Display::fmt(element, f),
                Self::BalanceOf(element) => ::core::fmt::Display::fmt(element, f),
                Self::CallBalances(element) => ::core::fmt::Display::fmt(element, f),
                Self::CallFunction(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateAggregator(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateAttestationQueue(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateEnclave(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateEnclaveWithId(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateFunction(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateFunctionWithId(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateOracle(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateOracleQueue(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateOracleWithId(element) => ::core::fmt::Display::fmt(element, f),
                Self::CreateRoutineWithId(element) => ::core::fmt::Display::fmt(element, f),
                Self::DiamondCut(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveGarbageCollect(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveHeartbeat(element) => ::core::fmt::Display::fmt(element, f),
                Self::EnclaveSignerToEnclaveId(element) => ::core::fmt::Display::fmt(element, f),
                Self::Enclaves(element) => ::core::fmt::Display::fmt(element, f),
                Self::EstimatedRunCost(element) => ::core::fmt::Display::fmt(element, f),
                Self::FacetAddress(element) => ::core::fmt::Display::fmt(element, f),
                Self::FacetAddresses(element) => ::core::fmt::Display::fmt(element, f),
                Self::FacetFunctionSelectors(element) => ::core::fmt::Display::fmt(element, f),
                Self::Facets(element) => ::core::fmt::Display::fmt(element, f),
                Self::FailEnclave(element) => ::core::fmt::Display::fmt(element, f),
                Self::FailFunctionResult(element) => ::core::fmt::Display::fmt(element, f),
                Self::ForceOverrideVerify(element) => ::core::fmt::Display::fmt(element, f),
                Self::Forward(element) => ::core::fmt::Display::fmt(element, f),
                Self::Funcs(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionCallSettings(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionCalls(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionEscrowFund(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionEscrowWithdraw(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionSettings(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionVerify(element) => ::core::fmt::Display::fmt(element, f),
                Self::FunctionVerifyRequest(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetActiveFunctionCallsByQueue(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetActiveFunctionsByQueue(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetActiveRequestsByQueue(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetActiveRoutinesByQueue(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetAggregatorsByAuthority(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetAllAggregators(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetAllFunctions(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetAttestationQueueMrEnclaves(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetCurrentIntervalId(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetEnclaveIdx(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetEnclaves(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetFunctionMrEnclaves(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetFunctionPermittedCallers(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetFunctionsByAuthority(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetIntervalResult(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetOracleIdx(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetOracleQueueAllowedMrEnclaves(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::GetOracles(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetPermission(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetRequestsByFunctionId(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetRoutinesByAuthority(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetRoutinesByFunctionId(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetStakeForEnclave(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetStakeForEnclaveWithToken(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetStakingConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::GetTransactionHash(element) => ::core::fmt::Display::fmt(element, f),
                Self::HasPermission(element) => ::core::fmt::Display::fmt(element, f),
                Self::Init(element) => ::core::fmt::Display::fmt(element, f),
                Self::Initialize(element) => ::core::fmt::Display::fmt(element, f),
                Self::IsAdmin(element) => ::core::fmt::Display::fmt(element, f),
                Self::IsAllowed(element) => ::core::fmt::Display::fmt(element, f),
                Self::IsEnclaveValid(element) => ::core::fmt::Display::fmt(element, f),
                Self::IsTrustedForwarder(element) => ::core::fmt::Display::fmt(element, f),
                Self::LatestResult(element) => ::core::fmt::Display::fmt(element, f),
                Self::OpenInterval(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleGarbageCollect(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleHeartbeat(element) => ::core::fmt::Display::fmt(element, f),
                Self::OracleQueues(element) => ::core::fmt::Display::fmt(element, f),
                Self::Oracles(element) => ::core::fmt::Display::fmt(element, f),
                Self::Owner(element) => ::core::fmt::Display::fmt(element, f),
                Self::PrepareUnstake(element) => ::core::fmt::Display::fmt(element, f),
                Self::QueueAttestationConfigs(element) => ::core::fmt::Display::fmt(element, f),
                Self::RecoverStakeWithToken(element) => ::core::fmt::Display::fmt(element, f),
                Self::RemoveMrEnclaveFromAttestationQueue(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RemoveMrEnclaveFromFunction(element) => ::core::fmt::Display::fmt(element, f),
                Self::RemoveMrEnclaveFromOracleQueue(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::RequestFund(element) => ::core::fmt::Display::fmt(element, f),
                Self::RequestWithdrawal(element) => ::core::fmt::Display::fmt(element, f),
                Self::Requests(element) => ::core::fmt::Display::fmt(element, f),
                Self::RotateEnclaveSigner(element) => ::core::fmt::Display::fmt(element, f),
                Self::RotateOracleSigner(element) => ::core::fmt::Display::fmt(element, f),
                Self::RoutineEscrowFund(element) => ::core::fmt::Display::fmt(element, f),
                Self::RoutineEscrowWithdraw(element) => ::core::fmt::Display::fmt(element, f),
                Self::RoutineExists(element) => ::core::fmt::Display::fmt(element, f),
                Self::Routines(element) => ::core::fmt::Display::fmt(element, f),
                Self::SaveResults(element) => ::core::fmt::Display::fmt(element, f),
                Self::SendDelayedRequest(element) => ::core::fmt::Display::fmt(element, f),
                Self::SendRequest(element) => ::core::fmt::Display::fmt(element, f),
                Self::SendRequestWithId(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetAdmin(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetAggregatorConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetAllowed(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetAttestationQueueConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetAttestationQueuePermission(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetFunctionCallSettings(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetFunctionConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetFunctionDeactivated(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetFunctionSettings(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetOracleConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetOracleQueueAttestationConfig(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SetOracleQueueConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetOracleQueuePermission(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetStakingConfig(element) => ::core::fmt::Display::fmt(element, f),
                Self::SetToleratedTimestampDiscrepancy(element) => {
                    ::core::fmt::Display::fmt(element, f)
                }
                Self::SlashStake(element) => ::core::fmt::Display::fmt(element, f),
                Self::SupportsInterface(element) => ::core::fmt::Display::fmt(element, f),
                Self::TotalStaked(element) => ::core::fmt::Display::fmt(element, f),
                Self::TotalSupply(element) => ::core::fmt::Display::fmt(element, f),
                Self::Transfer(element) => ::core::fmt::Display::fmt(element, f),
                Self::TransferFrom(element) => ::core::fmt::Display::fmt(element, f),
                Self::TransferOwnership(element) => ::core::fmt::Display::fmt(element, f),
                Self::Unstake(element) => ::core::fmt::Display::fmt(element, f),
                Self::UpdateEnclave(element) => ::core::fmt::Display::fmt(element, f),
                Self::UpdateRoutine(element) => ::core::fmt::Display::fmt(element, f),
                Self::Validate(element) => ::core::fmt::Display::fmt(element, f),
                Self::VerifyCallbackParams(element) => ::core::fmt::Display::fmt(element, f),
                Self::VerifyEnclave(element) => ::core::fmt::Display::fmt(element, f),
                Self::VerifyFunctionResult(element) => ::core::fmt::Display::fmt(element, f),
                Self::ViewAggregatorResults(element) => ::core::fmt::Display::fmt(element, f),
                Self::ViewLatestResult(element) => ::core::fmt::Display::fmt(element, f),
            }
        }
    }
    impl ::core::convert::From<AddMrEnclaveToAttestationQueueCall> for SwitchboardCalls {
        fn from(value: AddMrEnclaveToAttestationQueueCall) -> Self {
            Self::AddMrEnclaveToAttestationQueue(value)
        }
    }
    impl ::core::convert::From<AddMrEnclaveToFunctionCall> for SwitchboardCalls {
        fn from(value: AddMrEnclaveToFunctionCall) -> Self {
            Self::AddMrEnclaveToFunction(value)
        }
    }
    impl ::core::convert::From<AddMrEnclaveToOracleQueueCall> for SwitchboardCalls {
        fn from(value: AddMrEnclaveToOracleQueueCall) -> Self {
            Self::AddMrEnclaveToOracleQueue(value)
        }
    }
    impl ::core::convert::From<AddStakeCall> for SwitchboardCalls {
        fn from(value: AddStakeCall) -> Self {
            Self::AddStake(value)
        }
    }
    impl ::core::convert::From<AggregatorEscrowFundCall> for SwitchboardCalls {
        fn from(value: AggregatorEscrowFundCall) -> Self {
            Self::AggregatorEscrowFund(value)
        }
    }
    impl ::core::convert::From<AggregatorEscrowWithdrawCall> for SwitchboardCalls {
        fn from(value: AggregatorEscrowWithdrawCall) -> Self {
            Self::AggregatorEscrowWithdraw(value)
        }
    }
    impl ::core::convert::From<AggregatorHistoryCall> for SwitchboardCalls {
        fn from(value: AggregatorHistoryCall) -> Self {
            Self::AggregatorHistory(value)
        }
    }
    impl ::core::convert::From<AggregatorsCall> for SwitchboardCalls {
        fn from(value: AggregatorsCall) -> Self {
            Self::Aggregators(value)
        }
    }
    impl ::core::convert::From<AllowanceCall> for SwitchboardCalls {
        fn from(value: AllowanceCall) -> Self {
            Self::Allowance(value)
        }
    }
    impl ::core::convert::From<ApproveCall> for SwitchboardCalls {
        fn from(value: ApproveCall) -> Self {
            Self::Approve(value)
        }
    }
    impl ::core::convert::From<AttestationQueueHasMrEnclaveCall> for SwitchboardCalls {
        fn from(value: AttestationQueueHasMrEnclaveCall) -> Self {
            Self::AttestationQueueHasMrEnclave(value)
        }
    }
    impl ::core::convert::From<AttestationQueuesCall> for SwitchboardCalls {
        fn from(value: AttestationQueuesCall) -> Self {
            Self::AttestationQueues(value)
        }
    }
    impl ::core::convert::From<BalanceOfCall> for SwitchboardCalls {
        fn from(value: BalanceOfCall) -> Self {
            Self::BalanceOf(value)
        }
    }
    impl ::core::convert::From<CallBalancesCall> for SwitchboardCalls {
        fn from(value: CallBalancesCall) -> Self {
            Self::CallBalances(value)
        }
    }
    impl ::core::convert::From<CallFunctionCall> for SwitchboardCalls {
        fn from(value: CallFunctionCall) -> Self {
            Self::CallFunction(value)
        }
    }
    impl ::core::convert::From<CreateAggregatorCall> for SwitchboardCalls {
        fn from(value: CreateAggregatorCall) -> Self {
            Self::CreateAggregator(value)
        }
    }
    impl ::core::convert::From<CreateAttestationQueueCall> for SwitchboardCalls {
        fn from(value: CreateAttestationQueueCall) -> Self {
            Self::CreateAttestationQueue(value)
        }
    }
    impl ::core::convert::From<CreateEnclaveCall> for SwitchboardCalls {
        fn from(value: CreateEnclaveCall) -> Self {
            Self::CreateEnclave(value)
        }
    }
    impl ::core::convert::From<CreateEnclaveWithIdCall> for SwitchboardCalls {
        fn from(value: CreateEnclaveWithIdCall) -> Self {
            Self::CreateEnclaveWithId(value)
        }
    }
    impl ::core::convert::From<CreateFunctionCall> for SwitchboardCalls {
        fn from(value: CreateFunctionCall) -> Self {
            Self::CreateFunction(value)
        }
    }
    impl ::core::convert::From<CreateFunctionWithIdCall> for SwitchboardCalls {
        fn from(value: CreateFunctionWithIdCall) -> Self {
            Self::CreateFunctionWithId(value)
        }
    }
    impl ::core::convert::From<CreateOracleCall> for SwitchboardCalls {
        fn from(value: CreateOracleCall) -> Self {
            Self::CreateOracle(value)
        }
    }
    impl ::core::convert::From<CreateOracleQueueCall> for SwitchboardCalls {
        fn from(value: CreateOracleQueueCall) -> Self {
            Self::CreateOracleQueue(value)
        }
    }
    impl ::core::convert::From<CreateOracleWithIdCall> for SwitchboardCalls {
        fn from(value: CreateOracleWithIdCall) -> Self {
            Self::CreateOracleWithId(value)
        }
    }
    impl ::core::convert::From<CreateRoutineWithIdCall> for SwitchboardCalls {
        fn from(value: CreateRoutineWithIdCall) -> Self {
            Self::CreateRoutineWithId(value)
        }
    }
    impl ::core::convert::From<DiamondCutCall> for SwitchboardCalls {
        fn from(value: DiamondCutCall) -> Self {
            Self::DiamondCut(value)
        }
    }
    impl ::core::convert::From<EnclaveGarbageCollectCall> for SwitchboardCalls {
        fn from(value: EnclaveGarbageCollectCall) -> Self {
            Self::EnclaveGarbageCollect(value)
        }
    }
    impl ::core::convert::From<EnclaveHeartbeatCall> for SwitchboardCalls {
        fn from(value: EnclaveHeartbeatCall) -> Self {
            Self::EnclaveHeartbeat(value)
        }
    }
    impl ::core::convert::From<EnclaveSignerToEnclaveIdCall> for SwitchboardCalls {
        fn from(value: EnclaveSignerToEnclaveIdCall) -> Self {
            Self::EnclaveSignerToEnclaveId(value)
        }
    }
    impl ::core::convert::From<EnclavesCall> for SwitchboardCalls {
        fn from(value: EnclavesCall) -> Self {
            Self::Enclaves(value)
        }
    }
    impl ::core::convert::From<EstimatedRunCostCall> for SwitchboardCalls {
        fn from(value: EstimatedRunCostCall) -> Self {
            Self::EstimatedRunCost(value)
        }
    }
    impl ::core::convert::From<FacetAddressCall> for SwitchboardCalls {
        fn from(value: FacetAddressCall) -> Self {
            Self::FacetAddress(value)
        }
    }
    impl ::core::convert::From<FacetAddressesCall> for SwitchboardCalls {
        fn from(value: FacetAddressesCall) -> Self {
            Self::FacetAddresses(value)
        }
    }
    impl ::core::convert::From<FacetFunctionSelectorsCall> for SwitchboardCalls {
        fn from(value: FacetFunctionSelectorsCall) -> Self {
            Self::FacetFunctionSelectors(value)
        }
    }
    impl ::core::convert::From<FacetsCall> for SwitchboardCalls {
        fn from(value: FacetsCall) -> Self {
            Self::Facets(value)
        }
    }
    impl ::core::convert::From<FailEnclaveCall> for SwitchboardCalls {
        fn from(value: FailEnclaveCall) -> Self {
            Self::FailEnclave(value)
        }
    }
    impl ::core::convert::From<FailFunctionResultCall> for SwitchboardCalls {
        fn from(value: FailFunctionResultCall) -> Self {
            Self::FailFunctionResult(value)
        }
    }
    impl ::core::convert::From<ForceOverrideVerifyCall> for SwitchboardCalls {
        fn from(value: ForceOverrideVerifyCall) -> Self {
            Self::ForceOverrideVerify(value)
        }
    }
    impl ::core::convert::From<ForwardCall> for SwitchboardCalls {
        fn from(value: ForwardCall) -> Self {
            Self::Forward(value)
        }
    }
    impl ::core::convert::From<FuncsCall> for SwitchboardCalls {
        fn from(value: FuncsCall) -> Self {
            Self::Funcs(value)
        }
    }
    impl ::core::convert::From<FunctionCallSettingsCall> for SwitchboardCalls {
        fn from(value: FunctionCallSettingsCall) -> Self {
            Self::FunctionCallSettings(value)
        }
    }
    impl ::core::convert::From<FunctionCallsCall> for SwitchboardCalls {
        fn from(value: FunctionCallsCall) -> Self {
            Self::FunctionCalls(value)
        }
    }
    impl ::core::convert::From<FunctionEscrowFundCall> for SwitchboardCalls {
        fn from(value: FunctionEscrowFundCall) -> Self {
            Self::FunctionEscrowFund(value)
        }
    }
    impl ::core::convert::From<FunctionEscrowWithdrawCall> for SwitchboardCalls {
        fn from(value: FunctionEscrowWithdrawCall) -> Self {
            Self::FunctionEscrowWithdraw(value)
        }
    }
    impl ::core::convert::From<FunctionExistsCall> for SwitchboardCalls {
        fn from(value: FunctionExistsCall) -> Self {
            Self::FunctionExists(value)
        }
    }
    impl ::core::convert::From<FunctionSettingsCall> for SwitchboardCalls {
        fn from(value: FunctionSettingsCall) -> Self {
            Self::FunctionSettings(value)
        }
    }
    impl ::core::convert::From<FunctionVerifyCall> for SwitchboardCalls {
        fn from(value: FunctionVerifyCall) -> Self {
            Self::FunctionVerify(value)
        }
    }
    impl ::core::convert::From<FunctionVerifyRequestCall> for SwitchboardCalls {
        fn from(value: FunctionVerifyRequestCall) -> Self {
            Self::FunctionVerifyRequest(value)
        }
    }
    impl ::core::convert::From<GetActiveFunctionCallsByQueueCall> for SwitchboardCalls {
        fn from(value: GetActiveFunctionCallsByQueueCall) -> Self {
            Self::GetActiveFunctionCallsByQueue(value)
        }
    }
    impl ::core::convert::From<GetActiveFunctionsByQueueCall> for SwitchboardCalls {
        fn from(value: GetActiveFunctionsByQueueCall) -> Self {
            Self::GetActiveFunctionsByQueue(value)
        }
    }
    impl ::core::convert::From<GetActiveRequestsByQueueCall> for SwitchboardCalls {
        fn from(value: GetActiveRequestsByQueueCall) -> Self {
            Self::GetActiveRequestsByQueue(value)
        }
    }
    impl ::core::convert::From<GetActiveRoutinesByQueueCall> for SwitchboardCalls {
        fn from(value: GetActiveRoutinesByQueueCall) -> Self {
            Self::GetActiveRoutinesByQueue(value)
        }
    }
    impl ::core::convert::From<GetAggregatorsByAuthorityCall> for SwitchboardCalls {
        fn from(value: GetAggregatorsByAuthorityCall) -> Self {
            Self::GetAggregatorsByAuthority(value)
        }
    }
    impl ::core::convert::From<GetAllAggregatorsCall> for SwitchboardCalls {
        fn from(value: GetAllAggregatorsCall) -> Self {
            Self::GetAllAggregators(value)
        }
    }
    impl ::core::convert::From<GetAllFunctionsCall> for SwitchboardCalls {
        fn from(value: GetAllFunctionsCall) -> Self {
            Self::GetAllFunctions(value)
        }
    }
    impl ::core::convert::From<GetAttestationQueueMrEnclavesCall> for SwitchboardCalls {
        fn from(value: GetAttestationQueueMrEnclavesCall) -> Self {
            Self::GetAttestationQueueMrEnclaves(value)
        }
    }
    impl ::core::convert::From<GetCurrentIntervalIdCall> for SwitchboardCalls {
        fn from(value: GetCurrentIntervalIdCall) -> Self {
            Self::GetCurrentIntervalId(value)
        }
    }
    impl ::core::convert::From<GetEnclaveIdxCall> for SwitchboardCalls {
        fn from(value: GetEnclaveIdxCall) -> Self {
            Self::GetEnclaveIdx(value)
        }
    }
    impl ::core::convert::From<GetEnclavesCall> for SwitchboardCalls {
        fn from(value: GetEnclavesCall) -> Self {
            Self::GetEnclaves(value)
        }
    }
    impl ::core::convert::From<GetFunctionMrEnclavesCall> for SwitchboardCalls {
        fn from(value: GetFunctionMrEnclavesCall) -> Self {
            Self::GetFunctionMrEnclaves(value)
        }
    }
    impl ::core::convert::From<GetFunctionPermittedCallersCall> for SwitchboardCalls {
        fn from(value: GetFunctionPermittedCallersCall) -> Self {
            Self::GetFunctionPermittedCallers(value)
        }
    }
    impl ::core::convert::From<GetFunctionsByAuthorityCall> for SwitchboardCalls {
        fn from(value: GetFunctionsByAuthorityCall) -> Self {
            Self::GetFunctionsByAuthority(value)
        }
    }
    impl ::core::convert::From<GetIntervalResultCall> for SwitchboardCalls {
        fn from(value: GetIntervalResultCall) -> Self {
            Self::GetIntervalResult(value)
        }
    }
    impl ::core::convert::From<GetOracleIdxCall> for SwitchboardCalls {
        fn from(value: GetOracleIdxCall) -> Self {
            Self::GetOracleIdx(value)
        }
    }
    impl ::core::convert::From<GetOracleQueueAllowedMrEnclavesCall> for SwitchboardCalls {
        fn from(value: GetOracleQueueAllowedMrEnclavesCall) -> Self {
            Self::GetOracleQueueAllowedMrEnclaves(value)
        }
    }
    impl ::core::convert::From<GetOraclesCall> for SwitchboardCalls {
        fn from(value: GetOraclesCall) -> Self {
            Self::GetOracles(value)
        }
    }
    impl ::core::convert::From<GetPermissionCall> for SwitchboardCalls {
        fn from(value: GetPermissionCall) -> Self {
            Self::GetPermission(value)
        }
    }
    impl ::core::convert::From<GetRequestsByFunctionIdCall> for SwitchboardCalls {
        fn from(value: GetRequestsByFunctionIdCall) -> Self {
            Self::GetRequestsByFunctionId(value)
        }
    }
    impl ::core::convert::From<GetRoutinesByAuthorityCall> for SwitchboardCalls {
        fn from(value: GetRoutinesByAuthorityCall) -> Self {
            Self::GetRoutinesByAuthority(value)
        }
    }
    impl ::core::convert::From<GetRoutinesByFunctionIdCall> for SwitchboardCalls {
        fn from(value: GetRoutinesByFunctionIdCall) -> Self {
            Self::GetRoutinesByFunctionId(value)
        }
    }
    impl ::core::convert::From<GetStakeForEnclaveCall> for SwitchboardCalls {
        fn from(value: GetStakeForEnclaveCall) -> Self {
            Self::GetStakeForEnclave(value)
        }
    }
    impl ::core::convert::From<GetStakeForEnclaveWithTokenCall> for SwitchboardCalls {
        fn from(value: GetStakeForEnclaveWithTokenCall) -> Self {
            Self::GetStakeForEnclaveWithToken(value)
        }
    }
    impl ::core::convert::From<GetStakingConfigCall> for SwitchboardCalls {
        fn from(value: GetStakingConfigCall) -> Self {
            Self::GetStakingConfig(value)
        }
    }
    impl ::core::convert::From<GetTransactionHashCall> for SwitchboardCalls {
        fn from(value: GetTransactionHashCall) -> Self {
            Self::GetTransactionHash(value)
        }
    }
    impl ::core::convert::From<HasPermissionCall> for SwitchboardCalls {
        fn from(value: HasPermissionCall) -> Self {
            Self::HasPermission(value)
        }
    }
    impl ::core::convert::From<InitCall> for SwitchboardCalls {
        fn from(value: InitCall) -> Self {
            Self::Init(value)
        }
    }
    impl ::core::convert::From<InitializeCall> for SwitchboardCalls {
        fn from(value: InitializeCall) -> Self {
            Self::Initialize(value)
        }
    }
    impl ::core::convert::From<IsAdminCall> for SwitchboardCalls {
        fn from(value: IsAdminCall) -> Self {
            Self::IsAdmin(value)
        }
    }
    impl ::core::convert::From<IsAllowedCall> for SwitchboardCalls {
        fn from(value: IsAllowedCall) -> Self {
            Self::IsAllowed(value)
        }
    }
    impl ::core::convert::From<IsEnclaveValidCall> for SwitchboardCalls {
        fn from(value: IsEnclaveValidCall) -> Self {
            Self::IsEnclaveValid(value)
        }
    }
    impl ::core::convert::From<IsTrustedForwarderCall> for SwitchboardCalls {
        fn from(value: IsTrustedForwarderCall) -> Self {
            Self::IsTrustedForwarder(value)
        }
    }
    impl ::core::convert::From<LatestResultCall> for SwitchboardCalls {
        fn from(value: LatestResultCall) -> Self {
            Self::LatestResult(value)
        }
    }
    impl ::core::convert::From<OpenIntervalCall> for SwitchboardCalls {
        fn from(value: OpenIntervalCall) -> Self {
            Self::OpenInterval(value)
        }
    }
    impl ::core::convert::From<OracleGarbageCollectCall> for SwitchboardCalls {
        fn from(value: OracleGarbageCollectCall) -> Self {
            Self::OracleGarbageCollect(value)
        }
    }
    impl ::core::convert::From<OracleHeartbeatCall> for SwitchboardCalls {
        fn from(value: OracleHeartbeatCall) -> Self {
            Self::OracleHeartbeat(value)
        }
    }
    impl ::core::convert::From<OracleQueuesCall> for SwitchboardCalls {
        fn from(value: OracleQueuesCall) -> Self {
            Self::OracleQueues(value)
        }
    }
    impl ::core::convert::From<OraclesCall> for SwitchboardCalls {
        fn from(value: OraclesCall) -> Self {
            Self::Oracles(value)
        }
    }
    impl ::core::convert::From<OwnerCall> for SwitchboardCalls {
        fn from(value: OwnerCall) -> Self {
            Self::Owner(value)
        }
    }
    impl ::core::convert::From<PrepareUnstakeCall> for SwitchboardCalls {
        fn from(value: PrepareUnstakeCall) -> Self {
            Self::PrepareUnstake(value)
        }
    }
    impl ::core::convert::From<QueueAttestationConfigsCall> for SwitchboardCalls {
        fn from(value: QueueAttestationConfigsCall) -> Self {
            Self::QueueAttestationConfigs(value)
        }
    }
    impl ::core::convert::From<RecoverStakeWithTokenCall> for SwitchboardCalls {
        fn from(value: RecoverStakeWithTokenCall) -> Self {
            Self::RecoverStakeWithToken(value)
        }
    }
    impl ::core::convert::From<RemoveMrEnclaveFromAttestationQueueCall> for SwitchboardCalls {
        fn from(value: RemoveMrEnclaveFromAttestationQueueCall) -> Self {
            Self::RemoveMrEnclaveFromAttestationQueue(value)
        }
    }
    impl ::core::convert::From<RemoveMrEnclaveFromFunctionCall> for SwitchboardCalls {
        fn from(value: RemoveMrEnclaveFromFunctionCall) -> Self {
            Self::RemoveMrEnclaveFromFunction(value)
        }
    }
    impl ::core::convert::From<RemoveMrEnclaveFromOracleQueueCall> for SwitchboardCalls {
        fn from(value: RemoveMrEnclaveFromOracleQueueCall) -> Self {
            Self::RemoveMrEnclaveFromOracleQueue(value)
        }
    }
    impl ::core::convert::From<RequestFundCall> for SwitchboardCalls {
        fn from(value: RequestFundCall) -> Self {
            Self::RequestFund(value)
        }
    }
    impl ::core::convert::From<RequestWithdrawalCall> for SwitchboardCalls {
        fn from(value: RequestWithdrawalCall) -> Self {
            Self::RequestWithdrawal(value)
        }
    }
    impl ::core::convert::From<RequestsCall> for SwitchboardCalls {
        fn from(value: RequestsCall) -> Self {
            Self::Requests(value)
        }
    }
    impl ::core::convert::From<RotateEnclaveSignerCall> for SwitchboardCalls {
        fn from(value: RotateEnclaveSignerCall) -> Self {
            Self::RotateEnclaveSigner(value)
        }
    }
    impl ::core::convert::From<RotateOracleSignerCall> for SwitchboardCalls {
        fn from(value: RotateOracleSignerCall) -> Self {
            Self::RotateOracleSigner(value)
        }
    }
    impl ::core::convert::From<RoutineEscrowFundCall> for SwitchboardCalls {
        fn from(value: RoutineEscrowFundCall) -> Self {
            Self::RoutineEscrowFund(value)
        }
    }
    impl ::core::convert::From<RoutineEscrowWithdrawCall> for SwitchboardCalls {
        fn from(value: RoutineEscrowWithdrawCall) -> Self {
            Self::RoutineEscrowWithdraw(value)
        }
    }
    impl ::core::convert::From<RoutineExistsCall> for SwitchboardCalls {
        fn from(value: RoutineExistsCall) -> Self {
            Self::RoutineExists(value)
        }
    }
    impl ::core::convert::From<RoutinesCall> for SwitchboardCalls {
        fn from(value: RoutinesCall) -> Self {
            Self::Routines(value)
        }
    }
    impl ::core::convert::From<SaveResultsCall> for SwitchboardCalls {
        fn from(value: SaveResultsCall) -> Self {
            Self::SaveResults(value)
        }
    }
    impl ::core::convert::From<SendDelayedRequestCall> for SwitchboardCalls {
        fn from(value: SendDelayedRequestCall) -> Self {
            Self::SendDelayedRequest(value)
        }
    }
    impl ::core::convert::From<SendRequestCall> for SwitchboardCalls {
        fn from(value: SendRequestCall) -> Self {
            Self::SendRequest(value)
        }
    }
    impl ::core::convert::From<SendRequestWithIdCall> for SwitchboardCalls {
        fn from(value: SendRequestWithIdCall) -> Self {
            Self::SendRequestWithId(value)
        }
    }
    impl ::core::convert::From<SetAdminCall> for SwitchboardCalls {
        fn from(value: SetAdminCall) -> Self {
            Self::SetAdmin(value)
        }
    }
    impl ::core::convert::From<SetAggregatorConfigCall> for SwitchboardCalls {
        fn from(value: SetAggregatorConfigCall) -> Self {
            Self::SetAggregatorConfig(value)
        }
    }
    impl ::core::convert::From<SetAllowedCall> for SwitchboardCalls {
        fn from(value: SetAllowedCall) -> Self {
            Self::SetAllowed(value)
        }
    }
    impl ::core::convert::From<SetAttestationQueueConfigCall> for SwitchboardCalls {
        fn from(value: SetAttestationQueueConfigCall) -> Self {
            Self::SetAttestationQueueConfig(value)
        }
    }
    impl ::core::convert::From<SetAttestationQueuePermissionCall> for SwitchboardCalls {
        fn from(value: SetAttestationQueuePermissionCall) -> Self {
            Self::SetAttestationQueuePermission(value)
        }
    }
    impl ::core::convert::From<SetFunctionCallSettingsCall> for SwitchboardCalls {
        fn from(value: SetFunctionCallSettingsCall) -> Self {
            Self::SetFunctionCallSettings(value)
        }
    }
    impl ::core::convert::From<SetFunctionConfigCall> for SwitchboardCalls {
        fn from(value: SetFunctionConfigCall) -> Self {
            Self::SetFunctionConfig(value)
        }
    }
    impl ::core::convert::From<SetFunctionDeactivatedCall> for SwitchboardCalls {
        fn from(value: SetFunctionDeactivatedCall) -> Self {
            Self::SetFunctionDeactivated(value)
        }
    }
    impl ::core::convert::From<SetFunctionSettingsCall> for SwitchboardCalls {
        fn from(value: SetFunctionSettingsCall) -> Self {
            Self::SetFunctionSettings(value)
        }
    }
    impl ::core::convert::From<SetOracleConfigCall> for SwitchboardCalls {
        fn from(value: SetOracleConfigCall) -> Self {
            Self::SetOracleConfig(value)
        }
    }
    impl ::core::convert::From<SetOracleQueueAttestationConfigCall> for SwitchboardCalls {
        fn from(value: SetOracleQueueAttestationConfigCall) -> Self {
            Self::SetOracleQueueAttestationConfig(value)
        }
    }
    impl ::core::convert::From<SetOracleQueueConfigCall> for SwitchboardCalls {
        fn from(value: SetOracleQueueConfigCall) -> Self {
            Self::SetOracleQueueConfig(value)
        }
    }
    impl ::core::convert::From<SetOracleQueuePermissionCall> for SwitchboardCalls {
        fn from(value: SetOracleQueuePermissionCall) -> Self {
            Self::SetOracleQueuePermission(value)
        }
    }
    impl ::core::convert::From<SetStakingConfigCall> for SwitchboardCalls {
        fn from(value: SetStakingConfigCall) -> Self {
            Self::SetStakingConfig(value)
        }
    }
    impl ::core::convert::From<SetToleratedTimestampDiscrepancyCall> for SwitchboardCalls {
        fn from(value: SetToleratedTimestampDiscrepancyCall) -> Self {
            Self::SetToleratedTimestampDiscrepancy(value)
        }
    }
    impl ::core::convert::From<SlashStakeCall> for SwitchboardCalls {
        fn from(value: SlashStakeCall) -> Self {
            Self::SlashStake(value)
        }
    }
    impl ::core::convert::From<SupportsInterfaceCall> for SwitchboardCalls {
        fn from(value: SupportsInterfaceCall) -> Self {
            Self::SupportsInterface(value)
        }
    }
    impl ::core::convert::From<TotalStakedCall> for SwitchboardCalls {
        fn from(value: TotalStakedCall) -> Self {
            Self::TotalStaked(value)
        }
    }
    impl ::core::convert::From<TotalSupplyCall> for SwitchboardCalls {
        fn from(value: TotalSupplyCall) -> Self {
            Self::TotalSupply(value)
        }
    }
    impl ::core::convert::From<TransferCall> for SwitchboardCalls {
        fn from(value: TransferCall) -> Self {
            Self::Transfer(value)
        }
    }
    impl ::core::convert::From<TransferFromCall> for SwitchboardCalls {
        fn from(value: TransferFromCall) -> Self {
            Self::TransferFrom(value)
        }
    }
    impl ::core::convert::From<TransferOwnershipCall> for SwitchboardCalls {
        fn from(value: TransferOwnershipCall) -> Self {
            Self::TransferOwnership(value)
        }
    }
    impl ::core::convert::From<UnstakeCall> for SwitchboardCalls {
        fn from(value: UnstakeCall) -> Self {
            Self::Unstake(value)
        }
    }
    impl ::core::convert::From<UpdateEnclaveCall> for SwitchboardCalls {
        fn from(value: UpdateEnclaveCall) -> Self {
            Self::UpdateEnclave(value)
        }
    }
    impl ::core::convert::From<UpdateRoutineCall> for SwitchboardCalls {
        fn from(value: UpdateRoutineCall) -> Self {
            Self::UpdateRoutine(value)
        }
    }
    impl ::core::convert::From<ValidateCall> for SwitchboardCalls {
        fn from(value: ValidateCall) -> Self {
            Self::Validate(value)
        }
    }
    impl ::core::convert::From<VerifyCallbackParamsCall> for SwitchboardCalls {
        fn from(value: VerifyCallbackParamsCall) -> Self {
            Self::VerifyCallbackParams(value)
        }
    }
    impl ::core::convert::From<VerifyEnclaveCall> for SwitchboardCalls {
        fn from(value: VerifyEnclaveCall) -> Self {
            Self::VerifyEnclave(value)
        }
    }
    impl ::core::convert::From<VerifyFunctionResultCall> for SwitchboardCalls {
        fn from(value: VerifyFunctionResultCall) -> Self {
            Self::VerifyFunctionResult(value)
        }
    }
    impl ::core::convert::From<ViewAggregatorResultsCall> for SwitchboardCalls {
        fn from(value: ViewAggregatorResultsCall) -> Self {
            Self::ViewAggregatorResults(value)
        }
    }
    impl ::core::convert::From<ViewLatestResultCall> for SwitchboardCalls {
        fn from(value: ViewLatestResultCall) -> Self {
            Self::ViewLatestResult(value)
        }
    }
    ///Container type for all return fields from the `aggregatorHistory` function with signature `aggregatorHistory(address,uint80)` and selector `0x8625bd08`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AggregatorHistoryReturn(pub AggregatorHistoryResult);
    ///Container type for all return fields from the `aggregators` function with signature `aggregators(address)` and selector `0x112cdab9`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AggregatorsReturn(pub Aggregator);
    ///Container type for all return fields from the `allowance` function with signature `allowance(address,address)` and selector `0xdd62ed3e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AllowanceReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `approve` function with signature `approve(address,uint256)` and selector `0x095ea7b3`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct ApproveReturn(pub bool);
    ///Container type for all return fields from the `attestationQueueHasMrEnclave` function with signature `attestationQueueHasMrEnclave(address,bytes32)` and selector `0x63fcd771`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AttestationQueueHasMrEnclaveReturn(pub bool);
    ///Container type for all return fields from the `attestationQueues` function with signature `attestationQueues(address)` and selector `0x8bb3048c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AttestationQueuesReturn(pub AttestationQueue);
    ///Container type for all return fields from the `balanceOf` function with signature `balanceOf(address)` and selector `0x70a08231`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BalanceOfReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `callBalances` function with signature `callBalances(address[])` and selector `0x0aaeffe5`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct CallBalancesReturn {
        pub balances: ::std::vec::Vec<::ethers::core::types::U256>,
    }
    ///Container type for all return fields from the `callFunction` function with signature `callFunction(address,bytes)` and selector `0x9c23da50`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct CallFunctionReturn {
        pub call_id: ::ethers::core::types::Address,
    }
    ///Container type for all return fields from the `enclaveSignerToEnclaveId` function with signature `enclaveSignerToEnclaveId(address)` and selector `0x2ff75ec2`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct EnclaveSignerToEnclaveIdReturn(pub ::ethers::core::types::Address);
    ///Container type for all return fields from the `enclaves` function with signature `enclaves(address)` and selector `0xfaeedb07`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct EnclavesReturn(pub Enclave);
    ///Container type for all return fields from the `estimatedRunCost` function with signature `estimatedRunCost(address,uint256)` and selector `0x3da87438`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct EstimatedRunCostReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `facetAddress` function with signature `facetAddress(bytes4)` and selector `0xcdffacc6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FacetAddressReturn {
        pub facet_address: ::ethers::core::types::Address,
    }
    ///Container type for all return fields from the `facetAddresses` function with signature `facetAddresses()` and selector `0x52ef6b2c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FacetAddressesReturn {
        pub facet_addresses: ::std::vec::Vec<::ethers::core::types::Address>,
    }
    ///Container type for all return fields from the `facetFunctionSelectors` function with signature `facetFunctionSelectors(address)` and selector `0xadfca15e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FacetFunctionSelectorsReturn {
        pub facet_function_selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///Container type for all return fields from the `facets` function with signature `facets()` and selector `0x7a0ed627`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FacetsReturn {
        pub facets: ::std::vec::Vec<Facet>,
    }
    ///Container type for all return fields from the `funcs` function with signature `funcs(address)` and selector `0x8ef92003`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FuncsReturn(pub SbFunction);
    ///Container type for all return fields from the `functionCallSettings` function with signature `functionCallSettings(address)` and selector `0xa30f8d25`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionCallSettingsReturn(pub FunctionCallSettings);
    ///Container type for all return fields from the `functionCalls` function with signature `functionCalls(address)` and selector `0x826df326`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionCallsReturn(pub FunctionCall);
    ///Container type for all return fields from the `functionExists` function with signature `functionExists(address)` and selector `0xa13001c9`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionExistsReturn(pub bool);
    ///Container type for all return fields from the `functionSettings` function with signature `functionSettings(address)` and selector `0xce77efa6`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionSettingsReturn(pub FunctionSettings);
    ///Container type for all return fields from the `getActiveFunctionCallsByQueue` function with signature `getActiveFunctionCallsByQueue(address)` and selector `0xfa88c651`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetActiveFunctionCallsByQueueReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<FunctionCall>,
    );
    ///Container type for all return fields from the `getActiveFunctionsByQueue` function with signature `getActiveFunctionsByQueue(address)` and selector `0x1fc747b7`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetActiveFunctionsByQueueReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<SbFunction>,
    );
    ///Container type for all return fields from the `getActiveRequestsByQueue` function with signature `getActiveRequestsByQueue(address)` and selector `0x55c053c3`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetActiveRequestsByQueueReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<Request>,
    );
    ///Container type for all return fields from the `getActiveRoutinesByQueue` function with signature `getActiveRoutinesByQueue(address)` and selector `0x9da3c6eb`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetActiveRoutinesByQueueReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<Routine>,
    );
    ///Container type for all return fields from the `getAggregatorsByAuthority` function with signature `getAggregatorsByAuthority(address)` and selector `0x911c30f3`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetAggregatorsByAuthorityReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<Aggregator>,
    );
    ///Container type for all return fields from the `getAllAggregators` function with signature `getAllAggregators()` and selector `0x465c65dd`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetAllAggregatorsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<Aggregator>,
    );
    ///Container type for all return fields from the `getAllFunctions` function with signature `getAllFunctions()` and selector `0xab6418b4`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetAllFunctionsReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<SbFunction>,
    );
    ///Container type for all return fields from the `getAttestationQueueMrEnclaves` function with signature `getAttestationQueueMrEnclaves(address)` and selector `0x0f3bc418`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetAttestationQueueMrEnclavesReturn(pub ::std::vec::Vec<[u8; 32]>);
    ///Container type for all return fields from the `getCurrentIntervalId` function with signature `getCurrentIntervalId(address)` and selector `0x1dc1da86`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetCurrentIntervalIdReturn {
        pub round_id: u128,
    }
    ///Container type for all return fields from the `getEnclaveIdx` function with signature `getEnclaveIdx(address)` and selector `0x21fb3bbc`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetEnclaveIdxReturn(pub ::ethers::core::types::I256);
    ///Container type for all return fields from the `getEnclaves` function with signature `getEnclaves(address)` and selector `0x340dd88b`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetEnclavesReturn(pub ::std::vec::Vec<::ethers::core::types::Address>);
    ///Container type for all return fields from the `getFunctionMrEnclaves` function with signature `getFunctionMrEnclaves(address)` and selector `0x526112ce`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetFunctionMrEnclavesReturn(pub ::std::vec::Vec<[u8; 32]>);
    ///Container type for all return fields from the `getFunctionPermittedCallers` function with signature `getFunctionPermittedCallers(address)` and selector `0xafdcbd6a`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetFunctionPermittedCallersReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
    );
    ///Container type for all return fields from the `getFunctionsByAuthority` function with signature `getFunctionsByAuthority(address)` and selector `0x357f633f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetFunctionsByAuthorityReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<SbFunction>,
    );
    ///Container type for all return fields from the `getIntervalResult` function with signature `getIntervalResult(address,uint80)` and selector `0x3d24ef6e`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetIntervalResultReturn {
        pub value: ::ethers::core::types::I256,
        pub timestamp: ::ethers::core::types::U256,
        pub median_timestamp: ::ethers::core::types::U256,
    }
    ///Container type for all return fields from the `getOracleIdx` function with signature `getOracleIdx(address)` and selector `0xd87dd0ac`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetOracleIdxReturn(pub ::ethers::core::types::I256);
    ///Container type for all return fields from the `getOracleQueueAllowedMrEnclaves` function with signature `getOracleQueueAllowedMrEnclaves(address)` and selector `0xf04b0f59`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetOracleQueueAllowedMrEnclavesReturn(pub ::std::vec::Vec<[u8; 32]>);
    ///Container type for all return fields from the `getOracles` function with signature `getOracles(address)` and selector `0x8e749281`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetOraclesReturn(pub ::std::vec::Vec<::ethers::core::types::Address>);
    ///Container type for all return fields from the `getPermission` function with signature `getPermission(address,address)` and selector `0x910185dd`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetPermissionReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `getRequestsByFunctionId` function with signature `getRequestsByFunctionId(address)` and selector `0xb68e3ace`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetRequestsByFunctionIdReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<Request>,
    );
    ///Container type for all return fields from the `getRoutinesByAuthority` function with signature `getRoutinesByAuthority(address)` and selector `0xb36afb5a`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetRoutinesByAuthorityReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<Routine>,
    );
    ///Container type for all return fields from the `getRoutinesByFunctionId` function with signature `getRoutinesByFunctionId(address)` and selector `0x27c66c0f`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetRoutinesByFunctionIdReturn(
        pub ::std::vec::Vec<::ethers::core::types::Address>,
        pub ::std::vec::Vec<Routine>,
    );
    ///Container type for all return fields from the `getStakeForEnclave` function with signature `getStakeForEnclave(address)` and selector `0x376d9b41`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetStakeForEnclaveReturn(pub Stake);
    ///Container type for all return fields from the `getStakeForEnclaveWithToken` function with signature `getStakeForEnclaveWithToken(address,address)` and selector `0x3ff8f2af`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetStakeForEnclaveWithTokenReturn(pub Stake);
    ///Container type for all return fields from the `getStakingConfig` function with signature `getStakingConfig(address)` and selector `0x5133a68c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetStakingConfigReturn(pub StakingConfig);
    ///Container type for all return fields from the `getTransactionHash` function with signature `getTransactionHash(uint256,uint256,uint256,address,address,bytes)` and selector `0xd93f1970`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct GetTransactionHashReturn(pub [u8; 32]);
    ///Container type for all return fields from the `hasPermission` function with signature `hasPermission(address,address,uint256)` and selector `0x8b01813d`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct HasPermissionReturn(pub bool);
    ///Container type for all return fields from the `isAdmin` function with signature `isAdmin(address)` and selector `0x24d7806c`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct IsAdminReturn(pub bool);
    ///Container type for all return fields from the `isAllowed` function with signature `isAllowed(address)` and selector `0xbabcc539`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct IsAllowedReturn(pub bool);
    ///Container type for all return fields from the `isEnclaveValid` function with signature `isEnclaveValid(address)` and selector `0xfb4acdfe`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct IsEnclaveValidReturn(pub bool);
    ///Container type for all return fields from the `isTrustedForwarder` function with signature `isTrustedForwarder(address)` and selector `0x572b6c05`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct IsTrustedForwarderReturn(pub bool);
    ///Container type for all return fields from the `latestResult` function with signature `latestResult(address)` and selector `0xfab005a2`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct LatestResultReturn {
        pub value: ::ethers::core::types::I256,
        pub timestamp: ::ethers::core::types::U256,
    }
    ///Container type for all return fields from the `oracleQueues` function with signature `oracleQueues(address)` and selector `0xf2378e88`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct OracleQueuesReturn(pub OracleQueue);
    ///Container type for all return fields from the `oracles` function with signature `oracles(address)` and selector `0xaddd5099`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct OraclesReturn(pub Oracle);
    ///Container type for all return fields from the `owner` function with signature `owner()` and selector `0x8da5cb5b`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct OwnerReturn {
        pub owner: ::ethers::core::types::Address,
    }
    ///Container type for all return fields from the `queueAttestationConfigs` function with signature `queueAttestationConfigs(address)` and selector `0x6ddc9122`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct QueueAttestationConfigsReturn(pub AttestationConfig);
    ///Container type for all return fields from the `requests` function with signature `requests(address)` and selector `0x74adad1d`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct RequestsReturn(pub Request);
    ///Container type for all return fields from the `routineExists` function with signature `routineExists(address)` and selector `0xc98d9be8`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct RoutineExistsReturn(pub bool);
    ///Container type for all return fields from the `routines` function with signature `routines(address)` and selector `0xfdcc54d2`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct RoutinesReturn(pub Routine);
    ///Container type for all return fields from the `sendRequest` function with signature `sendRequest(address,bytes)` and selector `0x62d3fe46`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct SendRequestReturn {
        pub id: ::ethers::core::types::Address,
    }
    ///Container type for all return fields from the `sendRequestWithId` function with signature `sendRequestWithId(address,address,bytes)` and selector `0x264c1450`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct SendRequestWithIdReturn {
        pub id: ::ethers::core::types::Address,
    }
    ///Container type for all return fields from the `supportsInterface` function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct SupportsInterfaceReturn(pub bool);
    ///Container type for all return fields from the `totalStaked` function with signature `totalStaked(address,address)` and selector `0xf21630cb`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct TotalStakedReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `totalSupply` function with signature `totalSupply()` and selector `0x18160ddd`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct TotalSupplyReturn(pub ::ethers::core::types::U256);
    ///Container type for all return fields from the `transfer` function with signature `transfer(address,uint256)` and selector `0xa9059cbb`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct TransferReturn(pub bool);
    ///Container type for all return fields from the `transferFrom` function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct TransferFromReturn(pub bool);
    ///Container type for all return fields from the `viewAggregatorResults` function with signature `viewAggregatorResults(address)` and selector `0xde866484`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct ViewAggregatorResultsReturn(pub ::std::vec::Vec<Result>);
    ///Container type for all return fields from the `viewLatestResult` function with signature `viewLatestResult(address)` and selector `0xbdf5edef`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct ViewLatestResultReturn {
        pub value: ::ethers::core::types::I256,
        pub timestamp: ::ethers::core::types::U256,
    }
    ///`Aggregator(string,address,(int256,uint256,address),(uint256,uint256,uint256,uint256,uint256,uint256),string,address,uint256,uint256,uint80,uint256,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Aggregator {
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub latest_result: Result,
        pub config: AggregatorConfig,
        pub jobs_hash: ::std::string::String,
        pub queue_id: ::ethers::core::types::Address,
        pub balance_left_for_interval: ::ethers::core::types::U256,
        pub next_interval_refresh_time: ::ethers::core::types::U256,
        pub interval_id: u128,
        pub balance: ::ethers::core::types::U256,
        pub history_enabled: bool,
    }
    ///`AggregatorConfig(uint256,uint256,uint256,uint256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AggregatorConfig {
        pub batch_size: ::ethers::core::types::U256,
        pub min_update_delay_seconds: ::ethers::core::types::U256,
        pub min_oracle_results: ::ethers::core::types::U256,
        pub variance_threshold: ::ethers::core::types::U256,
        pub min_job_results: ::ethers::core::types::U256,
        pub force_report_period: ::ethers::core::types::U256,
    }
    ///`AggregatorHistoryResult(int256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AggregatorHistoryResult {
        pub value: ::ethers::core::types::I256,
        pub timestamp: ::ethers::core::types::U256,
        pub median_timestamp: ::ethers::core::types::U256,
    }
    ///`Result(int256,uint256,address)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Result {
        pub value: ::ethers::core::types::I256,
        pub timestamp: ::ethers::core::types::U256,
        pub oracle_id: ::ethers::core::types::Address,
    }
    ///`AttestationQueue(address,address[],uint256,uint256,uint256,bytes32[],uint256,uint256,uint256,bool,bool,uint256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AttestationQueue {
        pub authority: ::ethers::core::types::Address,
        pub data: ::std::vec::Vec<::ethers::core::types::Address>,
        pub max_size: ::ethers::core::types::U256,
        pub reward: ::ethers::core::types::U256,
        pub last_heartbeat: ::ethers::core::types::U256,
        pub mr_enclaves: ::std::vec::Vec<[u8; 32]>,
        pub max_enclave_verification_age: ::ethers::core::types::U256,
        pub allow_authority_override_after: ::ethers::core::types::U256,
        pub max_consecutive_function_failures: ::ethers::core::types::U256,
        pub require_authority_heartbeat_permission: bool,
        pub require_usage_permissions: bool,
        pub enclave_timeout: ::ethers::core::types::U256,
        pub gc_idx: ::ethers::core::types::U256,
        pub curr_idx: ::ethers::core::types::U256,
    }
    ///`Enclave(address,address,address,bytes,uint8,uint256,uint256,bytes32,bool,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Enclave {
        pub signer: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub cid: ::ethers::core::types::Bytes,
        pub verification_status: u8,
        pub verification_timestamp: ::ethers::core::types::U256,
        pub valid_until: ::ethers::core::types::U256,
        pub mr_enclave: [u8; 32],
        pub is_on_queue: bool,
        pub last_heartbeat: ::ethers::core::types::U256,
        pub balance: ::ethers::core::types::U256,
    }
    ///`FunctionCall(address,address,uint256,bytes,bool,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionCall {
        pub function_id: ::ethers::core::types::Address,
        pub caller: ::ethers::core::types::Address,
        pub timestamp: ::ethers::core::types::U256,
        pub call_data: ::ethers::core::types::Bytes,
        pub executed: bool,
        pub consecutive_failures: ::ethers::core::types::U256,
        pub fee_paid: ::ethers::core::types::U256,
    }
    ///`FunctionCallSettings(bool,uint256,uint256,bool,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionCallSettings {
        pub require_estimated_run_cost_fee: bool,
        pub minimum_fee: ::ethers::core::types::U256,
        pub max_gas_cost: ::ethers::core::types::U256,
        pub require_caller_pay_full_cost: bool,
        pub require_sender_be_return_address: bool,
    }
    ///`FunctionConfig(string,address[],string,string,string,string,bytes32[],bool,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionConfig {
        pub schedule: ::std::string::String,
        pub permitted_callers: ::std::vec::Vec<::ethers::core::types::Address>,
        pub container_registry: ::std::string::String,
        pub container: ::std::string::String,
        pub version: ::std::string::String,
        pub params_schema: ::std::string::String,
        pub mr_enclaves: ::std::vec::Vec<[u8; 32]>,
        pub allow_all_fn_calls: bool,
        pub use_fn_call_escrow: bool,
    }
    ///`FunctionState(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionState {
        pub consecutive_failures: ::ethers::core::types::U256,
        pub last_execution_timestamp: ::ethers::core::types::U256,
        pub next_allowed_timestamp: ::ethers::core::types::U256,
        pub last_execution_gas_cost: ::ethers::core::types::U256,
        pub triggered_since: ::ethers::core::types::U256,
        pub trigger_count: ::ethers::core::types::U256,
        pub queue_idx: ::ethers::core::types::U256,
        pub triggered: bool,
        pub created_at: ::ethers::core::types::U256,
    }
    ///`SbFunction(string,address,address,address,uint256,uint8,(string,address[],string,string,string,string,bytes32[],bool,bool),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool,uint256))`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct SbFunction {
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub enclave_id: ::ethers::core::types::Address,
        pub queue_id: ::ethers::core::types::Address,
        pub balance: ::ethers::core::types::U256,
        pub status: u8,
        pub config: FunctionConfig,
        pub state: FunctionState,
    }
    ///`FunctionSettings(uint256,bool,bool,bool,uint256,bool,uint256,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionSettings {
        pub max_gas_cost: ::ethers::core::types::U256,
        pub require_isolated_runs: bool,
        pub routines_disabled: bool,
        pub routines_require_authorization: bool,
        pub routine_fee: ::ethers::core::types::U256,
        pub requests_disabled: bool,
        pub request_fee: ::ethers::core::types::U256,
        pub requests_require_authorization: bool,
    }
    ///`FunctionFailParams(uint256,address,uint256,uint256,uint8,address[],bytes32[],uint8[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionFailParams {
        pub enclave_idx: ::ethers::core::types::U256,
        pub function_id: ::ethers::core::types::Address,
        pub observed_time: ::ethers::core::types::U256,
        pub next_allowed_timestamp: ::ethers::core::types::U256,
        pub code: u8,
        pub ids: ::std::vec::Vec<::ethers::core::types::Address>,
        pub checksums: ::std::vec::Vec<[u8; 32]>,
        pub codes: ::std::vec::Vec<u8>,
    }
    ///`FunctionVerifyParams(uint256,address,address,uint256,uint256,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[],address[],bytes32[],uint8[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FunctionVerifyParams {
        pub enclave_idx: ::ethers::core::types::U256,
        pub function_id: ::ethers::core::types::Address,
        pub delegated_signer_address: ::ethers::core::types::Address,
        pub observed_time: ::ethers::core::types::U256,
        pub next_allowed_timestamp: ::ethers::core::types::U256,
        pub mr_enclave: [u8; 32],
        pub transactions: ::std::vec::Vec<Transaction>,
        pub signatures: ::std::vec::Vec<::ethers::core::types::Bytes>,
        pub ids: ::std::vec::Vec<::ethers::core::types::Address>,
        pub checksums: ::std::vec::Vec<[u8; 32]>,
        pub codes: ::std::vec::Vec<u8>,
    }
    ///`FacetCut(address,uint8,bytes4[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct FacetCut {
        pub facet_address: ::ethers::core::types::Address,
        pub action: u8,
        pub function_selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///`Facet(address,bytes4[])`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Facet {
        pub facet_address: ::ethers::core::types::Address,
        pub function_selectors: ::std::vec::Vec<[u8; 4]>,
    }
    ///`Oracle(string,address,uint8,uint256,address,address)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Oracle {
        pub name: ::std::string::String,
        pub signer: ::ethers::core::types::Address,
        pub num_rows: u8,
        pub last_heartbeat: ::ethers::core::types::U256,
        pub queue_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
    }
    ///`AttestationConfig(address,bytes32[],bool,bool)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct AttestationConfig {
        pub attestation_queue_id: ::ethers::core::types::Address,
        pub mr_enclaves: ::std::vec::Vec<[u8; 32]>,
        pub require_valid_enclave: bool,
        pub require_heartbeat_permission: bool,
    }
    ///`OracleQueue(string,address,address[],bool,uint256,uint256,uint256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct OracleQueue {
        pub name: ::std::string::String,
        pub authority: ::ethers::core::types::Address,
        pub oracles: ::std::vec::Vec<::ethers::core::types::Address>,
        pub unpermissioned_feeds_enabled: bool,
        pub max_size: ::ethers::core::types::U256,
        pub reward: ::ethers::core::types::U256,
        pub oracle_timeout: ::ethers::core::types::U256,
        pub gc_idx: ::ethers::core::types::U256,
        pub curr_idx: ::ethers::core::types::U256,
    }
    ///`Request(address,address,uint256,bytes,bool,uint256,uint256,uint256,uint8,uint256,uint8)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Request {
        pub function_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
        pub created_at: ::ethers::core::types::U256,
        pub request_data: ::ethers::core::types::Bytes,
        pub executed: bool,
        pub consecutive_failures: ::ethers::core::types::U256,
        pub balance: ::ethers::core::types::U256,
        pub start_after: ::ethers::core::types::U256,
        pub error_code: u8,
        pub executed_at: ::ethers::core::types::U256,
        pub status: u8,
    }
    ///`Routine(address,address,string,bytes,uint256,uint256,uint256,uint8,uint8)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Routine {
        pub function_id: ::ethers::core::types::Address,
        pub authority: ::ethers::core::types::Address,
        pub schedule: ::std::string::String,
        pub params: ::ethers::core::types::Bytes,
        pub last_called_at: ::ethers::core::types::U256,
        pub consecutive_failures: ::ethers::core::types::U256,
        pub balance: ::ethers::core::types::U256,
        pub status: u8,
        pub error_code: u8,
    }
    ///`Stake(uint256,uint256,uint256,uint256,address)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Stake {
        pub amount: ::ethers::core::types::U256,
        pub ready_at: ::ethers::core::types::U256,
        pub unstake_ready_at: ::ethers::core::types::U256,
        pub last_updated: ::ethers::core::types::U256,
        pub token: ::ethers::core::types::Address,
    }
    ///`StakingConfig(address,uint256,uint256,uint256)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct StakingConfig {
        pub token: ::ethers::core::types::Address,
        pub staking_amount: ::ethers::core::types::U256,
        pub staking_period: ::ethers::core::types::U256,
        pub unstaking_period: ::ethers::core::types::U256,
    }
    ///`Transaction(uint256,uint256,uint256,address,address,bytes)`
    #[derive(
        Clone,
        ::ethers::contract::EthAbiType,
        ::ethers::contract::EthAbiCodec,
        Default,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Transaction {
        pub expiration_time_seconds: ::ethers::core::types::U256,
        pub gas_limit: ::ethers::core::types::U256,
        pub value: ::ethers::core::types::U256,
        pub to: ::ethers::core::types::Address,
        pub from: ::ethers::core::types::Address,
        pub data: ::ethers::core::types::Bytes,
    }
}
