/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace AggregatorLib {
  export type AggregatorHistoryResultStruct = {
    value: PromiseOrValue<BigNumberish>;
    timestamp: PromiseOrValue<BigNumberish>;
    medianTimestamp: PromiseOrValue<BigNumberish>;
  };

  export type AggregatorHistoryResultStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber
  ] & { value: BigNumber; timestamp: BigNumber; medianTimestamp: BigNumber };

  export type ResultStruct = {
    value: PromiseOrValue<BigNumberish>;
    timestamp: PromiseOrValue<BigNumberish>;
    oracleId: PromiseOrValue<string>;
  };

  export type ResultStructOutput = [BigNumber, BigNumber, string] & {
    value: BigNumber;
    timestamp: BigNumber;
    oracleId: string;
  };

  export type AggregatorConfigStruct = {
    batchSize: PromiseOrValue<BigNumberish>;
    minUpdateDelaySeconds: PromiseOrValue<BigNumberish>;
    minOracleResults: PromiseOrValue<BigNumberish>;
    varianceThreshold: PromiseOrValue<BigNumberish>;
    minJobResults: PromiseOrValue<BigNumberish>;
    forceReportPeriod: PromiseOrValue<BigNumberish>;
  };

  export type AggregatorConfigStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    batchSize: BigNumber;
    minUpdateDelaySeconds: BigNumber;
    minOracleResults: BigNumber;
    varianceThreshold: BigNumber;
    minJobResults: BigNumber;
    forceReportPeriod: BigNumber;
  };

  export type AggregatorStruct = {
    name: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    latestResult: AggregatorLib.ResultStruct;
    config: AggregatorLib.AggregatorConfigStruct;
    jobsHash: PromiseOrValue<string>;
    queueId: PromiseOrValue<string>;
    balanceLeftForInterval: PromiseOrValue<BigNumberish>;
    nextIntervalRefreshTime: PromiseOrValue<BigNumberish>;
    intervalId: PromiseOrValue<BigNumberish>;
    balance: PromiseOrValue<BigNumberish>;
    historyEnabled: PromiseOrValue<boolean>;
  };

  export type AggregatorStructOutput = [
    string,
    string,
    AggregatorLib.ResultStructOutput,
    AggregatorLib.AggregatorConfigStructOutput,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    name: string;
    authority: string;
    latestResult: AggregatorLib.ResultStructOutput;
    config: AggregatorLib.AggregatorConfigStructOutput;
    jobsHash: string;
    queueId: string;
    balanceLeftForInterval: BigNumber;
    nextIntervalRefreshTime: BigNumber;
    intervalId: BigNumber;
    balance: BigNumber;
    historyEnabled: boolean;
  };
}

export declare namespace AttestationQueueLib {
  export type AttestationQueueStruct = {
    authority: PromiseOrValue<string>;
    data: PromiseOrValue<string>[];
    maxSize: PromiseOrValue<BigNumberish>;
    reward: PromiseOrValue<BigNumberish>;
    lastHeartbeat: PromiseOrValue<BigNumberish>;
    mrEnclaves: PromiseOrValue<BytesLike>[];
    maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>;
    allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>;
    maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>;
    requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>;
    requireUsagePermissions: PromiseOrValue<boolean>;
    enclaveTimeout: PromiseOrValue<BigNumberish>;
    gcIdx: PromiseOrValue<BigNumberish>;
    currIdx: PromiseOrValue<BigNumberish>;
  };

  export type AttestationQueueStructOutput = [
    string,
    string[],
    BigNumber,
    BigNumber,
    BigNumber,
    string[],
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    authority: string;
    data: string[];
    maxSize: BigNumber;
    reward: BigNumber;
    lastHeartbeat: BigNumber;
    mrEnclaves: string[];
    maxEnclaveVerificationAge: BigNumber;
    allowAuthorityOverrideAfter: BigNumber;
    maxConsecutiveFunctionFailures: BigNumber;
    requireAuthorityHeartbeatPermission: boolean;
    requireUsagePermissions: boolean;
    enclaveTimeout: BigNumber;
    gcIdx: BigNumber;
    currIdx: BigNumber;
  };
}

export declare namespace IDiamondCut {
  export type FacetCutStruct = {
    facetAddress: PromiseOrValue<string>;
    action: PromiseOrValue<BigNumberish>;
    functionSelectors: PromiseOrValue<BytesLike>[];
  };

  export type FacetCutStructOutput = [string, number, string[]] & {
    facetAddress: string;
    action: number;
    functionSelectors: string[];
  };
}

export declare namespace IDiamondLoupe {
  export type FacetStruct = {
    facetAddress: PromiseOrValue<string>;
    functionSelectors: PromiseOrValue<BytesLike>[];
  };

  export type FacetStructOutput = [string, string[]] & {
    facetAddress: string;
    functionSelectors: string[];
  };
}

export declare namespace EnclaveLib {
  export type EnclaveStruct = {
    authority: PromiseOrValue<string>;
    owner: PromiseOrValue<string>;
    queueId: PromiseOrValue<string>;
    cid: PromiseOrValue<BytesLike>;
    verificationStatus: PromiseOrValue<BigNumberish>;
    verificationTimestamp: PromiseOrValue<BigNumberish>;
    validUntil: PromiseOrValue<BigNumberish>;
    mrEnclave: PromiseOrValue<BytesLike>;
    isOnQueue: PromiseOrValue<boolean>;
    lastHeartbeat: PromiseOrValue<BigNumberish>;
    balance: PromiseOrValue<BigNumberish>;
  };

  export type EnclaveStructOutput = [
    string,
    string,
    string,
    string,
    number,
    BigNumber,
    BigNumber,
    string,
    boolean,
    BigNumber,
    BigNumber
  ] & {
    authority: string;
    owner: string;
    queueId: string;
    cid: string;
    verificationStatus: number;
    verificationTimestamp: BigNumber;
    validUntil: BigNumber;
    mrEnclave: string;
    isOnQueue: boolean;
    lastHeartbeat: BigNumber;
    balance: BigNumber;
  };
}

export declare namespace OracleLib {
  export type OracleStruct = {
    name: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    numRows: PromiseOrValue<BigNumberish>;
    lastHeartbeat: PromiseOrValue<BigNumberish>;
    queueId: PromiseOrValue<string>;
    owner: PromiseOrValue<string>;
  };

  export type OracleStructOutput = [
    string,
    string,
    number,
    BigNumber,
    string,
    string
  ] & {
    name: string;
    authority: string;
    numRows: number;
    lastHeartbeat: BigNumber;
    queueId: string;
    owner: string;
  };
}

export declare namespace OracleQueueLib {
  export type OracleQueueStruct = {
    name: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    oracles: PromiseOrValue<string>[];
    unpermissionedFeedsEnabled: PromiseOrValue<boolean>;
    maxSize: PromiseOrValue<BigNumberish>;
    reward: PromiseOrValue<BigNumberish>;
    oracleTimeout: PromiseOrValue<BigNumberish>;
    gcIdx: PromiseOrValue<BigNumberish>;
    currIdx: PromiseOrValue<BigNumberish>;
  };

  export type OracleQueueStructOutput = [
    string,
    string,
    string[],
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    name: string;
    authority: string;
    oracles: string[];
    unpermissionedFeedsEnabled: boolean;
    maxSize: BigNumber;
    reward: BigNumber;
    oracleTimeout: BigNumber;
    gcIdx: BigNumber;
    currIdx: BigNumber;
  };

  export type AttestationConfigStruct = {
    attestationQueueId: PromiseOrValue<string>;
    mrEnclaves: PromiseOrValue<BytesLike>[];
    requireValidEnclave: PromiseOrValue<boolean>;
    requireHeartbeatPermission: PromiseOrValue<boolean>;
  };

  export type AttestationConfigStructOutput = [
    string,
    string[],
    boolean,
    boolean
  ] & {
    attestationQueueId: string;
    mrEnclaves: string[];
    requireValidEnclave: boolean;
    requireHeartbeatPermission: boolean;
  };
}

export declare namespace TransactionLib {
  export type TransactionStruct = {
    expirationTimeSeconds: PromiseOrValue<BigNumberish>;
    gasLimit: PromiseOrValue<BigNumberish>;
    value: PromiseOrValue<BigNumberish>;
    to: PromiseOrValue<string>;
    from: PromiseOrValue<string>;
    data: PromiseOrValue<BytesLike>;
  };

  export type TransactionStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    string
  ] & {
    expirationTimeSeconds: BigNumber;
    gasLimit: BigNumber;
    value: BigNumber;
    to: string;
    from: string;
    data: string;
  };
}

export declare namespace FunctionLib {
  export type FunctionConfigStruct = {
    schedule: PromiseOrValue<string>;
    permittedCallers: PromiseOrValue<string>[];
    containerRegistry: PromiseOrValue<string>;
    container: PromiseOrValue<string>;
    version: PromiseOrValue<BytesLike>;
    paramsSchema: PromiseOrValue<string>;
  };

  export type FunctionConfigStructOutput = [
    string,
    string[],
    string,
    string,
    string,
    string
  ] & {
    schedule: string;
    permittedCallers: string[];
    containerRegistry: string;
    container: string;
    version: string;
    paramsSchema: string;
  };

  export type FunctionStateStruct = {
    consecutiveFailures: PromiseOrValue<BigNumberish>;
    lastExecutionTimestamp: PromiseOrValue<BigNumberish>;
    nextAllowedTimestamp: PromiseOrValue<BigNumberish>;
    callId: PromiseOrValue<BigNumberish>;
    triggeredSince: PromiseOrValue<BigNumberish>;
    triggerCount: PromiseOrValue<BigNumberish>;
    queueIdx: PromiseOrValue<BigNumberish>;
    triggered: PromiseOrValue<boolean>;
  };

  export type FunctionStateStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    consecutiveFailures: BigNumber;
    lastExecutionTimestamp: BigNumber;
    nextAllowedTimestamp: BigNumber;
    callId: BigNumber;
    triggeredSince: BigNumber;
    triggerCount: BigNumber;
    queueIdx: BigNumber;
    triggered: boolean;
  };

  export type SbFunctionStruct = {
    name: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    enclaveId: PromiseOrValue<string>;
    queueId: PromiseOrValue<string>;
    balance: PromiseOrValue<BigNumberish>;
    status: PromiseOrValue<BigNumberish>;
    config: FunctionLib.FunctionConfigStruct;
    state: FunctionLib.FunctionStateStruct;
  };

  export type SbFunctionStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    number,
    FunctionLib.FunctionConfigStructOutput,
    FunctionLib.FunctionStateStructOutput
  ] & {
    name: string;
    authority: string;
    enclaveId: string;
    queueId: string;
    balance: BigNumber;
    status: number;
    config: FunctionLib.FunctionConfigStructOutput;
    state: FunctionLib.FunctionStateStructOutput;
  };

  export type FunctionCallStruct = {
    caller: PromiseOrValue<string>;
    timestamp: PromiseOrValue<BigNumberish>;
    callData: PromiseOrValue<BytesLike>;
    executed: PromiseOrValue<boolean>;
  };

  export type FunctionCallStructOutput = [
    string,
    BigNumber,
    string,
    boolean
  ] & {
    caller: string;
    timestamp: BigNumber;
    callData: string;
    executed: boolean;
  };
}

export interface SwitchboardInterface extends utils.Interface {
  functions: {
    "aggregatorEscrowFund(address)": FunctionFragment;
    "aggregatorEscrowWithdraw(address,address,uint256)": FunctionFragment;
    "aggregatorHistory(address,uint80)": FunctionFragment;
    "aggregators(address)": FunctionFragment;
    "createAggregator(string,address,uint256,uint256,uint256,string,address,uint256,uint256,uint256,bool)": FunctionFragment;
    "getAggregatorsByAuthority(address)": FunctionFragment;
    "getAllAggregators()": FunctionFragment;
    "getCurrentIntervalId(address)": FunctionFragment;
    "getIntervalResult(address,uint80)": FunctionFragment;
    "latestResult(address)": FunctionFragment;
    "openInterval(address)": FunctionFragment;
    "saveResults(address[],int256[],address,uint256)": FunctionFragment;
    "setAggregatorConfig(address,string,address,uint256,uint256,uint256,string,address,uint256,uint256,uint256,bool)": FunctionFragment;
    "viewAggregatorResults(address)": FunctionFragment;
    "viewLatestResult(address)": FunctionFragment;
    "addMrEnclaveToAttestationQueue(address,bytes32)": FunctionFragment;
    "attestationQueueHasMrEnclave(address,bytes32)": FunctionFragment;
    "attestationQueues(address)": FunctionFragment;
    "createAttestationQueue(address,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256)": FunctionFragment;
    "getAttestationQueueMrEnclaves(address)": FunctionFragment;
    "getEnclaveIdx(address)": FunctionFragment;
    "getEnclaves(address)": FunctionFragment;
    "removeMrEnclaveFromAttestationQueue(address,bytes32)": FunctionFragment;
    "setAttestationQueueConfig(address,address,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256)": FunctionFragment;
    "setAttestationQueuePermission(address,address,uint256,bool)": FunctionFragment;
    "diamondCut((address,uint8,bytes4[])[],address,bytes)": FunctionFragment;
    "facetAddress(bytes4)": FunctionFragment;
    "facetAddresses()": FunctionFragment;
    "facetFunctionSelectors(address)": FunctionFragment;
    "facets()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "owner()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "init()": FunctionFragment;
    "createEnclave(address,address,address)": FunctionFragment;
    "createEnclaveWithId(address,address,address,address)": FunctionFragment;
    "enclaveAuthorityToEnclaveAddress(address)": FunctionFragment;
    "enclaveGarbageCollect(address,uint256)": FunctionFragment;
    "enclaveHeartbeat(address)": FunctionFragment;
    "enclaves(address)": FunctionFragment;
    "failEnclave(address,address,uint256)": FunctionFragment;
    "forceOverrideVerify(address)": FunctionFragment;
    "isEnclaveValid(address)": FunctionFragment;
    "rotateEnclaveAuthority(address,address)": FunctionFragment;
    "updateEnclave(address,bytes)": FunctionFragment;
    "validate(address,address,bytes32[])": FunctionFragment;
    "verifyEnclave(address,address,uint256,uint256,bytes32)": FunctionFragment;
    "createOracle(string,address,address,address)": FunctionFragment;
    "createOracleWithId(address,string,address,address,address)": FunctionFragment;
    "oracleGarbageCollect(address,uint256)": FunctionFragment;
    "oracleHeartbeat(address)": FunctionFragment;
    "oracles(address)": FunctionFragment;
    "rotateOracleAuthority(address,address)": FunctionFragment;
    "setOracleConfig(address,string,address,address,address)": FunctionFragment;
    "addMrEnclaveToOracleQueue(address,bytes32)": FunctionFragment;
    "createOracleQueue(string,address,bool,uint256,uint256,uint256)": FunctionFragment;
    "getOracleIdx(address)": FunctionFragment;
    "getOracleQueueAllowedMrEnclaves(address)": FunctionFragment;
    "getOracles(address)": FunctionFragment;
    "oracleQueues(address)": FunctionFragment;
    "queueAttestationConfigs(address)": FunctionFragment;
    "removeMrEnclaveFromOracleQueue(address,bytes32)": FunctionFragment;
    "setOracleQueueAttestationConfig(address,address,bytes32[],bool,bool)": FunctionFragment;
    "setOracleQueueConfig(address,string,address,bool,uint256,uint256,uint256)": FunctionFragment;
    "setOracleQueuePermission(address,address,uint256,bool)": FunctionFragment;
    "getPermission(address,address)": FunctionFragment;
    "hasPermission(address,address,uint256)": FunctionFragment;
    "callFunction(address,bytes)": FunctionFragment;
    "createFunction(string,address,address,string,string,bytes32,string,string,address[])": FunctionFragment;
    "forward((uint256,uint256,uint256,address,address,bytes)[],bytes[])": FunctionFragment;
    "funcs(address)": FunctionFragment;
    "functionEscrowFund(address)": FunctionFragment;
    "functionEscrowWithdraw(address,address,uint256)": FunctionFragment;
    "functionExists(address)": FunctionFragment;
    "getActiveFunctionsByQueue(address)": FunctionFragment;
    "getAllFunctions()": FunctionFragment;
    "getAllUnexecutedFunctionCalls(address)": FunctionFragment;
    "getFunctionsByAuthority(address)": FunctionFragment;
    "getTransactionHash(uint256,uint256,uint256,address,address,bytes)": FunctionFragment;
    "isTrustedForwarder(address)": FunctionFragment;
    "setFunctionConfig(address,string,address,string,string,bytes32,string,string,address[])": FunctionFragment;
    "verifyFunction(uint256,address,address,uint256,uint256,bool,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "aggregatorEscrowFund"
      | "aggregatorEscrowWithdraw"
      | "aggregatorHistory"
      | "aggregators"
      | "createAggregator"
      | "getAggregatorsByAuthority"
      | "getAllAggregators"
      | "getCurrentIntervalId"
      | "getIntervalResult"
      | "latestResult"
      | "openInterval"
      | "saveResults"
      | "setAggregatorConfig"
      | "viewAggregatorResults"
      | "viewLatestResult"
      | "addMrEnclaveToAttestationQueue"
      | "attestationQueueHasMrEnclave"
      | "attestationQueues"
      | "createAttestationQueue"
      | "getAttestationQueueMrEnclaves"
      | "getEnclaveIdx"
      | "getEnclaves"
      | "removeMrEnclaveFromAttestationQueue"
      | "setAttestationQueueConfig"
      | "setAttestationQueuePermission"
      | "diamondCut"
      | "facetAddress"
      | "facetAddresses"
      | "facetFunctionSelectors"
      | "facets"
      | "supportsInterface"
      | "owner"
      | "transferOwnership"
      | "init"
      | "createEnclave"
      | "createEnclaveWithId"
      | "enclaveAuthorityToEnclaveAddress"
      | "enclaveGarbageCollect"
      | "enclaveHeartbeat"
      | "enclaves"
      | "failEnclave"
      | "forceOverrideVerify"
      | "isEnclaveValid"
      | "rotateEnclaveAuthority"
      | "updateEnclave"
      | "validate"
      | "verifyEnclave"
      | "createOracle"
      | "createOracleWithId"
      | "oracleGarbageCollect"
      | "oracleHeartbeat"
      | "oracles"
      | "rotateOracleAuthority"
      | "setOracleConfig"
      | "addMrEnclaveToOracleQueue"
      | "createOracleQueue"
      | "getOracleIdx"
      | "getOracleQueueAllowedMrEnclaves"
      | "getOracles"
      | "oracleQueues"
      | "queueAttestationConfigs"
      | "removeMrEnclaveFromOracleQueue"
      | "setOracleQueueAttestationConfig"
      | "setOracleQueueConfig"
      | "setOracleQueuePermission"
      | "getPermission"
      | "hasPermission"
      | "callFunction"
      | "createFunction"
      | "forward"
      | "funcs"
      | "functionEscrowFund"
      | "functionEscrowWithdraw"
      | "functionExists"
      | "getActiveFunctionsByQueue"
      | "getAllFunctions"
      | "getAllUnexecutedFunctionCalls"
      | "getFunctionsByAuthority"
      | "getTransactionHash"
      | "isTrustedForwarder"
      | "setFunctionConfig"
      | "verifyFunction"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "aggregatorEscrowFund",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "aggregatorEscrowWithdraw",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "aggregatorHistory",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "aggregators",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createAggregator",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAggregatorsByAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllAggregators",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentIntervalId",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getIntervalResult",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "latestResult",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "openInterval",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "saveResults",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setAggregatorConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "viewAggregatorResults",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "viewLatestResult",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addMrEnclaveToAttestationQueue",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "attestationQueueHasMrEnclave",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "attestationQueues",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createAttestationQueue",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAttestationQueueMrEnclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getEnclaveIdx",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getEnclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMrEnclaveFromAttestationQueue",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setAttestationQueueConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setAttestationQueuePermission",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "diamondCut",
    values: [
      IDiamondCut.FacetCutStruct[],
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "facetAddress",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "facetAddresses",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "facetFunctionSelectors",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "facets", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "init", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "createEnclave",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createEnclaveWithId",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "enclaveAuthorityToEnclaveAddress",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "enclaveGarbageCollect",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "enclaveHeartbeat",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "enclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "failEnclave",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceOverrideVerify",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isEnclaveValid",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "rotateEnclaveAuthority",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateEnclave",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "validate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyEnclave",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createOracle",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createOracleWithId",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "oracleGarbageCollect",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "oracleHeartbeat",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "oracles",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "rotateOracleAuthority",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addMrEnclaveToOracleQueue",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "createOracleQueue",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getOracleIdx",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOracleQueueAllowedMrEnclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOracles",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "oracleQueues",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "queueAttestationConfigs",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMrEnclaveFromOracleQueue",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleQueueAttestationConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleQueueConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleQueuePermission",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getPermission",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasPermission",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "callFunction",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "createFunction",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forward",
    values: [TransactionLib.TransactionStruct[], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "funcs",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "functionEscrowFund",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "functionEscrowWithdraw",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "functionExists",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveFunctionsByQueue",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllFunctions",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAllUnexecutedFunctionCalls",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getFunctionsByAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTransactionHash",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isTrustedForwarder",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFunctionConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyFunction",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
      TransactionLib.TransactionStruct[],
      PromiseOrValue<BytesLike>[]
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "aggregatorEscrowFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregatorEscrowWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregatorHistory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAggregator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAggregatorsByAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllAggregators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentIntervalId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getIntervalResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "latestResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openInterval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "saveResults",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAggregatorConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "viewAggregatorResults",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "viewLatestResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addMrEnclaveToAttestationQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attestationQueueHasMrEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attestationQueues",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAttestationQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAttestationQueueMrEnclaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEnclaveIdx",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEnclaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMrEnclaveFromAttestationQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAttestationQueueConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAttestationQueuePermission",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "diamondCut", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "facetAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "facetAddresses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "facetFunctionSelectors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "facets", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "init", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createEnclaveWithId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enclaveAuthorityToEnclaveAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enclaveGarbageCollect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enclaveHeartbeat",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "enclaves", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "failEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceOverrideVerify",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isEnclaveValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rotateEnclaveAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "validate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "verifyEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createOracleWithId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oracleGarbageCollect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oracleHeartbeat",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "oracles", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rotateOracleAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addMrEnclaveToOracleQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createOracleQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOracleIdx",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOracleQueueAllowedMrEnclaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOracles", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "oracleQueues",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "queueAttestationConfigs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMrEnclaveFromOracleQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleQueueAttestationConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleQueueConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleQueuePermission",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPermission",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasPermission",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callFunction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFunction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "forward", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "funcs", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "functionEscrowFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "functionEscrowWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "functionExists",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveFunctionsByQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllFunctions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllUnexecutedFunctionCalls",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFunctionsByAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTransactionHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTrustedForwarder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFunctionConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyFunction",
    data: BytesLike
  ): Result;

  events: {
    "AggregatorAccountInit(address,address,uint256)": EventFragment;
    "AggregatorFundEvent(address,address,uint256)": EventFragment;
    "AggregatorIntervalRefreshed(address,uint256,uint256)": EventFragment;
    "AggregatorOpenInterval(address,uint256)": EventFragment;
    "AggregatorRead(address,address,int256)": EventFragment;
    "AggregatorSaveResult(address,address,int256)": EventFragment;
    "AggregatorSettingsUpdated(address,uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "AggregatorUpdate(address,int256,uint256)": EventFragment;
    "AggregatorWithdrawEvent(address,address,uint256)": EventFragment;
    "OraclePayoutEvent(address,address,uint256)": EventFragment;
    "AddMrEnclave(address,bytes32)": EventFragment;
    "AttestationQueueAccountInit(address,address)": EventFragment;
    "AttestationQueuePermissionUpdated(address,address,address,uint256)": EventFragment;
    "AttestationQueueSetConfig(address,address)": EventFragment;
    "RemoveMrEnclave(address,bytes32)": EventFragment;
    "DiamondCut(tuple[],address,bytes)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "EnclaveAccountInit(address,address)": EventFragment;
    "EnclaveGC(address,address)": EventFragment;
    "EnclaveHeartbeat(address,address)": EventFragment;
    "EnclavePayoutEvent(address,address,uint256)": EventFragment;
    "EnclaveRotateAuthority(address,address,address)": EventFragment;
    "EnclaveVerifyRequest(address,address,address)": EventFragment;
    "OracleAccountInit(address,address)": EventFragment;
    "OracleGC(address,address)": EventFragment;
    "OracleHeartbeat(address)": EventFragment;
    "OracleSetConfig(address,string,address,address,address)": EventFragment;
    "OracleQueueAccountInit(address,address)": EventFragment;
    "OracleQueueAddMrEnclave(address,address,bytes32)": EventFragment;
    "OracleQueueRemoveMrEnclave(address,address,bytes32)": EventFragment;
    "OracleQueueSetAttestationConfig(address,address)": EventFragment;
    "OracleQueueSetConfig(address,address)": EventFragment;
    "OracleQueueSetPermission(address,address,address,uint256)": EventFragment;
    "FunctionAccountInit(address,address)": EventFragment;
    "FunctionCall(address,address,uint256,bytes)": EventFragment;
    "FunctionFund(address,address,uint256)": EventFragment;
    "FunctionWithdraw(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AggregatorAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorFundEvent"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "AggregatorIntervalRefreshed"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorOpenInterval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorRead"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorSaveResult"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorSettingsUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorWithdrawEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OraclePayoutEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AddMrEnclave"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "AttestationQueueAccountInit"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "AttestationQueuePermissionUpdated"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AttestationQueueSetConfig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveMrEnclave"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DiamondCut"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveGC"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveHeartbeat"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclavePayoutEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveRotateAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveVerifyRequest"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleGC"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleHeartbeat"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleSetConfig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueAddMrEnclave"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueRemoveMrEnclave"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "OracleQueueSetAttestationConfig"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueSetConfig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueSetPermission"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionCall"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionFund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionWithdraw"): EventFragment;
}

export interface AggregatorAccountInitEventObject {
  authority: string;
  accountId: string;
  timestamp: BigNumber;
}
export type AggregatorAccountInitEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorAccountInitEventObject
>;

export type AggregatorAccountInitEventFilter =
  TypedEventFilter<AggregatorAccountInitEvent>;

export interface AggregatorFundEventEventObject {
  aggregatorId: string;
  funder: string;
  amount: BigNumber;
}
export type AggregatorFundEventEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorFundEventEventObject
>;

export type AggregatorFundEventEventFilter =
  TypedEventFilter<AggregatorFundEventEvent>;

export interface AggregatorIntervalRefreshedEventObject {
  aggregatorId: string;
  intervalId: BigNumber;
  balanceLeftForInterval: BigNumber;
}
export type AggregatorIntervalRefreshedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  AggregatorIntervalRefreshedEventObject
>;

export type AggregatorIntervalRefreshedEventFilter =
  TypedEventFilter<AggregatorIntervalRefreshedEvent>;

export interface AggregatorOpenIntervalEventObject {
  aggregatorId: string;
  intervalId: BigNumber;
}
export type AggregatorOpenIntervalEvent = TypedEvent<
  [string, BigNumber],
  AggregatorOpenIntervalEventObject
>;

export type AggregatorOpenIntervalEventFilter =
  TypedEventFilter<AggregatorOpenIntervalEvent>;

export interface AggregatorReadEventObject {
  aggregatorId: string;
  reader: string;
  value: BigNumber;
}
export type AggregatorReadEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorReadEventObject
>;

export type AggregatorReadEventFilter = TypedEventFilter<AggregatorReadEvent>;

export interface AggregatorSaveResultEventObject {
  aggregatorId: string;
  oracle: string;
  value: BigNumber;
}
export type AggregatorSaveResultEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorSaveResultEventObject
>;

export type AggregatorSaveResultEventFilter =
  TypedEventFilter<AggregatorSaveResultEvent>;

export interface AggregatorSettingsUpdatedEventObject {
  aggregatorId: string;
  minUpdateDelaySeconds: BigNumber;
  minOracleResults: BigNumber;
  varianceThreshold: BigNumber;
  minJobResults: BigNumber;
  forceReportPeriod: BigNumber;
}
export type AggregatorSettingsUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  AggregatorSettingsUpdatedEventObject
>;

export type AggregatorSettingsUpdatedEventFilter =
  TypedEventFilter<AggregatorSettingsUpdatedEvent>;

export interface AggregatorUpdateEventObject {
  aggregatorId: string;
  value: BigNumber;
  timestamp: BigNumber;
}
export type AggregatorUpdateEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  AggregatorUpdateEventObject
>;

export type AggregatorUpdateEventFilter =
  TypedEventFilter<AggregatorUpdateEvent>;

export interface AggregatorWithdrawEventEventObject {
  aggregatorId: string;
  funder: string;
  amount: BigNumber;
}
export type AggregatorWithdrawEventEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorWithdrawEventEventObject
>;

export type AggregatorWithdrawEventEventFilter =
  TypedEventFilter<AggregatorWithdrawEventEvent>;

export interface OraclePayoutEventEventObject {
  oracleId: string;
  aggregatorId: string;
  amount: BigNumber;
}
export type OraclePayoutEventEvent = TypedEvent<
  [string, string, BigNumber],
  OraclePayoutEventEventObject
>;

export type OraclePayoutEventEventFilter =
  TypedEventFilter<OraclePayoutEventEvent>;

export interface AddMrEnclaveEventObject {
  queueId: string;
  mrEnclave: string;
}
export type AddMrEnclaveEvent = TypedEvent<
  [string, string],
  AddMrEnclaveEventObject
>;

export type AddMrEnclaveEventFilter = TypedEventFilter<AddMrEnclaveEvent>;

export interface AttestationQueueAccountInitEventObject {
  authority: string;
  accountId: string;
}
export type AttestationQueueAccountInitEvent = TypedEvent<
  [string, string],
  AttestationQueueAccountInitEventObject
>;

export type AttestationQueueAccountInitEventFilter =
  TypedEventFilter<AttestationQueueAccountInitEvent>;

export interface AttestationQueuePermissionUpdatedEventObject {
  queueId: string;
  granter: string;
  grantee: string;
  permission: BigNumber;
}
export type AttestationQueuePermissionUpdatedEvent = TypedEvent<
  [string, string, string, BigNumber],
  AttestationQueuePermissionUpdatedEventObject
>;

export type AttestationQueuePermissionUpdatedEventFilter =
  TypedEventFilter<AttestationQueuePermissionUpdatedEvent>;

export interface AttestationQueueSetConfigEventObject {
  queueId: string;
  authority: string;
}
export type AttestationQueueSetConfigEvent = TypedEvent<
  [string, string],
  AttestationQueueSetConfigEventObject
>;

export type AttestationQueueSetConfigEventFilter =
  TypedEventFilter<AttestationQueueSetConfigEvent>;

export interface RemoveMrEnclaveEventObject {
  queueId: string;
  mrEnclave: string;
}
export type RemoveMrEnclaveEvent = TypedEvent<
  [string, string],
  RemoveMrEnclaveEventObject
>;

export type RemoveMrEnclaveEventFilter = TypedEventFilter<RemoveMrEnclaveEvent>;

export interface DiamondCutEventObject {
  _diamondCut: IDiamondCut.FacetCutStructOutput[];
  _init: string;
  _calldata: string;
}
export type DiamondCutEvent = TypedEvent<
  [IDiamondCut.FacetCutStructOutput[], string, string],
  DiamondCutEventObject
>;

export type DiamondCutEventFilter = TypedEventFilter<DiamondCutEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface EnclaveAccountInitEventObject {
  authority: string;
  accountId: string;
}
export type EnclaveAccountInitEvent = TypedEvent<
  [string, string],
  EnclaveAccountInitEventObject
>;

export type EnclaveAccountInitEventFilter =
  TypedEventFilter<EnclaveAccountInitEvent>;

export interface EnclaveGCEventObject {
  enclaveId: string;
  queue: string;
}
export type EnclaveGCEvent = TypedEvent<[string, string], EnclaveGCEventObject>;

export type EnclaveGCEventFilter = TypedEventFilter<EnclaveGCEvent>;

export interface EnclaveHeartbeatEventObject {
  enclaveId: string;
  authority: string;
}
export type EnclaveHeartbeatEvent = TypedEvent<
  [string, string],
  EnclaveHeartbeatEventObject
>;

export type EnclaveHeartbeatEventFilter =
  TypedEventFilter<EnclaveHeartbeatEvent>;

export interface EnclavePayoutEventEventObject {
  nodeId: string;
  enclaveId: string;
  amount: BigNumber;
}
export type EnclavePayoutEventEvent = TypedEvent<
  [string, string, BigNumber],
  EnclavePayoutEventEventObject
>;

export type EnclavePayoutEventEventFilter =
  TypedEventFilter<EnclavePayoutEventEvent>;

export interface EnclaveRotateAuthorityEventObject {
  queueId: string;
  oldAuthority: string;
  newAuthority: string;
}
export type EnclaveRotateAuthorityEvent = TypedEvent<
  [string, string, string],
  EnclaveRotateAuthorityEventObject
>;

export type EnclaveRotateAuthorityEventFilter =
  TypedEventFilter<EnclaveRotateAuthorityEvent>;

export interface EnclaveVerifyRequestEventObject {
  queueId: string;
  verifier: string;
  verifiee: string;
}
export type EnclaveVerifyRequestEvent = TypedEvent<
  [string, string, string],
  EnclaveVerifyRequestEventObject
>;

export type EnclaveVerifyRequestEventFilter =
  TypedEventFilter<EnclaveVerifyRequestEvent>;

export interface OracleAccountInitEventObject {
  authority: string;
  accountId: string;
}
export type OracleAccountInitEvent = TypedEvent<
  [string, string],
  OracleAccountInitEventObject
>;

export type OracleAccountInitEventFilter =
  TypedEventFilter<OracleAccountInitEvent>;

export interface OracleGCEventObject {
  oracleId: string;
  queueId: string;
}
export type OracleGCEvent = TypedEvent<[string, string], OracleGCEventObject>;

export type OracleGCEventFilter = TypedEventFilter<OracleGCEvent>;

export interface OracleHeartbeatEventObject {
  oracleId: string;
}
export type OracleHeartbeatEvent = TypedEvent<
  [string],
  OracleHeartbeatEventObject
>;

export type OracleHeartbeatEventFilter = TypedEventFilter<OracleHeartbeatEvent>;

export interface OracleSetConfigEventObject {
  oracleId: string;
  name: string;
  authority: string;
  queueId: string;
  owner: string;
}
export type OracleSetConfigEvent = TypedEvent<
  [string, string, string, string, string],
  OracleSetConfigEventObject
>;

export type OracleSetConfigEventFilter = TypedEventFilter<OracleSetConfigEvent>;

export interface OracleQueueAccountInitEventObject {
  authority: string;
  accountId: string;
}
export type OracleQueueAccountInitEvent = TypedEvent<
  [string, string],
  OracleQueueAccountInitEventObject
>;

export type OracleQueueAccountInitEventFilter =
  TypedEventFilter<OracleQueueAccountInitEvent>;

export interface OracleQueueAddMrEnclaveEventObject {
  queueId: string;
  attestationQueueId: string;
  mrEnclave: string;
}
export type OracleQueueAddMrEnclaveEvent = TypedEvent<
  [string, string, string],
  OracleQueueAddMrEnclaveEventObject
>;

export type OracleQueueAddMrEnclaveEventFilter =
  TypedEventFilter<OracleQueueAddMrEnclaveEvent>;

export interface OracleQueueRemoveMrEnclaveEventObject {
  queueId: string;
  attestationQueueId: string;
  mrEnclave: string;
}
export type OracleQueueRemoveMrEnclaveEvent = TypedEvent<
  [string, string, string],
  OracleQueueRemoveMrEnclaveEventObject
>;

export type OracleQueueRemoveMrEnclaveEventFilter =
  TypedEventFilter<OracleQueueRemoveMrEnclaveEvent>;

export interface OracleQueueSetAttestationConfigEventObject {
  queueId: string;
  attestationQueueId: string;
}
export type OracleQueueSetAttestationConfigEvent = TypedEvent<
  [string, string],
  OracleQueueSetAttestationConfigEventObject
>;

export type OracleQueueSetAttestationConfigEventFilter =
  TypedEventFilter<OracleQueueSetAttestationConfigEvent>;

export interface OracleQueueSetConfigEventObject {
  queueId: string;
  authority: string;
}
export type OracleQueueSetConfigEvent = TypedEvent<
  [string, string],
  OracleQueueSetConfigEventObject
>;

export type OracleQueueSetConfigEventFilter =
  TypedEventFilter<OracleQueueSetConfigEvent>;

export interface OracleQueueSetPermissionEventObject {
  queueId: string;
  granter: string;
  grantee: string;
  permission: BigNumber;
}
export type OracleQueueSetPermissionEvent = TypedEvent<
  [string, string, string, BigNumber],
  OracleQueueSetPermissionEventObject
>;

export type OracleQueueSetPermissionEventFilter =
  TypedEventFilter<OracleQueueSetPermissionEvent>;

export interface FunctionAccountInitEventObject {
  authority: string;
  accountId: string;
}
export type FunctionAccountInitEvent = TypedEvent<
  [string, string],
  FunctionAccountInitEventObject
>;

export type FunctionAccountInitEventFilter =
  TypedEventFilter<FunctionAccountInitEvent>;

export interface FunctionCallEventObject {
  functionId: string;
  sender: string;
  callId: BigNumber;
  params: string;
}
export type FunctionCallEvent = TypedEvent<
  [string, string, BigNumber, string],
  FunctionCallEventObject
>;

export type FunctionCallEventFilter = TypedEventFilter<FunctionCallEvent>;

export interface FunctionFundEventObject {
  functionId: string;
  funder: string;
  amount: BigNumber;
}
export type FunctionFundEvent = TypedEvent<
  [string, string, BigNumber],
  FunctionFundEventObject
>;

export type FunctionFundEventFilter = TypedEventFilter<FunctionFundEvent>;

export interface FunctionWithdrawEventObject {
  functionId: string;
  withdrawer: string;
  amount: BigNumber;
}
export type FunctionWithdrawEvent = TypedEvent<
  [string, string, BigNumber],
  FunctionWithdrawEventObject
>;

export type FunctionWithdrawEventFilter =
  TypedEventFilter<FunctionWithdrawEvent>;

export interface Switchboard extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SwitchboardInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    aggregatorEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    aggregatorEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      aggregatorId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    aggregatorHistory(
      aggregatorId: PromiseOrValue<string>,
      roundId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[AggregatorLib.AggregatorHistoryResultStructOutput]>;

    aggregators(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[AggregatorLib.AggregatorStructOutput]>;

    createAggregator(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAggregatorsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

    getAllAggregators(
      overrides?: CallOverrides
    ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

    getCurrentIntervalId(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { roundId: BigNumber }>;

    getIntervalResult(
      aggregatorId: PromiseOrValue<string>,
      intervalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    latestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    openInterval(
      aggregatorId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    saveResults(
      ids: PromiseOrValue<string>[],
      results: PromiseOrValue<BigNumberish>[],
      queueId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAggregatorConfig(
      aggregatorId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    viewAggregatorResults(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[AggregatorLib.ResultStructOutput[]]>;

    viewLatestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { value: BigNumber; timestamp: BigNumber }
    >;

    addMrEnclaveToAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    attestationQueueHasMrEnclave(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    attestationQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[AttestationQueueLib.AttestationQueueStructOutput]>;

    createAttestationQueue(
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAttestationQueueMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getEnclaveIdx(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    removeMrEnclaveFromAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAttestationQueueConfig(
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAttestationQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    diamondCut(
      _diamondCut: IDiamondCut.FacetCutStruct[],
      _init: PromiseOrValue<string>,
      _calldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    facetAddress(
      _functionSelector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { facetAddress_: string }>;

    facetAddresses(
      overrides?: CallOverrides
    ): Promise<[string[]] & { facetAddresses_: string[] }>;

    facetFunctionSelectors(
      _facet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]] & { facetFunctionSelectors_: string[] }>;

    facets(
      overrides?: CallOverrides
    ): Promise<
      [IDiamondLoupe.FacetStructOutput[]] & {
        facets_: IDiamondLoupe.FacetStructOutput[];
      }
    >;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string] & { owner_: string }>;

    transferOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createEnclave(
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createEnclaveWithId(
      enclaveId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enclaveAuthorityToEnclaveAddress(
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    enclaveGarbageCollect(
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enclaveHeartbeat(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enclaves(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[EnclaveLib.EnclaveStructOutput]>;

    failEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      verifierIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceOverrideVerify(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isEnclaveValid(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    rotateEnclaveAuthority(
      enclaveId: PromiseOrValue<string>,
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateEnclave(
      enclaveId: PromiseOrValue<string>,
      cid: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    validate(
      authority: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      validMeasurements: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    verifyEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      timestamp: PromiseOrValue<BigNumberish>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createOracle(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createOracleWithId(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oracleGarbageCollect(
      oracleId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oracleHeartbeat(
      oracleId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oracles(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[OracleLib.OracleStructOutput]>;

    rotateOracleAuthority(
      oracleId: PromiseOrValue<string>,
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleConfig(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addMrEnclaveToOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createOracleQueue(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getOracleIdx(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getOracleQueueAllowedMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getOracles(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    oracleQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[OracleQueueLib.OracleQueueStructOutput]>;

    queueAttestationConfigs(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[OracleQueueLib.AttestationConfigStructOutput]>;

    removeMrEnclaveFromOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleQueueAttestationConfig(
      queueId: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      mrEnclaves: PromiseOrValue<BytesLike>[],
      requireValidEnclave: PromiseOrValue<boolean>,
      requireHeartbeatPermission: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleQueueConfig(
      queueId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    hasPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    callFunction(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createFunction(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forward(
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    funcs(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[FunctionLib.SbFunctionStructOutput]>;

    functionEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    functionEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    functionExists(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getActiveFunctionsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getAllFunctions(
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getAllUnexecutedFunctionCalls(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[FunctionLib.FunctionCallStructOutput[]]>;

    getFunctionsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getTransactionHash(
      expirationTimeSeconds: PromiseOrValue<BigNumberish>,
      gasLimit: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    isTrustedForwarder(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    setFunctionConfig(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    verifyFunction(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  aggregatorEscrowFund(
    accountId: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  aggregatorEscrowWithdraw(
    recipient: PromiseOrValue<string>,
    aggregatorId: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  aggregatorHistory(
    aggregatorId: PromiseOrValue<string>,
    roundId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<AggregatorLib.AggregatorHistoryResultStructOutput>;

  aggregators(
    aggregatorId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<AggregatorLib.AggregatorStructOutput>;

  createAggregator(
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    batchSize: PromiseOrValue<BigNumberish>,
    minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
    minOracleResults: PromiseOrValue<BigNumberish>,
    jobsHash: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    varianceThreshold: PromiseOrValue<BigNumberish>,
    minJobResults: PromiseOrValue<BigNumberish>,
    forceReportPeriod: PromiseOrValue<BigNumberish>,
    enableHistory: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAggregatorsByAuthority(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

  getAllAggregators(
    overrides?: CallOverrides
  ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

  getCurrentIntervalId(
    aggregatorId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getIntervalResult(
    aggregatorId: PromiseOrValue<string>,
    intervalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  latestResult(
    aggregatorId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  openInterval(
    aggregatorId: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  saveResults(
    ids: PromiseOrValue<string>[],
    results: PromiseOrValue<BigNumberish>[],
    queueId: PromiseOrValue<string>,
    oracleIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAggregatorConfig(
    aggregatorId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    batchSize: PromiseOrValue<BigNumberish>,
    minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
    minOracleResults: PromiseOrValue<BigNumberish>,
    jobsHash: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    varianceThreshold: PromiseOrValue<BigNumberish>,
    minJobResults: PromiseOrValue<BigNumberish>,
    forceReportPeriod: PromiseOrValue<BigNumberish>,
    enableHistory: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  viewAggregatorResults(
    aggregatorId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<AggregatorLib.ResultStructOutput[]>;

  viewLatestResult(
    aggregatorId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { value: BigNumber; timestamp: BigNumber }
  >;

  addMrEnclaveToAttestationQueue(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  attestationQueueHasMrEnclave(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  attestationQueues(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<AttestationQueueLib.AttestationQueueStructOutput>;

  createAttestationQueue(
    authority: PromiseOrValue<string>,
    maxSize: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    enclaveTimeout: PromiseOrValue<BigNumberish>,
    maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
    allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
    requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
    requireUsagePermissions: PromiseOrValue<boolean>,
    maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAttestationQueueMrEnclaves(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getEnclaveIdx(
    enclaveId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getEnclaves(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  removeMrEnclaveFromAttestationQueue(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAttestationQueueConfig(
    queueId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    maxSize: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    enclaveTimeout: PromiseOrValue<BigNumberish>,
    maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
    allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
    requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
    requireUsagePermissions: PromiseOrValue<boolean>,
    maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAttestationQueuePermission(
    queueId: PromiseOrValue<string>,
    grantee: PromiseOrValue<string>,
    permission: PromiseOrValue<BigNumberish>,
    on: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  diamondCut(
    _diamondCut: IDiamondCut.FacetCutStruct[],
    _init: PromiseOrValue<string>,
    _calldata: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  facetAddress(
    _functionSelector: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  facetAddresses(overrides?: CallOverrides): Promise<string[]>;

  facetFunctionSelectors(
    _facet: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  facets(overrides?: CallOverrides): Promise<IDiamondLoupe.FacetStructOutput[]>;

  supportsInterface(
    _interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    _newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  init(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createEnclave(
    authority: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createEnclaveWithId(
    enclaveId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enclaveAuthorityToEnclaveAddress(
    authority: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  enclaveGarbageCollect(
    enclaveId: PromiseOrValue<string>,
    enclaveIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enclaveHeartbeat(
    enclaveId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enclaves(
    enclaveId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<EnclaveLib.EnclaveStructOutput>;

  failEnclave(
    verifierId: PromiseOrValue<string>,
    enclaveId: PromiseOrValue<string>,
    verifierIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceOverrideVerify(
    enclaveId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isEnclaveValid(
    enclaveId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  rotateEnclaveAuthority(
    enclaveId: PromiseOrValue<string>,
    newAuthority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateEnclave(
    enclaveId: PromiseOrValue<string>,
    cid: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  validate(
    authority: PromiseOrValue<string>,
    attestationQueueId: PromiseOrValue<string>,
    validMeasurements: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<void>;

  verifyEnclave(
    verifierId: PromiseOrValue<string>,
    enclaveId: PromiseOrValue<string>,
    enclaveIdx: PromiseOrValue<BigNumberish>,
    timestamp: PromiseOrValue<BigNumberish>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createOracle(
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createOracleWithId(
    oracleId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oracleGarbageCollect(
    oracleId: PromiseOrValue<string>,
    oracleIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oracleHeartbeat(
    oracleId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oracles(
    oracleId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<OracleLib.OracleStructOutput>;

  rotateOracleAuthority(
    oracleId: PromiseOrValue<string>,
    newAuthority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleConfig(
    oracleId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addMrEnclaveToOracleQueue(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createOracleQueue(
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
    maxSize: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    oracleTimeout: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getOracleIdx(
    oracleId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getOracleQueueAllowedMrEnclaves(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getOracles(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  oracleQueues(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<OracleQueueLib.OracleQueueStructOutput>;

  queueAttestationConfigs(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<OracleQueueLib.AttestationConfigStructOutput>;

  removeMrEnclaveFromOracleQueue(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleQueueAttestationConfig(
    queueId: PromiseOrValue<string>,
    attestationQueueId: PromiseOrValue<string>,
    mrEnclaves: PromiseOrValue<BytesLike>[],
    requireValidEnclave: PromiseOrValue<boolean>,
    requireHeartbeatPermission: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleQueueConfig(
    queueId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
    maxSize: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    oracleTimeout: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleQueuePermission(
    queueId: PromiseOrValue<string>,
    grantee: PromiseOrValue<string>,
    permission: PromiseOrValue<BigNumberish>,
    on: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getPermission(
    granter: PromiseOrValue<string>,
    grantee: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  hasPermission(
    granter: PromiseOrValue<string>,
    grantee: PromiseOrValue<string>,
    permission: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callFunction(
    functionId: PromiseOrValue<string>,
    params: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createFunction(
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    containerRegistry: PromiseOrValue<string>,
    container: PromiseOrValue<string>,
    version: PromiseOrValue<BytesLike>,
    schedule: PromiseOrValue<string>,
    paramsSchema: PromiseOrValue<string>,
    permittedCallers: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forward(
    transactions: TransactionLib.TransactionStruct[],
    signatures: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  funcs(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FunctionLib.SbFunctionStructOutput>;

  functionEscrowFund(
    accountId: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  functionEscrowWithdraw(
    recipient: PromiseOrValue<string>,
    functionId: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  functionExists(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getActiveFunctionsByQueue(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

  getAllFunctions(
    overrides?: CallOverrides
  ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

  getAllUnexecutedFunctionCalls(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FunctionLib.FunctionCallStructOutput[]>;

  getFunctionsByAuthority(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

  getTransactionHash(
    expirationTimeSeconds: PromiseOrValue<BigNumberish>,
    gasLimit: PromiseOrValue<BigNumberish>,
    value: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  isTrustedForwarder(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  setFunctionConfig(
    functionId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    containerRegistry: PromiseOrValue<string>,
    container: PromiseOrValue<string>,
    version: PromiseOrValue<BytesLike>,
    schedule: PromiseOrValue<string>,
    paramsSchema: PromiseOrValue<string>,
    permittedCallers: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  verifyFunction(
    enclaveIdx: PromiseOrValue<BigNumberish>,
    functionId: PromiseOrValue<string>,
    delegatedSignerAddress: PromiseOrValue<string>,
    observedTime: PromiseOrValue<BigNumberish>,
    nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
    isFailure: PromiseOrValue<boolean>,
    mrEnclave: PromiseOrValue<BytesLike>,
    transactions: TransactionLib.TransactionStruct[],
    signatures: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    aggregatorEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    aggregatorEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      aggregatorId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    aggregatorHistory(
      aggregatorId: PromiseOrValue<string>,
      roundId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<AggregatorLib.AggregatorHistoryResultStructOutput>;

    aggregators(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<AggregatorLib.AggregatorStructOutput>;

    createAggregator(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAggregatorsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

    getAllAggregators(
      overrides?: CallOverrides
    ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

    getCurrentIntervalId(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIntervalResult(
      aggregatorId: PromiseOrValue<string>,
      intervalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        value: BigNumber;
        timestamp: BigNumber;
        medianTimestamp: BigNumber;
      }
    >;

    latestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { value: BigNumber; timestamp: BigNumber }
    >;

    openInterval(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    saveResults(
      ids: PromiseOrValue<string>[],
      results: PromiseOrValue<BigNumberish>[],
      queueId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setAggregatorConfig(
      aggregatorId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    viewAggregatorResults(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<AggregatorLib.ResultStructOutput[]>;

    viewLatestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { value: BigNumber; timestamp: BigNumber }
    >;

    addMrEnclaveToAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    attestationQueueHasMrEnclave(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    attestationQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<AttestationQueueLib.AttestationQueueStructOutput>;

    createAttestationQueue(
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAttestationQueueMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getEnclaveIdx(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    removeMrEnclaveFromAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setAttestationQueueConfig(
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setAttestationQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    diamondCut(
      _diamondCut: IDiamondCut.FacetCutStruct[],
      _init: PromiseOrValue<string>,
      _calldata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    facetAddress(
      _functionSelector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    facetAddresses(overrides?: CallOverrides): Promise<string[]>;

    facetFunctionSelectors(
      _facet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    facets(
      overrides?: CallOverrides
    ): Promise<IDiamondLoupe.FacetStructOutput[]>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    transferOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    init(overrides?: CallOverrides): Promise<void>;

    createEnclave(
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    createEnclaveWithId(
      enclaveId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    enclaveAuthorityToEnclaveAddress(
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    enclaveGarbageCollect(
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    enclaveHeartbeat(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    enclaves(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<EnclaveLib.EnclaveStructOutput>;

    failEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      verifierIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceOverrideVerify(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    isEnclaveValid(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    rotateEnclaveAuthority(
      enclaveId: PromiseOrValue<string>,
      newAuthority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateEnclave(
      enclaveId: PromiseOrValue<string>,
      cid: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    validate(
      authority: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      validMeasurements: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    verifyEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      timestamp: PromiseOrValue<BigNumberish>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    createOracle(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    createOracleWithId(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    oracleGarbageCollect(
      oracleId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    oracleHeartbeat(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    oracles(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<OracleLib.OracleStructOutput>;

    rotateOracleAuthority(
      oracleId: PromiseOrValue<string>,
      newAuthority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleConfig(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addMrEnclaveToOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    createOracleQueue(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getOracleIdx(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOracleQueueAllowedMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getOracles(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    oracleQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<OracleQueueLib.OracleQueueStructOutput>;

    queueAttestationConfigs(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<OracleQueueLib.AttestationConfigStructOutput>;

    removeMrEnclaveFromOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleQueueAttestationConfig(
      queueId: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      mrEnclaves: PromiseOrValue<BytesLike>[],
      requireValidEnclave: PromiseOrValue<boolean>,
      requireHeartbeatPermission: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleQueueConfig(
      queueId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    getPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    callFunction(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    createFunction(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    forward(
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    funcs(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FunctionLib.SbFunctionStructOutput>;

    functionEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    functionEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    functionExists(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getActiveFunctionsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getAllFunctions(
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getAllUnexecutedFunctionCalls(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FunctionLib.FunctionCallStructOutput[]>;

    getFunctionsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getTransactionHash(
      expirationTimeSeconds: PromiseOrValue<BigNumberish>,
      gasLimit: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    isTrustedForwarder(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setFunctionConfig(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    verifyFunction(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AggregatorAccountInit(address,address,uint256)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null,
      timestamp?: null
    ): AggregatorAccountInitEventFilter;
    AggregatorAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null,
      timestamp?: null
    ): AggregatorAccountInitEventFilter;

    "AggregatorFundEvent(address,address,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): AggregatorFundEventEventFilter;
    AggregatorFundEvent(
      aggregatorId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): AggregatorFundEventEventFilter;

    "AggregatorIntervalRefreshed(address,uint256,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      intervalId?: PromiseOrValue<BigNumberish> | null,
      balanceLeftForInterval?: PromiseOrValue<BigNumberish> | null
    ): AggregatorIntervalRefreshedEventFilter;
    AggregatorIntervalRefreshed(
      aggregatorId?: PromiseOrValue<string> | null,
      intervalId?: PromiseOrValue<BigNumberish> | null,
      balanceLeftForInterval?: PromiseOrValue<BigNumberish> | null
    ): AggregatorIntervalRefreshedEventFilter;

    "AggregatorOpenInterval(address,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      intervalId?: PromiseOrValue<BigNumberish> | null
    ): AggregatorOpenIntervalEventFilter;
    AggregatorOpenInterval(
      aggregatorId?: PromiseOrValue<string> | null,
      intervalId?: PromiseOrValue<BigNumberish> | null
    ): AggregatorOpenIntervalEventFilter;

    "AggregatorRead(address,address,int256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      reader?: PromiseOrValue<string> | null,
      value?: null
    ): AggregatorReadEventFilter;
    AggregatorRead(
      aggregatorId?: PromiseOrValue<string> | null,
      reader?: PromiseOrValue<string> | null,
      value?: null
    ): AggregatorReadEventFilter;

    "AggregatorSaveResult(address,address,int256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      oracle?: PromiseOrValue<string> | null,
      value?: PromiseOrValue<BigNumberish> | null
    ): AggregatorSaveResultEventFilter;
    AggregatorSaveResult(
      aggregatorId?: PromiseOrValue<string> | null,
      oracle?: PromiseOrValue<string> | null,
      value?: PromiseOrValue<BigNumberish> | null
    ): AggregatorSaveResultEventFilter;

    "AggregatorSettingsUpdated(address,uint256,uint256,uint256,uint256,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      minUpdateDelaySeconds?: null,
      minOracleResults?: null,
      varianceThreshold?: null,
      minJobResults?: null,
      forceReportPeriod?: null
    ): AggregatorSettingsUpdatedEventFilter;
    AggregatorSettingsUpdated(
      aggregatorId?: PromiseOrValue<string> | null,
      minUpdateDelaySeconds?: null,
      minOracleResults?: null,
      varianceThreshold?: null,
      minJobResults?: null,
      forceReportPeriod?: null
    ): AggregatorSettingsUpdatedEventFilter;

    "AggregatorUpdate(address,int256,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      value?: PromiseOrValue<BigNumberish> | null,
      timestamp?: null
    ): AggregatorUpdateEventFilter;
    AggregatorUpdate(
      aggregatorId?: PromiseOrValue<string> | null,
      value?: PromiseOrValue<BigNumberish> | null,
      timestamp?: null
    ): AggregatorUpdateEventFilter;

    "AggregatorWithdrawEvent(address,address,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): AggregatorWithdrawEventEventFilter;
    AggregatorWithdrawEvent(
      aggregatorId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): AggregatorWithdrawEventEventFilter;

    "OraclePayoutEvent(address,address,uint256)"(
      oracleId?: PromiseOrValue<string> | null,
      aggregatorId?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): OraclePayoutEventEventFilter;
    OraclePayoutEvent(
      oracleId?: PromiseOrValue<string> | null,
      aggregatorId?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): OraclePayoutEventEventFilter;

    "AddMrEnclave(address,bytes32)"(
      queueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): AddMrEnclaveEventFilter;
    AddMrEnclave(
      queueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): AddMrEnclaveEventFilter;

    "AttestationQueueAccountInit(address,address)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): AttestationQueueAccountInitEventFilter;
    AttestationQueueAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): AttestationQueueAccountInitEventFilter;

    "AttestationQueuePermissionUpdated(address,address,address,uint256)"(
      queueId?: PromiseOrValue<string> | null,
      granter?: PromiseOrValue<string> | null,
      grantee?: PromiseOrValue<string> | null,
      permission?: null
    ): AttestationQueuePermissionUpdatedEventFilter;
    AttestationQueuePermissionUpdated(
      queueId?: PromiseOrValue<string> | null,
      granter?: PromiseOrValue<string> | null,
      grantee?: PromiseOrValue<string> | null,
      permission?: null
    ): AttestationQueuePermissionUpdatedEventFilter;

    "AttestationQueueSetConfig(address,address)"(
      queueId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): AttestationQueueSetConfigEventFilter;
    AttestationQueueSetConfig(
      queueId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): AttestationQueueSetConfigEventFilter;

    "RemoveMrEnclave(address,bytes32)"(
      queueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): RemoveMrEnclaveEventFilter;
    RemoveMrEnclave(
      queueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): RemoveMrEnclaveEventFilter;

    "DiamondCut(tuple[],address,bytes)"(
      _diamondCut?: null,
      _init?: null,
      _calldata?: null
    ): DiamondCutEventFilter;
    DiamondCut(
      _diamondCut?: null,
      _init?: null,
      _calldata?: null
    ): DiamondCutEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "EnclaveAccountInit(address,address)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): EnclaveAccountInitEventFilter;
    EnclaveAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): EnclaveAccountInitEventFilter;

    "EnclaveGC(address,address)"(
      enclaveId?: PromiseOrValue<string> | null,
      queue?: PromiseOrValue<string> | null
    ): EnclaveGCEventFilter;
    EnclaveGC(
      enclaveId?: PromiseOrValue<string> | null,
      queue?: PromiseOrValue<string> | null
    ): EnclaveGCEventFilter;

    "EnclaveHeartbeat(address,address)"(
      enclaveId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): EnclaveHeartbeatEventFilter;
    EnclaveHeartbeat(
      enclaveId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): EnclaveHeartbeatEventFilter;

    "EnclavePayoutEvent(address,address,uint256)"(
      nodeId?: PromiseOrValue<string> | null,
      enclaveId?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): EnclavePayoutEventEventFilter;
    EnclavePayoutEvent(
      nodeId?: PromiseOrValue<string> | null,
      enclaveId?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): EnclavePayoutEventEventFilter;

    "EnclaveRotateAuthority(address,address,address)"(
      queueId?: PromiseOrValue<string> | null,
      oldAuthority?: PromiseOrValue<string> | null,
      newAuthority?: PromiseOrValue<string> | null
    ): EnclaveRotateAuthorityEventFilter;
    EnclaveRotateAuthority(
      queueId?: PromiseOrValue<string> | null,
      oldAuthority?: PromiseOrValue<string> | null,
      newAuthority?: PromiseOrValue<string> | null
    ): EnclaveRotateAuthorityEventFilter;

    "EnclaveVerifyRequest(address,address,address)"(
      queueId?: PromiseOrValue<string> | null,
      verifier?: PromiseOrValue<string> | null,
      verifiee?: PromiseOrValue<string> | null
    ): EnclaveVerifyRequestEventFilter;
    EnclaveVerifyRequest(
      queueId?: PromiseOrValue<string> | null,
      verifier?: PromiseOrValue<string> | null,
      verifiee?: PromiseOrValue<string> | null
    ): EnclaveVerifyRequestEventFilter;

    "OracleAccountInit(address,address)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): OracleAccountInitEventFilter;
    OracleAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): OracleAccountInitEventFilter;

    "OracleGC(address,address)"(
      oracleId?: PromiseOrValue<string> | null,
      queueId?: PromiseOrValue<string> | null
    ): OracleGCEventFilter;
    OracleGC(
      oracleId?: PromiseOrValue<string> | null,
      queueId?: PromiseOrValue<string> | null
    ): OracleGCEventFilter;

    "OracleHeartbeat(address)"(
      oracleId?: PromiseOrValue<string> | null
    ): OracleHeartbeatEventFilter;
    OracleHeartbeat(
      oracleId?: PromiseOrValue<string> | null
    ): OracleHeartbeatEventFilter;

    "OracleSetConfig(address,string,address,address,address)"(
      oracleId?: PromiseOrValue<string> | null,
      name?: null,
      authority?: PromiseOrValue<string> | null,
      queueId?: PromiseOrValue<string> | null,
      owner?: null
    ): OracleSetConfigEventFilter;
    OracleSetConfig(
      oracleId?: PromiseOrValue<string> | null,
      name?: null,
      authority?: PromiseOrValue<string> | null,
      queueId?: PromiseOrValue<string> | null,
      owner?: null
    ): OracleSetConfigEventFilter;

    "OracleQueueAccountInit(address,address)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): OracleQueueAccountInitEventFilter;
    OracleQueueAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): OracleQueueAccountInitEventFilter;

    "OracleQueueAddMrEnclave(address,address,bytes32)"(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): OracleQueueAddMrEnclaveEventFilter;
    OracleQueueAddMrEnclave(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): OracleQueueAddMrEnclaveEventFilter;

    "OracleQueueRemoveMrEnclave(address,address,bytes32)"(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): OracleQueueRemoveMrEnclaveEventFilter;
    OracleQueueRemoveMrEnclave(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): OracleQueueRemoveMrEnclaveEventFilter;

    "OracleQueueSetAttestationConfig(address,address)"(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null
    ): OracleQueueSetAttestationConfigEventFilter;
    OracleQueueSetAttestationConfig(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null
    ): OracleQueueSetAttestationConfigEventFilter;

    "OracleQueueSetConfig(address,address)"(
      queueId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): OracleQueueSetConfigEventFilter;
    OracleQueueSetConfig(
      queueId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): OracleQueueSetConfigEventFilter;

    "OracleQueueSetPermission(address,address,address,uint256)"(
      queueId?: PromiseOrValue<string> | null,
      granter?: PromiseOrValue<string> | null,
      grantee?: PromiseOrValue<string> | null,
      permission?: null
    ): OracleQueueSetPermissionEventFilter;
    OracleQueueSetPermission(
      queueId?: PromiseOrValue<string> | null,
      granter?: PromiseOrValue<string> | null,
      grantee?: PromiseOrValue<string> | null,
      permission?: null
    ): OracleQueueSetPermissionEventFilter;

    "FunctionAccountInit(address,address)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): FunctionAccountInitEventFilter;
    FunctionAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): FunctionAccountInitEventFilter;

    "FunctionCall(address,address,uint256,bytes)"(
      functionId?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      callId?: PromiseOrValue<BigNumberish> | null,
      params?: null
    ): FunctionCallEventFilter;
    FunctionCall(
      functionId?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      callId?: PromiseOrValue<BigNumberish> | null,
      params?: null
    ): FunctionCallEventFilter;

    "FunctionFund(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionFundEventFilter;
    FunctionFund(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionFundEventFilter;

    "FunctionWithdraw(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      withdrawer?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionWithdrawEventFilter;
    FunctionWithdraw(
      functionId?: PromiseOrValue<string> | null,
      withdrawer?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionWithdrawEventFilter;
  };

  estimateGas: {
    aggregatorEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    aggregatorEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      aggregatorId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    aggregatorHistory(
      aggregatorId: PromiseOrValue<string>,
      roundId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    aggregators(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createAggregator(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAggregatorsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllAggregators(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentIntervalId(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIntervalResult(
      aggregatorId: PromiseOrValue<string>,
      intervalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    latestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    openInterval(
      aggregatorId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    saveResults(
      ids: PromiseOrValue<string>[],
      results: PromiseOrValue<BigNumberish>[],
      queueId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAggregatorConfig(
      aggregatorId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    viewAggregatorResults(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    viewLatestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addMrEnclaveToAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    attestationQueueHasMrEnclave(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    attestationQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createAttestationQueue(
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAttestationQueueMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEnclaveIdx(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeMrEnclaveFromAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAttestationQueueConfig(
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAttestationQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    diamondCut(
      _diamondCut: IDiamondCut.FacetCutStruct[],
      _init: PromiseOrValue<string>,
      _calldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    facetAddress(
      _functionSelector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    facetAddresses(overrides?: CallOverrides): Promise<BigNumber>;

    facetFunctionSelectors(
      _facet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    facets(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createEnclave(
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createEnclaveWithId(
      enclaveId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enclaveAuthorityToEnclaveAddress(
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    enclaveGarbageCollect(
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enclaveHeartbeat(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enclaves(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    failEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      verifierIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceOverrideVerify(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isEnclaveValid(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rotateEnclaveAuthority(
      enclaveId: PromiseOrValue<string>,
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateEnclave(
      enclaveId: PromiseOrValue<string>,
      cid: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    validate(
      authority: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      validMeasurements: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      timestamp: PromiseOrValue<BigNumberish>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createOracle(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createOracleWithId(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oracleGarbageCollect(
      oracleId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oracleHeartbeat(
      oracleId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oracles(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rotateOracleAuthority(
      oracleId: PromiseOrValue<string>,
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleConfig(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addMrEnclaveToOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createOracleQueue(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getOracleIdx(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOracleQueueAllowedMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOracles(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oracleQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    queueAttestationConfigs(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeMrEnclaveFromOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleQueueAttestationConfig(
      queueId: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      mrEnclaves: PromiseOrValue<BytesLike>[],
      requireValidEnclave: PromiseOrValue<boolean>,
      requireHeartbeatPermission: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleQueueConfig(
      queueId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    callFunction(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createFunction(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forward(
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    funcs(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    functionEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    functionEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    functionExists(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getActiveFunctionsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllFunctions(overrides?: CallOverrides): Promise<BigNumber>;

    getAllUnexecutedFunctionCalls(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFunctionsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTransactionHash(
      expirationTimeSeconds: PromiseOrValue<BigNumberish>,
      gasLimit: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTrustedForwarder(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setFunctionConfig(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    verifyFunction(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    aggregatorEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    aggregatorEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      aggregatorId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    aggregatorHistory(
      aggregatorId: PromiseOrValue<string>,
      roundId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    aggregators(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createAggregator(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAggregatorsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllAggregators(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCurrentIntervalId(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getIntervalResult(
      aggregatorId: PromiseOrValue<string>,
      intervalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    latestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    openInterval(
      aggregatorId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    saveResults(
      ids: PromiseOrValue<string>[],
      results: PromiseOrValue<BigNumberish>[],
      queueId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAggregatorConfig(
      aggregatorId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    viewAggregatorResults(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    viewLatestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addMrEnclaveToAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    attestationQueueHasMrEnclave(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    attestationQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createAttestationQueue(
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAttestationQueueMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getEnclaveIdx(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeMrEnclaveFromAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAttestationQueueConfig(
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAttestationQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    diamondCut(
      _diamondCut: IDiamondCut.FacetCutStruct[],
      _init: PromiseOrValue<string>,
      _calldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    facetAddress(
      _functionSelector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    facetAddresses(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    facetFunctionSelectors(
      _facet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    facets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createEnclave(
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createEnclaveWithId(
      enclaveId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enclaveAuthorityToEnclaveAddress(
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    enclaveGarbageCollect(
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enclaveHeartbeat(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enclaves(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    failEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      verifierIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceOverrideVerify(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isEnclaveValid(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rotateEnclaveAuthority(
      enclaveId: PromiseOrValue<string>,
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateEnclave(
      enclaveId: PromiseOrValue<string>,
      cid: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    validate(
      authority: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      validMeasurements: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      timestamp: PromiseOrValue<BigNumberish>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createOracle(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createOracleWithId(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oracleGarbageCollect(
      oracleId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oracleHeartbeat(
      oracleId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oracles(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rotateOracleAuthority(
      oracleId: PromiseOrValue<string>,
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleConfig(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addMrEnclaveToOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createOracleQueue(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getOracleIdx(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOracleQueueAllowedMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOracles(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oracleQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    queueAttestationConfigs(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeMrEnclaveFromOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleQueueAttestationConfig(
      queueId: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      mrEnclaves: PromiseOrValue<BytesLike>[],
      requireValidEnclave: PromiseOrValue<boolean>,
      requireHeartbeatPermission: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleQueueConfig(
      queueId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    callFunction(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createFunction(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forward(
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    funcs(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    functionEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    functionEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    functionExists(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getActiveFunctionsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllFunctions(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAllUnexecutedFunctionCalls(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFunctionsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTransactionHash(
      expirationTimeSeconds: PromiseOrValue<BigNumberish>,
      gasLimit: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTrustedForwarder(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setFunctionConfig(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    verifyFunction(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
