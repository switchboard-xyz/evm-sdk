/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace AggregatorLib {
  export type AggregatorHistoryResultStruct = {
    value: PromiseOrValue<BigNumberish>;
    timestamp: PromiseOrValue<BigNumberish>;
    medianTimestamp: PromiseOrValue<BigNumberish>;
  };

  export type AggregatorHistoryResultStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber
  ] & { value: BigNumber; timestamp: BigNumber; medianTimestamp: BigNumber };

  export type ResultStruct = {
    value: PromiseOrValue<BigNumberish>;
    timestamp: PromiseOrValue<BigNumberish>;
    oracleId: PromiseOrValue<string>;
  };

  export type ResultStructOutput = [BigNumber, BigNumber, string] & {
    value: BigNumber;
    timestamp: BigNumber;
    oracleId: string;
  };

  export type AggregatorConfigStruct = {
    batchSize: PromiseOrValue<BigNumberish>;
    minUpdateDelaySeconds: PromiseOrValue<BigNumberish>;
    minOracleResults: PromiseOrValue<BigNumberish>;
    varianceThreshold: PromiseOrValue<BigNumberish>;
    minJobResults: PromiseOrValue<BigNumberish>;
    forceReportPeriod: PromiseOrValue<BigNumberish>;
  };

  export type AggregatorConfigStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    batchSize: BigNumber;
    minUpdateDelaySeconds: BigNumber;
    minOracleResults: BigNumber;
    varianceThreshold: BigNumber;
    minJobResults: BigNumber;
    forceReportPeriod: BigNumber;
  };

  export type AggregatorStruct = {
    name: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    latestResult: AggregatorLib.ResultStruct;
    config: AggregatorLib.AggregatorConfigStruct;
    jobsHash: PromiseOrValue<string>;
    queueId: PromiseOrValue<string>;
    balanceLeftForInterval: PromiseOrValue<BigNumberish>;
    nextIntervalRefreshTime: PromiseOrValue<BigNumberish>;
    intervalId: PromiseOrValue<BigNumberish>;
    balance: PromiseOrValue<BigNumberish>;
    historyEnabled: PromiseOrValue<boolean>;
  };

  export type AggregatorStructOutput = [
    string,
    string,
    AggregatorLib.ResultStructOutput,
    AggregatorLib.AggregatorConfigStructOutput,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    name: string;
    authority: string;
    latestResult: AggregatorLib.ResultStructOutput;
    config: AggregatorLib.AggregatorConfigStructOutput;
    jobsHash: string;
    queueId: string;
    balanceLeftForInterval: BigNumber;
    nextIntervalRefreshTime: BigNumber;
    intervalId: BigNumber;
    balance: BigNumber;
    historyEnabled: boolean;
  };
}

export declare namespace AttestationQueueLib {
  export type AttestationQueueStruct = {
    authority: PromiseOrValue<string>;
    data: PromiseOrValue<string>[];
    maxSize: PromiseOrValue<BigNumberish>;
    reward: PromiseOrValue<BigNumberish>;
    lastHeartbeat: PromiseOrValue<BigNumberish>;
    mrEnclaves: PromiseOrValue<BytesLike>[];
    maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>;
    allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>;
    maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>;
    requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>;
    requireUsagePermissions: PromiseOrValue<boolean>;
    enclaveTimeout: PromiseOrValue<BigNumberish>;
    gcIdx: PromiseOrValue<BigNumberish>;
    currIdx: PromiseOrValue<BigNumberish>;
  };

  export type AttestationQueueStructOutput = [
    string,
    string[],
    BigNumber,
    BigNumber,
    BigNumber,
    string[],
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    authority: string;
    data: string[];
    maxSize: BigNumber;
    reward: BigNumber;
    lastHeartbeat: BigNumber;
    mrEnclaves: string[];
    maxEnclaveVerificationAge: BigNumber;
    allowAuthorityOverrideAfter: BigNumber;
    maxConsecutiveFunctionFailures: BigNumber;
    requireAuthorityHeartbeatPermission: boolean;
    requireUsagePermissions: boolean;
    enclaveTimeout: BigNumber;
    gcIdx: BigNumber;
    currIdx: BigNumber;
  };
}

export declare namespace IDiamondCut {
  export type FacetCutStruct = {
    facetAddress: PromiseOrValue<string>;
    action: PromiseOrValue<BigNumberish>;
    functionSelectors: PromiseOrValue<BytesLike>[];
  };

  export type FacetCutStructOutput = [string, number, string[]] & {
    facetAddress: string;
    action: number;
    functionSelectors: string[];
  };
}

export declare namespace IDiamondLoupe {
  export type FacetStruct = {
    facetAddress: PromiseOrValue<string>;
    functionSelectors: PromiseOrValue<BytesLike>[];
  };

  export type FacetStructOutput = [string, string[]] & {
    facetAddress: string;
    functionSelectors: string[];
  };
}

export declare namespace EnclaveLib {
  export type EnclaveStruct = {
    signer: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    queueId: PromiseOrValue<string>;
    cid: PromiseOrValue<BytesLike>;
    verificationStatus: PromiseOrValue<BigNumberish>;
    verificationTimestamp: PromiseOrValue<BigNumberish>;
    validUntil: PromiseOrValue<BigNumberish>;
    mrEnclave: PromiseOrValue<BytesLike>;
    isOnQueue: PromiseOrValue<boolean>;
    lastHeartbeat: PromiseOrValue<BigNumberish>;
    balance: PromiseOrValue<BigNumberish>;
  };

  export type EnclaveStructOutput = [
    string,
    string,
    string,
    string,
    number,
    BigNumber,
    BigNumber,
    string,
    boolean,
    BigNumber,
    BigNumber
  ] & {
    signer: string;
    authority: string;
    queueId: string;
    cid: string;
    verificationStatus: number;
    verificationTimestamp: BigNumber;
    validUntil: BigNumber;
    mrEnclave: string;
    isOnQueue: boolean;
    lastHeartbeat: BigNumber;
    balance: BigNumber;
  };
}

export declare namespace FunctionCallLib {
  export type FunctionCallSettingsStruct = {
    requireEstimatedRunCostFee: PromiseOrValue<boolean>;
    minimumFee: PromiseOrValue<BigNumberish>;
    maxGasCost: PromiseOrValue<BigNumberish>;
    requireCallerPayFullCost: PromiseOrValue<boolean>;
    requireSenderBeReturnAddress: PromiseOrValue<boolean>;
  };

  export type FunctionCallSettingsStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    boolean,
    boolean
  ] & {
    requireEstimatedRunCostFee: boolean;
    minimumFee: BigNumber;
    maxGasCost: BigNumber;
    requireCallerPayFullCost: boolean;
    requireSenderBeReturnAddress: boolean;
  };

  export type FunctionCallStruct = {
    functionId: PromiseOrValue<string>;
    caller: PromiseOrValue<string>;
    timestamp: PromiseOrValue<BigNumberish>;
    callData: PromiseOrValue<BytesLike>;
    executed: PromiseOrValue<boolean>;
    consecutiveFailures: PromiseOrValue<BigNumberish>;
    feePaid: PromiseOrValue<BigNumberish>;
  };

  export type FunctionCallStructOutput = [
    string,
    string,
    BigNumber,
    string,
    boolean,
    BigNumber,
    BigNumber
  ] & {
    functionId: string;
    caller: string;
    timestamp: BigNumber;
    callData: string;
    executed: boolean;
    consecutiveFailures: BigNumber;
    feePaid: BigNumber;
  };
}

export declare namespace FunctionSettingsLib {
  export type FunctionSettingsStruct = {
    maxGasCost: PromiseOrValue<BigNumberish>;
    requireIsolatedRuns: PromiseOrValue<boolean>;
    routinesDisabled: PromiseOrValue<boolean>;
    routinesRequireAuthorization: PromiseOrValue<boolean>;
    routineFee: PromiseOrValue<BigNumberish>;
    requestsDisabled: PromiseOrValue<boolean>;
    requestFee: PromiseOrValue<BigNumberish>;
    requestsRequireAuthorization: PromiseOrValue<boolean>;
  };

  export type FunctionSettingsStructOutput = [
    BigNumber,
    boolean,
    boolean,
    boolean,
    BigNumber,
    boolean,
    BigNumber,
    boolean
  ] & {
    maxGasCost: BigNumber;
    requireIsolatedRuns: boolean;
    routinesDisabled: boolean;
    routinesRequireAuthorization: boolean;
    routineFee: BigNumber;
    requestsDisabled: boolean;
    requestFee: BigNumber;
    requestsRequireAuthorization: boolean;
  };
}

export declare namespace FunctionVerifyLib {
  export type FunctionFailParamsStruct = {
    enclaveIdx: PromiseOrValue<BigNumberish>;
    functionId: PromiseOrValue<string>;
    observedTime: PromiseOrValue<BigNumberish>;
    nextAllowedTimestamp: PromiseOrValue<BigNumberish>;
    code: PromiseOrValue<BigNumberish>;
    ids: PromiseOrValue<string>[];
    checksums: PromiseOrValue<BytesLike>[];
    codes: PromiseOrValue<BigNumberish>[];
  };

  export type FunctionFailParamsStructOutput = [
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    number,
    string[],
    string[],
    number[]
  ] & {
    enclaveIdx: BigNumber;
    functionId: string;
    observedTime: BigNumber;
    nextAllowedTimestamp: BigNumber;
    code: number;
    ids: string[];
    checksums: string[];
    codes: number[];
  };

  export type FunctionVerifyParamsStruct = {
    enclaveIdx: PromiseOrValue<BigNumberish>;
    functionId: PromiseOrValue<string>;
    delegatedSignerAddress: PromiseOrValue<string>;
    observedTime: PromiseOrValue<BigNumberish>;
    nextAllowedTimestamp: PromiseOrValue<BigNumberish>;
    mrEnclave: PromiseOrValue<BytesLike>;
    transactions: TransactionLib.TransactionStruct[];
    signatures: PromiseOrValue<BytesLike>[];
    ids: PromiseOrValue<string>[];
    checksums: PromiseOrValue<BytesLike>[];
    codes: PromiseOrValue<BigNumberish>[];
  };

  export type FunctionVerifyParamsStructOutput = [
    BigNumber,
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    TransactionLib.TransactionStructOutput[],
    string[],
    string[],
    string[],
    number[]
  ] & {
    enclaveIdx: BigNumber;
    functionId: string;
    delegatedSignerAddress: string;
    observedTime: BigNumber;
    nextAllowedTimestamp: BigNumber;
    mrEnclave: string;
    transactions: TransactionLib.TransactionStructOutput[];
    signatures: string[];
    ids: string[];
    checksums: string[];
    codes: number[];
  };
}

export declare namespace TransactionLib {
  export type TransactionStruct = {
    expirationTimeSeconds: PromiseOrValue<BigNumberish>;
    gasLimit: PromiseOrValue<BigNumberish>;
    value: PromiseOrValue<BigNumberish>;
    to: PromiseOrValue<string>;
    from: PromiseOrValue<string>;
    data: PromiseOrValue<BytesLike>;
  };

  export type TransactionStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    string
  ] & {
    expirationTimeSeconds: BigNumber;
    gasLimit: BigNumber;
    value: BigNumber;
    to: string;
    from: string;
    data: string;
  };
}

export declare namespace OracleLib {
  export type OracleStruct = {
    name: PromiseOrValue<string>;
    signer: PromiseOrValue<string>;
    numRows: PromiseOrValue<BigNumberish>;
    lastHeartbeat: PromiseOrValue<BigNumberish>;
    queueId: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
  };

  export type OracleStructOutput = [
    string,
    string,
    number,
    BigNumber,
    string,
    string
  ] & {
    name: string;
    signer: string;
    numRows: number;
    lastHeartbeat: BigNumber;
    queueId: string;
    authority: string;
  };
}

export declare namespace OracleQueueLib {
  export type OracleQueueStruct = {
    name: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    oracles: PromiseOrValue<string>[];
    unpermissionedFeedsEnabled: PromiseOrValue<boolean>;
    maxSize: PromiseOrValue<BigNumberish>;
    reward: PromiseOrValue<BigNumberish>;
    oracleTimeout: PromiseOrValue<BigNumberish>;
    gcIdx: PromiseOrValue<BigNumberish>;
    currIdx: PromiseOrValue<BigNumberish>;
  };

  export type OracleQueueStructOutput = [
    string,
    string,
    string[],
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    name: string;
    authority: string;
    oracles: string[];
    unpermissionedFeedsEnabled: boolean;
    maxSize: BigNumber;
    reward: BigNumber;
    oracleTimeout: BigNumber;
    gcIdx: BigNumber;
    currIdx: BigNumber;
  };

  export type AttestationConfigStruct = {
    attestationQueueId: PromiseOrValue<string>;
    mrEnclaves: PromiseOrValue<BytesLike>[];
    requireValidEnclave: PromiseOrValue<boolean>;
    requireHeartbeatPermission: PromiseOrValue<boolean>;
  };

  export type AttestationConfigStructOutput = [
    string,
    string[],
    boolean,
    boolean
  ] & {
    attestationQueueId: string;
    mrEnclaves: string[];
    requireValidEnclave: boolean;
    requireHeartbeatPermission: boolean;
  };
}

export declare namespace RequestLib {
  export type RequestStruct = {
    functionId: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    createdAt: PromiseOrValue<BigNumberish>;
    requestData: PromiseOrValue<BytesLike>;
    executed: PromiseOrValue<boolean>;
    consecutiveFailures: PromiseOrValue<BigNumberish>;
    balance: PromiseOrValue<BigNumberish>;
    startAfter: PromiseOrValue<BigNumberish>;
    errorCode: PromiseOrValue<BigNumberish>;
    executedAt: PromiseOrValue<BigNumberish>;
    status: PromiseOrValue<BigNumberish>;
  };

  export type RequestStructOutput = [
    string,
    string,
    BigNumber,
    string,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    BigNumber,
    number
  ] & {
    functionId: string;
    authority: string;
    createdAt: BigNumber;
    requestData: string;
    executed: boolean;
    consecutiveFailures: BigNumber;
    balance: BigNumber;
    startAfter: BigNumber;
    errorCode: number;
    executedAt: BigNumber;
    status: number;
  };
}

export declare namespace RoutineLib {
  export type RoutineStruct = {
    functionId: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    schedule: PromiseOrValue<string>;
    params: PromiseOrValue<BytesLike>;
    lastCalledAt: PromiseOrValue<BigNumberish>;
    consecutiveFailures: PromiseOrValue<BigNumberish>;
    balance: PromiseOrValue<BigNumberish>;
    status: PromiseOrValue<BigNumberish>;
    errorCode: PromiseOrValue<BigNumberish>;
    createdAt: PromiseOrValue<BigNumberish>;
  };

  export type RoutineStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    BigNumber
  ] & {
    functionId: string;
    authority: string;
    schedule: string;
    params: string;
    lastCalledAt: BigNumber;
    consecutiveFailures: BigNumber;
    balance: BigNumber;
    status: number;
    errorCode: number;
    createdAt: BigNumber;
  };
}

export declare namespace FunctionLib {
  export type FunctionConfigStruct = {
    schedule: PromiseOrValue<string>;
    permittedCallers: PromiseOrValue<string>[];
    containerRegistry: PromiseOrValue<string>;
    container: PromiseOrValue<string>;
    version: PromiseOrValue<string>;
    paramsSchema: PromiseOrValue<string>;
    mrEnclaves: PromiseOrValue<BytesLike>[];
    allowAllFnCalls: PromiseOrValue<boolean>;
    useFnCallEscrow: PromiseOrValue<boolean>;
  };

  export type FunctionConfigStructOutput = [
    string,
    string[],
    string,
    string,
    string,
    string,
    string[],
    boolean,
    boolean
  ] & {
    schedule: string;
    permittedCallers: string[];
    containerRegistry: string;
    container: string;
    version: string;
    paramsSchema: string;
    mrEnclaves: string[];
    allowAllFnCalls: boolean;
    useFnCallEscrow: boolean;
  };

  export type FunctionStateStruct = {
    consecutiveFailures: PromiseOrValue<BigNumberish>;
    lastExecutionTimestamp: PromiseOrValue<BigNumberish>;
    nextAllowedTimestamp: PromiseOrValue<BigNumberish>;
    lastExecutionGasCost: PromiseOrValue<BigNumberish>;
    triggeredSince: PromiseOrValue<BigNumberish>;
    triggerCount: PromiseOrValue<BigNumberish>;
    queueIdx: PromiseOrValue<BigNumberish>;
    triggered: PromiseOrValue<boolean>;
    createdAt: PromiseOrValue<BigNumberish>;
  };

  export type FunctionStateStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    BigNumber
  ] & {
    consecutiveFailures: BigNumber;
    lastExecutionTimestamp: BigNumber;
    nextAllowedTimestamp: BigNumber;
    lastExecutionGasCost: BigNumber;
    triggeredSince: BigNumber;
    triggerCount: BigNumber;
    queueIdx: BigNumber;
    triggered: boolean;
    createdAt: BigNumber;
  };

  export type SbFunctionStruct = {
    name: PromiseOrValue<string>;
    authority: PromiseOrValue<string>;
    enclaveId: PromiseOrValue<string>;
    queueId: PromiseOrValue<string>;
    balance: PromiseOrValue<BigNumberish>;
    status: PromiseOrValue<BigNumberish>;
    config: FunctionLib.FunctionConfigStruct;
    state: FunctionLib.FunctionStateStruct;
  };

  export type SbFunctionStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    number,
    FunctionLib.FunctionConfigStructOutput,
    FunctionLib.FunctionStateStructOutput
  ] & {
    name: string;
    authority: string;
    enclaveId: string;
    queueId: string;
    balance: BigNumber;
    status: number;
    config: FunctionLib.FunctionConfigStructOutput;
    state: FunctionLib.FunctionStateStructOutput;
  };
}

export declare namespace StakingLib {
  export type StakeStruct = {
    amount: PromiseOrValue<BigNumberish>;
    readyAt: PromiseOrValue<BigNumberish>;
    unstakeReadyAt: PromiseOrValue<BigNumberish>;
    lastUpdated: PromiseOrValue<BigNumberish>;
    token: PromiseOrValue<string>;
  };

  export type StakeStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string
  ] & {
    amount: BigNumber;
    readyAt: BigNumber;
    unstakeReadyAt: BigNumber;
    lastUpdated: BigNumber;
    token: string;
  };

  export type StakingConfigStruct = {
    token: PromiseOrValue<string>;
    stakingAmount: PromiseOrValue<BigNumberish>;
    stakingPeriod: PromiseOrValue<BigNumberish>;
    unstakingPeriod: PromiseOrValue<BigNumberish>;
  };

  export type StakingConfigStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token: string;
    stakingAmount: BigNumber;
    stakingPeriod: BigNumber;
    unstakingPeriod: BigNumber;
  };
}

export interface SwitchboardInterface extends utils.Interface {
  functions: {
    "initialize()": FunctionFragment;
    "isAdmin(address)": FunctionFragment;
    "isAllowed(address)": FunctionFragment;
    "setAdmin(address,bool)": FunctionFragment;
    "setAllowed(address,bool)": FunctionFragment;
    "aggregatorEscrowFund(address)": FunctionFragment;
    "aggregatorEscrowWithdraw(address,address,uint256)": FunctionFragment;
    "aggregatorHistory(address,uint80)": FunctionFragment;
    "aggregators(address)": FunctionFragment;
    "createAggregator(string,address,uint256,uint256,uint256,string,address,uint256,uint256,uint256,bool)": FunctionFragment;
    "getAggregatorsByAuthority(address)": FunctionFragment;
    "getAllAggregators()": FunctionFragment;
    "getCurrentIntervalId(address)": FunctionFragment;
    "getIntervalResult(address,uint80)": FunctionFragment;
    "latestResult(address)": FunctionFragment;
    "openInterval(address)": FunctionFragment;
    "saveResults(address[],int256[],address,uint256)": FunctionFragment;
    "setAggregatorConfig(address,string,address,uint256,uint256,uint256,string,address,uint256,uint256,uint256,bool)": FunctionFragment;
    "viewAggregatorResults(address)": FunctionFragment;
    "viewLatestResult(address)": FunctionFragment;
    "addMrEnclaveToAttestationQueue(address,bytes32)": FunctionFragment;
    "attestationQueueHasMrEnclave(address,bytes32)": FunctionFragment;
    "attestationQueues(address)": FunctionFragment;
    "createAttestationQueue(address,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256)": FunctionFragment;
    "getAttestationQueueMrEnclaves(address)": FunctionFragment;
    "getEnclaveIdx(address)": FunctionFragment;
    "getEnclaves(address)": FunctionFragment;
    "removeMrEnclaveFromAttestationQueue(address,bytes32)": FunctionFragment;
    "setAttestationQueueConfig(address,address,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256)": FunctionFragment;
    "setAttestationQueuePermission(address,address,uint256,bool)": FunctionFragment;
    "callBalances(address[])": FunctionFragment;
    "verifyCallbackParams(address[],bytes32[])": FunctionFragment;
    "diamondCut((address,uint8,bytes4[])[],address,bytes)": FunctionFragment;
    "facetAddress(bytes4)": FunctionFragment;
    "facetAddresses()": FunctionFragment;
    "facetFunctionSelectors(address)": FunctionFragment;
    "facets()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "owner()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "init()": FunctionFragment;
    "createEnclave(address,address,address)": FunctionFragment;
    "createEnclaveWithId(address,address,address,address)": FunctionFragment;
    "enclaveGarbageCollect(address,uint256)": FunctionFragment;
    "enclaveHeartbeat(address)": FunctionFragment;
    "enclaveSignerToEnclaveId(address)": FunctionFragment;
    "enclaves(address)": FunctionFragment;
    "failEnclave(address,address,uint256)": FunctionFragment;
    "forceOverrideVerify(address)": FunctionFragment;
    "isEnclaveValid(address)": FunctionFragment;
    "rotateEnclaveSigner(address,address)": FunctionFragment;
    "updateEnclave(address,bytes)": FunctionFragment;
    "validate(address,address,bytes32[])": FunctionFragment;
    "verifyEnclave(address,address,uint256,uint256,bytes32)": FunctionFragment;
    "callFunction(address,bytes)": FunctionFragment;
    "functionCallSettings(address)": FunctionFragment;
    "functionCalls(address)": FunctionFragment;
    "getActiveFunctionCallsByQueue(address)": FunctionFragment;
    "setFunctionCallSettings(address,bool,uint256,uint256,bool,bool)": FunctionFragment;
    "functionSettings(address)": FunctionFragment;
    "setFunctionSettings(address,(uint256,bool,bool,bool,uint256,bool,uint256,bool))": FunctionFragment;
    "failFunctionResult((uint256,address,uint256,uint256,uint8,address[],bytes32[],uint8[]))": FunctionFragment;
    "verifyFunctionResult((uint256,address,address,uint256,uint256,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[],address[],bytes32[],uint8[]))": FunctionFragment;
    "createOracle(string,address,address,address)": FunctionFragment;
    "createOracleWithId(address,string,address,address,address)": FunctionFragment;
    "oracleGarbageCollect(address,uint256)": FunctionFragment;
    "oracleHeartbeat(address)": FunctionFragment;
    "oracles(address)": FunctionFragment;
    "rotateOracleSigner(address,address)": FunctionFragment;
    "setOracleConfig(address,string,address,address,address)": FunctionFragment;
    "addMrEnclaveToOracleQueue(address,bytes32)": FunctionFragment;
    "createOracleQueue(string,address,bool,uint256,uint256,uint256)": FunctionFragment;
    "getOracleIdx(address)": FunctionFragment;
    "getOracleQueueAllowedMrEnclaves(address)": FunctionFragment;
    "getOracles(address)": FunctionFragment;
    "oracleQueues(address)": FunctionFragment;
    "queueAttestationConfigs(address)": FunctionFragment;
    "removeMrEnclaveFromOracleQueue(address,bytes32)": FunctionFragment;
    "setOracleQueueAttestationConfig(address,address,bytes32[],bool,bool)": FunctionFragment;
    "setOracleQueueConfig(address,string,address,bool,uint256,uint256,uint256)": FunctionFragment;
    "setOracleQueuePermission(address,address,uint256,bool)": FunctionFragment;
    "getPermission(address,address)": FunctionFragment;
    "hasPermission(address,address,uint256)": FunctionFragment;
    "getActiveRequestsByQueue(address)": FunctionFragment;
    "getRequestsByFunctionId(address)": FunctionFragment;
    "requestFund(address)": FunctionFragment;
    "requestWithdrawal(address,address,uint256)": FunctionFragment;
    "requests(address)": FunctionFragment;
    "sendDelayedRequest(address,address,bytes,uint256)": FunctionFragment;
    "sendRequest(address,bytes)": FunctionFragment;
    "sendRequestWithId(address,address,bytes)": FunctionFragment;
    "createRoutineWithId(address,address,address,bytes,string)": FunctionFragment;
    "getActiveRoutinesByQueue(address)": FunctionFragment;
    "getRoutinesByAuthority(address)": FunctionFragment;
    "getRoutinesByFunctionId(address)": FunctionFragment;
    "routineEscrowFund(address)": FunctionFragment;
    "routineEscrowWithdraw(address,uint256)": FunctionFragment;
    "routineExists(address)": FunctionFragment;
    "routines(address)": FunctionFragment;
    "updateRoutine(address,address,address,bytes,string)": FunctionFragment;
    "createFunction(string,address,address,string,string,string,string,string,address[])": FunctionFragment;
    "createFunctionWithId(address,string,address,address,string,string,string,string,string,address[])": FunctionFragment;
    "forward((uint256,uint256,uint256,address,address,bytes)[],bytes[])": FunctionFragment;
    "functionEscrowFund(address)": FunctionFragment;
    "functionEscrowWithdraw(address,address,uint256)": FunctionFragment;
    "functionVerify(uint256,address,address,uint256,uint256,bool,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[])": FunctionFragment;
    "functionVerifyRequest(uint256,address,address,uint256,uint256,bool,bytes32,(uint256,uint256,uint256,address,address,bytes)[],bytes[],address[])": FunctionFragment;
    "setFunctionConfig(address,string,address,string,string,string,string,string,address[])": FunctionFragment;
    "setFunctionDeactivated(address)": FunctionFragment;
    "setToleratedTimestampDiscrepancy(uint256)": FunctionFragment;
    "addMrEnclaveToFunction(address,bytes32)": FunctionFragment;
    "removeMrEnclaveFromFunction(address,bytes32)": FunctionFragment;
    "estimatedRunCost(address,uint256)": FunctionFragment;
    "funcs(address)": FunctionFragment;
    "functionExists(address)": FunctionFragment;
    "getActiveFunctionsByQueue(address)": FunctionFragment;
    "getAllFunctions()": FunctionFragment;
    "getFunctionMrEnclaves(address)": FunctionFragment;
    "getFunctionPermittedCallers(address)": FunctionFragment;
    "getFunctionsByAuthority(address)": FunctionFragment;
    "getTransactionHash(uint256,uint256,uint256,address,address,bytes)": FunctionFragment;
    "isTrustedForwarder(address)": FunctionFragment;
    "allowance(address,address)": FunctionFragment;
    "approve(address,uint256)": FunctionFragment;
    "balanceOf(address)": FunctionFragment;
    "totalSupply()": FunctionFragment;
    "transfer(address,uint256)": FunctionFragment;
    "transferFrom(address,address,uint256)": FunctionFragment;
    "addStake(address,uint256)": FunctionFragment;
    "getStakeForEnclave(address)": FunctionFragment;
    "getStakeForEnclaveWithToken(address,address)": FunctionFragment;
    "getStakingConfig(address)": FunctionFragment;
    "prepareUnstake(address)": FunctionFragment;
    "recoverStakeWithToken(address,address,uint256)": FunctionFragment;
    "setStakingConfig(address,address,uint256,uint256,uint256)": FunctionFragment;
    "slashStake(address,uint256)": FunctionFragment;
    "totalStaked(address,address)": FunctionFragment;
    "unstake(address,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "initialize"
      | "isAdmin"
      | "isAllowed"
      | "setAdmin"
      | "setAllowed"
      | "aggregatorEscrowFund"
      | "aggregatorEscrowWithdraw"
      | "aggregatorHistory"
      | "aggregators"
      | "createAggregator"
      | "getAggregatorsByAuthority"
      | "getAllAggregators"
      | "getCurrentIntervalId"
      | "getIntervalResult"
      | "latestResult"
      | "openInterval"
      | "saveResults"
      | "setAggregatorConfig"
      | "viewAggregatorResults"
      | "viewLatestResult"
      | "addMrEnclaveToAttestationQueue"
      | "attestationQueueHasMrEnclave"
      | "attestationQueues"
      | "createAttestationQueue"
      | "getAttestationQueueMrEnclaves"
      | "getEnclaveIdx"
      | "getEnclaves"
      | "removeMrEnclaveFromAttestationQueue"
      | "setAttestationQueueConfig"
      | "setAttestationQueuePermission"
      | "callBalances"
      | "verifyCallbackParams"
      | "diamondCut"
      | "facetAddress"
      | "facetAddresses"
      | "facetFunctionSelectors"
      | "facets"
      | "supportsInterface"
      | "owner"
      | "transferOwnership"
      | "init"
      | "createEnclave"
      | "createEnclaveWithId"
      | "enclaveGarbageCollect"
      | "enclaveHeartbeat"
      | "enclaveSignerToEnclaveId"
      | "enclaves"
      | "failEnclave"
      | "forceOverrideVerify"
      | "isEnclaveValid"
      | "rotateEnclaveSigner"
      | "updateEnclave"
      | "validate"
      | "verifyEnclave"
      | "callFunction"
      | "functionCallSettings"
      | "functionCalls"
      | "getActiveFunctionCallsByQueue"
      | "setFunctionCallSettings"
      | "functionSettings"
      | "setFunctionSettings"
      | "failFunctionResult"
      | "verifyFunctionResult"
      | "createOracle"
      | "createOracleWithId"
      | "oracleGarbageCollect"
      | "oracleHeartbeat"
      | "oracles"
      | "rotateOracleSigner"
      | "setOracleConfig"
      | "addMrEnclaveToOracleQueue"
      | "createOracleQueue"
      | "getOracleIdx"
      | "getOracleQueueAllowedMrEnclaves"
      | "getOracles"
      | "oracleQueues"
      | "queueAttestationConfigs"
      | "removeMrEnclaveFromOracleQueue"
      | "setOracleQueueAttestationConfig"
      | "setOracleQueueConfig"
      | "setOracleQueuePermission"
      | "getPermission"
      | "hasPermission"
      | "getActiveRequestsByQueue"
      | "getRequestsByFunctionId"
      | "requestFund"
      | "requestWithdrawal"
      | "requests"
      | "sendDelayedRequest"
      | "sendRequest"
      | "sendRequestWithId"
      | "createRoutineWithId"
      | "getActiveRoutinesByQueue"
      | "getRoutinesByAuthority"
      | "getRoutinesByFunctionId"
      | "routineEscrowFund"
      | "routineEscrowWithdraw"
      | "routineExists"
      | "routines"
      | "updateRoutine"
      | "createFunction"
      | "createFunctionWithId"
      | "forward"
      | "functionEscrowFund"
      | "functionEscrowWithdraw"
      | "functionVerify"
      | "functionVerifyRequest"
      | "setFunctionConfig"
      | "setFunctionDeactivated"
      | "setToleratedTimestampDiscrepancy"
      | "addMrEnclaveToFunction"
      | "removeMrEnclaveFromFunction"
      | "estimatedRunCost"
      | "funcs"
      | "functionExists"
      | "getActiveFunctionsByQueue"
      | "getAllFunctions"
      | "getFunctionMrEnclaves"
      | "getFunctionPermittedCallers"
      | "getFunctionsByAuthority"
      | "getTransactionHash"
      | "isTrustedForwarder"
      | "allowance"
      | "approve"
      | "balanceOf"
      | "totalSupply"
      | "transfer"
      | "transferFrom"
      | "addStake"
      | "getStakeForEnclave"
      | "getStakeForEnclaveWithToken"
      | "getStakingConfig"
      | "prepareUnstake"
      | "recoverStakeWithToken"
      | "setStakingConfig"
      | "slashStake"
      | "totalStaked"
      | "unstake"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "initialize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isAdmin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isAllowed",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setAdmin",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "aggregatorEscrowFund",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "aggregatorEscrowWithdraw",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "aggregatorHistory",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "aggregators",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createAggregator",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAggregatorsByAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllAggregators",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentIntervalId",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getIntervalResult",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "latestResult",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "openInterval",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "saveResults",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setAggregatorConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "viewAggregatorResults",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "viewLatestResult",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addMrEnclaveToAttestationQueue",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "attestationQueueHasMrEnclave",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "attestationQueues",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createAttestationQueue",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAttestationQueueMrEnclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getEnclaveIdx",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getEnclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMrEnclaveFromAttestationQueue",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setAttestationQueueConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setAttestationQueuePermission",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "callBalances",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyCallbackParams",
    values: [PromiseOrValue<string>[], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "diamondCut",
    values: [
      IDiamondCut.FacetCutStruct[],
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "facetAddress",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "facetAddresses",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "facetFunctionSelectors",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "facets", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "init", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "createEnclave",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createEnclaveWithId",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "enclaveGarbageCollect",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "enclaveHeartbeat",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "enclaveSignerToEnclaveId",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "enclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "failEnclave",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceOverrideVerify",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isEnclaveValid",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "rotateEnclaveSigner",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateEnclave",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "validate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyEnclave",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "callFunction",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "functionCallSettings",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "functionCalls",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveFunctionCallsByQueue",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFunctionCallSettings",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "functionSettings",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFunctionSettings",
    values: [PromiseOrValue<string>, FunctionSettingsLib.FunctionSettingsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "failFunctionResult",
    values: [FunctionVerifyLib.FunctionFailParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyFunctionResult",
    values: [FunctionVerifyLib.FunctionVerifyParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "createOracle",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createOracleWithId",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "oracleGarbageCollect",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "oracleHeartbeat",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "oracles",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "rotateOracleSigner",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addMrEnclaveToOracleQueue",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "createOracleQueue",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getOracleIdx",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOracleQueueAllowedMrEnclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOracles",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "oracleQueues",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "queueAttestationConfigs",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMrEnclaveFromOracleQueue",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleQueueAttestationConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleQueueConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracleQueuePermission",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getPermission",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasPermission",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveRequestsByQueue",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRequestsByFunctionId",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "requestFund",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "requestWithdrawal",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "requests",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "sendDelayedRequest",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sendRequest",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "sendRequestWithId",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createRoutineWithId",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveRoutinesByQueue",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoutinesByAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoutinesByFunctionId",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "routineEscrowFund",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "routineEscrowWithdraw",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "routineExists",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "routines",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateRoutine",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createFunction",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createFunctionWithId",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forward",
    values: [TransactionLib.TransactionStruct[], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "functionEscrowFund",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "functionEscrowWithdraw",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "functionVerify",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
      TransactionLib.TransactionStruct[],
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "functionVerifyRequest",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
      TransactionLib.TransactionStruct[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setFunctionConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setFunctionDeactivated",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setToleratedTimestampDiscrepancy",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "addMrEnclaveToFunction",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMrEnclaveFromFunction",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "estimatedRunCost",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "funcs",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "functionExists",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveFunctionsByQueue",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllFunctions",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getFunctionMrEnclaves",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getFunctionPermittedCallers",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getFunctionsByAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTransactionHash",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isTrustedForwarder",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "allowance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addStake",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getStakeForEnclave",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getStakeForEnclaveWithToken",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getStakingConfig",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "prepareUnstake",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "recoverStakeWithToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakingConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "slashStake",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalStaked",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "unstake",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isAdmin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setAdmin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setAllowed", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "aggregatorEscrowFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregatorEscrowWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregatorHistory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAggregator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAggregatorsByAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllAggregators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentIntervalId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getIntervalResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "latestResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openInterval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "saveResults",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAggregatorConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "viewAggregatorResults",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "viewLatestResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addMrEnclaveToAttestationQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attestationQueueHasMrEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attestationQueues",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAttestationQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAttestationQueueMrEnclaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEnclaveIdx",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEnclaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMrEnclaveFromAttestationQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAttestationQueueConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAttestationQueuePermission",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyCallbackParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "diamondCut", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "facetAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "facetAddresses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "facetFunctionSelectors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "facets", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "init", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createEnclaveWithId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enclaveGarbageCollect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enclaveHeartbeat",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enclaveSignerToEnclaveId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "enclaves", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "failEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceOverrideVerify",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isEnclaveValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rotateEnclaveSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "validate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "verifyEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callFunction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "functionCallSettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "functionCalls",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveFunctionCallsByQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFunctionCallSettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "functionSettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFunctionSettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "failFunctionResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyFunctionResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createOracleWithId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oracleGarbageCollect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oracleHeartbeat",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "oracles", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rotateOracleSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addMrEnclaveToOracleQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createOracleQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOracleIdx",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOracleQueueAllowedMrEnclaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOracles", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "oracleQueues",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "queueAttestationConfigs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMrEnclaveFromOracleQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleQueueAttestationConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleQueueConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOracleQueuePermission",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPermission",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasPermission",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveRequestsByQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRequestsByFunctionId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestWithdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "requests", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sendDelayedRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sendRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sendRequestWithId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createRoutineWithId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveRoutinesByQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoutinesByAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoutinesByFunctionId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "routineEscrowFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "routineEscrowWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "routineExists",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "routines", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateRoutine",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFunction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFunctionWithId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "forward", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "functionEscrowFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "functionEscrowWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "functionVerify",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "functionVerifyRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFunctionConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFunctionDeactivated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setToleratedTimestampDiscrepancy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addMrEnclaveToFunction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMrEnclaveFromFunction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimatedRunCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "funcs", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "functionExists",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveFunctionsByQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllFunctions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFunctionMrEnclaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFunctionPermittedCallers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFunctionsByAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTransactionHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTrustedForwarder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addStake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getStakeForEnclave",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakeForEnclaveWithToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakingConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prepareUnstake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recoverStakeWithToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakingConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "slashStake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unstake", data: BytesLike): Result;

  events: {
    "AggregatorAccountInit(address,address,uint256)": EventFragment;
    "AggregatorFundEvent(address,address,uint256)": EventFragment;
    "AggregatorIntervalRefreshed(address,uint256,uint256)": EventFragment;
    "AggregatorOpenInterval(address,uint256)": EventFragment;
    "AggregatorRead(address,address,int256)": EventFragment;
    "AggregatorSaveResult(address,address,int256)": EventFragment;
    "AggregatorSettingsUpdated(address,uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "AggregatorUpdate(address,int256,uint256)": EventFragment;
    "AggregatorWithdrawEvent(address,address,uint256)": EventFragment;
    "OraclePayoutEvent(address,address,uint256)": EventFragment;
    "AddMrEnclave(address,bytes32)": EventFragment;
    "AttestationQueueAccountInit(address,address)": EventFragment;
    "AttestationQueuePermissionUpdated(address,address,address,uint256)": EventFragment;
    "AttestationQueueSetConfig(address,address)": EventFragment;
    "RemoveMrEnclave(address,bytes32)": EventFragment;
    "DiamondCut(tuple[],address,bytes)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "EnclaveAccountInit(address,address)": EventFragment;
    "EnclaveGC(address,address)": EventFragment;
    "EnclaveHeartbeat(address,address)": EventFragment;
    "EnclavePayoutEvent(address,address,uint256)": EventFragment;
    "EnclaveRotateSigner(address,address,address)": EventFragment;
    "EnclaveVerifyRequest(address,address,address)": EventFragment;
    "FunctionCallEvent(address,address,address,bytes)": EventFragment;
    "FunctionCallFund(address,address,uint256)": EventFragment;
    "VerifyFailed(address,address,uint256)": EventFragment;
    "OracleAccountInit(address,address)": EventFragment;
    "OracleGC(address,address)": EventFragment;
    "OracleHeartbeat(address)": EventFragment;
    "OracleRotateSigner(address,address,address)": EventFragment;
    "OracleSetConfig(address,string,address,address,address)": EventFragment;
    "OracleQueueAccountInit(address,address)": EventFragment;
    "OracleQueueAddMrEnclave(address,address,bytes32)": EventFragment;
    "OracleQueueRemoveMrEnclave(address,address,bytes32)": EventFragment;
    "OracleQueueSetAttestationConfig(address,address)": EventFragment;
    "OracleQueueSetConfig(address,address)": EventFragment;
    "OracleQueueSetPermission(address,address,address,uint256)": EventFragment;
    "RequestEvent(address,address,address,bytes)": EventFragment;
    "RequestFund(address,address,uint256)": EventFragment;
    "RequestWithdraw(address,address,uint256)": EventFragment;
    "RoutineCreated(address,address,address,bytes)": EventFragment;
    "RoutineFund(address,address,uint256)": EventFragment;
    "RoutineWithdraw(address,address,uint256)": EventFragment;
    "FunctionAccountInit(address,address)": EventFragment;
    "FunctionFund(address,address,uint256)": EventFragment;
    "FunctionWithdraw(address,address,uint256)": EventFragment;
    "Approval(address,address,uint256)": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
    "StakeAdded(address,address,uint256,address)": EventFragment;
    "StakeRemoved(address,address,uint256,address)": EventFragment;
    "Unstaked(address,address,uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AggregatorAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorFundEvent"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "AggregatorIntervalRefreshed"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorOpenInterval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorRead"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorSaveResult"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorSettingsUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AggregatorWithdrawEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OraclePayoutEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AddMrEnclave"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "AttestationQueueAccountInit"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "AttestationQueuePermissionUpdated"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AttestationQueueSetConfig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveMrEnclave"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DiamondCut"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveGC"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveHeartbeat"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclavePayoutEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveRotateSigner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EnclaveVerifyRequest"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionCallEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionCallFund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VerifyFailed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleGC"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleHeartbeat"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleRotateSigner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleSetConfig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueAddMrEnclave"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueRemoveMrEnclave"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "OracleQueueSetAttestationConfig"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueSetConfig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OracleQueueSetPermission"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RequestEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RequestFund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RequestWithdraw"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoutineCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoutineFund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoutineWithdraw"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionAccountInit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionFund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FunctionWithdraw"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unstaked"): EventFragment;
}

export interface AggregatorAccountInitEventObject {
  authority: string;
  accountId: string;
  timestamp: BigNumber;
}
export type AggregatorAccountInitEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorAccountInitEventObject
>;

export type AggregatorAccountInitEventFilter =
  TypedEventFilter<AggregatorAccountInitEvent>;

export interface AggregatorFundEventEventObject {
  aggregatorId: string;
  funder: string;
  amount: BigNumber;
}
export type AggregatorFundEventEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorFundEventEventObject
>;

export type AggregatorFundEventEventFilter =
  TypedEventFilter<AggregatorFundEventEvent>;

export interface AggregatorIntervalRefreshedEventObject {
  aggregatorId: string;
  intervalId: BigNumber;
  balanceLeftForInterval: BigNumber;
}
export type AggregatorIntervalRefreshedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  AggregatorIntervalRefreshedEventObject
>;

export type AggregatorIntervalRefreshedEventFilter =
  TypedEventFilter<AggregatorIntervalRefreshedEvent>;

export interface AggregatorOpenIntervalEventObject {
  aggregatorId: string;
  intervalId: BigNumber;
}
export type AggregatorOpenIntervalEvent = TypedEvent<
  [string, BigNumber],
  AggregatorOpenIntervalEventObject
>;

export type AggregatorOpenIntervalEventFilter =
  TypedEventFilter<AggregatorOpenIntervalEvent>;

export interface AggregatorReadEventObject {
  aggregatorId: string;
  reader: string;
  value: BigNumber;
}
export type AggregatorReadEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorReadEventObject
>;

export type AggregatorReadEventFilter = TypedEventFilter<AggregatorReadEvent>;

export interface AggregatorSaveResultEventObject {
  aggregatorId: string;
  oracle: string;
  value: BigNumber;
}
export type AggregatorSaveResultEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorSaveResultEventObject
>;

export type AggregatorSaveResultEventFilter =
  TypedEventFilter<AggregatorSaveResultEvent>;

export interface AggregatorSettingsUpdatedEventObject {
  aggregatorId: string;
  minUpdateDelaySeconds: BigNumber;
  minOracleResults: BigNumber;
  varianceThreshold: BigNumber;
  minJobResults: BigNumber;
  forceReportPeriod: BigNumber;
}
export type AggregatorSettingsUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  AggregatorSettingsUpdatedEventObject
>;

export type AggregatorSettingsUpdatedEventFilter =
  TypedEventFilter<AggregatorSettingsUpdatedEvent>;

export interface AggregatorUpdateEventObject {
  aggregatorId: string;
  value: BigNumber;
  timestamp: BigNumber;
}
export type AggregatorUpdateEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  AggregatorUpdateEventObject
>;

export type AggregatorUpdateEventFilter =
  TypedEventFilter<AggregatorUpdateEvent>;

export interface AggregatorWithdrawEventEventObject {
  aggregatorId: string;
  funder: string;
  amount: BigNumber;
}
export type AggregatorWithdrawEventEvent = TypedEvent<
  [string, string, BigNumber],
  AggregatorWithdrawEventEventObject
>;

export type AggregatorWithdrawEventEventFilter =
  TypedEventFilter<AggregatorWithdrawEventEvent>;

export interface OraclePayoutEventEventObject {
  oracleId: string;
  aggregatorId: string;
  amount: BigNumber;
}
export type OraclePayoutEventEvent = TypedEvent<
  [string, string, BigNumber],
  OraclePayoutEventEventObject
>;

export type OraclePayoutEventEventFilter =
  TypedEventFilter<OraclePayoutEventEvent>;

export interface AddMrEnclaveEventObject {
  queueId: string;
  mrEnclave: string;
}
export type AddMrEnclaveEvent = TypedEvent<
  [string, string],
  AddMrEnclaveEventObject
>;

export type AddMrEnclaveEventFilter = TypedEventFilter<AddMrEnclaveEvent>;

export interface AttestationQueueAccountInitEventObject {
  authority: string;
  accountId: string;
}
export type AttestationQueueAccountInitEvent = TypedEvent<
  [string, string],
  AttestationQueueAccountInitEventObject
>;

export type AttestationQueueAccountInitEventFilter =
  TypedEventFilter<AttestationQueueAccountInitEvent>;

export interface AttestationQueuePermissionUpdatedEventObject {
  queueId: string;
  granter: string;
  grantee: string;
  permission: BigNumber;
}
export type AttestationQueuePermissionUpdatedEvent = TypedEvent<
  [string, string, string, BigNumber],
  AttestationQueuePermissionUpdatedEventObject
>;

export type AttestationQueuePermissionUpdatedEventFilter =
  TypedEventFilter<AttestationQueuePermissionUpdatedEvent>;

export interface AttestationQueueSetConfigEventObject {
  queueId: string;
  authority: string;
}
export type AttestationQueueSetConfigEvent = TypedEvent<
  [string, string],
  AttestationQueueSetConfigEventObject
>;

export type AttestationQueueSetConfigEventFilter =
  TypedEventFilter<AttestationQueueSetConfigEvent>;

export interface RemoveMrEnclaveEventObject {
  queueId: string;
  mrEnclave: string;
}
export type RemoveMrEnclaveEvent = TypedEvent<
  [string, string],
  RemoveMrEnclaveEventObject
>;

export type RemoveMrEnclaveEventFilter = TypedEventFilter<RemoveMrEnclaveEvent>;

export interface DiamondCutEventObject {
  _diamondCut: IDiamondCut.FacetCutStructOutput[];
  _init: string;
  _calldata: string;
}
export type DiamondCutEvent = TypedEvent<
  [IDiamondCut.FacetCutStructOutput[], string, string],
  DiamondCutEventObject
>;

export type DiamondCutEventFilter = TypedEventFilter<DiamondCutEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface EnclaveAccountInitEventObject {
  signer: string;
  accountId: string;
}
export type EnclaveAccountInitEvent = TypedEvent<
  [string, string],
  EnclaveAccountInitEventObject
>;

export type EnclaveAccountInitEventFilter =
  TypedEventFilter<EnclaveAccountInitEvent>;

export interface EnclaveGCEventObject {
  enclaveId: string;
  queue: string;
}
export type EnclaveGCEvent = TypedEvent<[string, string], EnclaveGCEventObject>;

export type EnclaveGCEventFilter = TypedEventFilter<EnclaveGCEvent>;

export interface EnclaveHeartbeatEventObject {
  enclaveId: string;
  signer: string;
}
export type EnclaveHeartbeatEvent = TypedEvent<
  [string, string],
  EnclaveHeartbeatEventObject
>;

export type EnclaveHeartbeatEventFilter =
  TypedEventFilter<EnclaveHeartbeatEvent>;

export interface EnclavePayoutEventEventObject {
  nodeId: string;
  enclaveId: string;
  amount: BigNumber;
}
export type EnclavePayoutEventEvent = TypedEvent<
  [string, string, BigNumber],
  EnclavePayoutEventEventObject
>;

export type EnclavePayoutEventEventFilter =
  TypedEventFilter<EnclavePayoutEventEvent>;

export interface EnclaveRotateSignerEventObject {
  queueId: string;
  oldSigner: string;
  newSigner: string;
}
export type EnclaveRotateSignerEvent = TypedEvent<
  [string, string, string],
  EnclaveRotateSignerEventObject
>;

export type EnclaveRotateSignerEventFilter =
  TypedEventFilter<EnclaveRotateSignerEvent>;

export interface EnclaveVerifyRequestEventObject {
  queueId: string;
  verifier: string;
  verifiee: string;
}
export type EnclaveVerifyRequestEvent = TypedEvent<
  [string, string, string],
  EnclaveVerifyRequestEventObject
>;

export type EnclaveVerifyRequestEventFilter =
  TypedEventFilter<EnclaveVerifyRequestEvent>;

export interface FunctionCallEventEventObject {
  functionId: string;
  sender: string;
  callId: string;
  params: string;
}
export type FunctionCallEventEvent = TypedEvent<
  [string, string, string, string],
  FunctionCallEventEventObject
>;

export type FunctionCallEventEventFilter =
  TypedEventFilter<FunctionCallEventEvent>;

export interface FunctionCallFundEventObject {
  functionId: string;
  funder: string;
  amount: BigNumber;
}
export type FunctionCallFundEvent = TypedEvent<
  [string, string, BigNumber],
  FunctionCallFundEventObject
>;

export type FunctionCallFundEventFilter =
  TypedEventFilter<FunctionCallFundEvent>;

export interface VerifyFailedEventObject {
  functionId: string;
  callId: string;
  code: BigNumber;
}
export type VerifyFailedEvent = TypedEvent<
  [string, string, BigNumber],
  VerifyFailedEventObject
>;

export type VerifyFailedEventFilter = TypedEventFilter<VerifyFailedEvent>;

export interface OracleAccountInitEventObject {
  signer: string;
  accountId: string;
}
export type OracleAccountInitEvent = TypedEvent<
  [string, string],
  OracleAccountInitEventObject
>;

export type OracleAccountInitEventFilter =
  TypedEventFilter<OracleAccountInitEvent>;

export interface OracleGCEventObject {
  oracleId: string;
  queueId: string;
}
export type OracleGCEvent = TypedEvent<[string, string], OracleGCEventObject>;

export type OracleGCEventFilter = TypedEventFilter<OracleGCEvent>;

export interface OracleHeartbeatEventObject {
  oracleId: string;
}
export type OracleHeartbeatEvent = TypedEvent<
  [string],
  OracleHeartbeatEventObject
>;

export type OracleHeartbeatEventFilter = TypedEventFilter<OracleHeartbeatEvent>;

export interface OracleRotateSignerEventObject {
  queueId: string;
  oldSigner: string;
  newSigner: string;
}
export type OracleRotateSignerEvent = TypedEvent<
  [string, string, string],
  OracleRotateSignerEventObject
>;

export type OracleRotateSignerEventFilter =
  TypedEventFilter<OracleRotateSignerEvent>;

export interface OracleSetConfigEventObject {
  oracleId: string;
  name: string;
  signer: string;
  queueId: string;
  authority: string;
}
export type OracleSetConfigEvent = TypedEvent<
  [string, string, string, string, string],
  OracleSetConfigEventObject
>;

export type OracleSetConfigEventFilter = TypedEventFilter<OracleSetConfigEvent>;

export interface OracleQueueAccountInitEventObject {
  authority: string;
  accountId: string;
}
export type OracleQueueAccountInitEvent = TypedEvent<
  [string, string],
  OracleQueueAccountInitEventObject
>;

export type OracleQueueAccountInitEventFilter =
  TypedEventFilter<OracleQueueAccountInitEvent>;

export interface OracleQueueAddMrEnclaveEventObject {
  queueId: string;
  attestationQueueId: string;
  mrEnclave: string;
}
export type OracleQueueAddMrEnclaveEvent = TypedEvent<
  [string, string, string],
  OracleQueueAddMrEnclaveEventObject
>;

export type OracleQueueAddMrEnclaveEventFilter =
  TypedEventFilter<OracleQueueAddMrEnclaveEvent>;

export interface OracleQueueRemoveMrEnclaveEventObject {
  queueId: string;
  attestationQueueId: string;
  mrEnclave: string;
}
export type OracleQueueRemoveMrEnclaveEvent = TypedEvent<
  [string, string, string],
  OracleQueueRemoveMrEnclaveEventObject
>;

export type OracleQueueRemoveMrEnclaveEventFilter =
  TypedEventFilter<OracleQueueRemoveMrEnclaveEvent>;

export interface OracleQueueSetAttestationConfigEventObject {
  queueId: string;
  attestationQueueId: string;
}
export type OracleQueueSetAttestationConfigEvent = TypedEvent<
  [string, string],
  OracleQueueSetAttestationConfigEventObject
>;

export type OracleQueueSetAttestationConfigEventFilter =
  TypedEventFilter<OracleQueueSetAttestationConfigEvent>;

export interface OracleQueueSetConfigEventObject {
  queueId: string;
  authority: string;
}
export type OracleQueueSetConfigEvent = TypedEvent<
  [string, string],
  OracleQueueSetConfigEventObject
>;

export type OracleQueueSetConfigEventFilter =
  TypedEventFilter<OracleQueueSetConfigEvent>;

export interface OracleQueueSetPermissionEventObject {
  queueId: string;
  granter: string;
  grantee: string;
  permission: BigNumber;
}
export type OracleQueueSetPermissionEvent = TypedEvent<
  [string, string, string, BigNumber],
  OracleQueueSetPermissionEventObject
>;

export type OracleQueueSetPermissionEventFilter =
  TypedEventFilter<OracleQueueSetPermissionEvent>;

export interface RequestEventEventObject {
  functionId: string;
  sender: string;
  requestId: string;
  params: string;
}
export type RequestEventEvent = TypedEvent<
  [string, string, string, string],
  RequestEventEventObject
>;

export type RequestEventEventFilter = TypedEventFilter<RequestEventEvent>;

export interface RequestFundEventObject {
  functionId: string;
  funder: string;
  amount: BigNumber;
}
export type RequestFundEvent = TypedEvent<
  [string, string, BigNumber],
  RequestFundEventObject
>;

export type RequestFundEventFilter = TypedEventFilter<RequestFundEvent>;

export interface RequestWithdrawEventObject {
  functionId: string;
  funder: string;
  amount: BigNumber;
}
export type RequestWithdrawEvent = TypedEvent<
  [string, string, BigNumber],
  RequestWithdrawEventObject
>;

export type RequestWithdrawEventFilter = TypedEventFilter<RequestWithdrawEvent>;

export interface RoutineCreatedEventObject {
  functionId: string;
  sender: string;
  routineId: string;
  params: string;
}
export type RoutineCreatedEvent = TypedEvent<
  [string, string, string, string],
  RoutineCreatedEventObject
>;

export type RoutineCreatedEventFilter = TypedEventFilter<RoutineCreatedEvent>;

export interface RoutineFundEventObject {
  functionId: string;
  funder: string;
  amount: BigNumber;
}
export type RoutineFundEvent = TypedEvent<
  [string, string, BigNumber],
  RoutineFundEventObject
>;

export type RoutineFundEventFilter = TypedEventFilter<RoutineFundEvent>;

export interface RoutineWithdrawEventObject {
  functionId: string;
  funder: string;
  amount: BigNumber;
}
export type RoutineWithdrawEvent = TypedEvent<
  [string, string, BigNumber],
  RoutineWithdrawEventObject
>;

export type RoutineWithdrawEventFilter = TypedEventFilter<RoutineWithdrawEvent>;

export interface FunctionAccountInitEventObject {
  authority: string;
  accountId: string;
}
export type FunctionAccountInitEvent = TypedEvent<
  [string, string],
  FunctionAccountInitEventObject
>;

export type FunctionAccountInitEventFilter =
  TypedEventFilter<FunctionAccountInitEvent>;

export interface FunctionFundEventObject {
  functionId: string;
  funder: string;
  amount: BigNumber;
}
export type FunctionFundEvent = TypedEvent<
  [string, string, BigNumber],
  FunctionFundEventObject
>;

export type FunctionFundEventFilter = TypedEventFilter<FunctionFundEvent>;

export interface FunctionWithdrawEventObject {
  functionId: string;
  withdrawer: string;
  amount: BigNumber;
}
export type FunctionWithdrawEvent = TypedEvent<
  [string, string, BigNumber],
  FunctionWithdrawEventObject
>;

export type FunctionWithdrawEventFilter =
  TypedEventFilter<FunctionWithdrawEvent>;

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  value: BigNumber;
}
export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber],
  ApprovalEventObject
>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  value: BigNumber;
}
export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  TransferEventObject
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface StakeAddedEventObject {
  queueId: string;
  staker: string;
  amount: BigNumber;
  sender: string;
}
export type StakeAddedEvent = TypedEvent<
  [string, string, BigNumber, string],
  StakeAddedEventObject
>;

export type StakeAddedEventFilter = TypedEventFilter<StakeAddedEvent>;

export interface StakeRemovedEventObject {
  queueId: string;
  staker: string;
  amount: BigNumber;
  sender: string;
}
export type StakeRemovedEvent = TypedEvent<
  [string, string, BigNumber, string],
  StakeRemovedEventObject
>;

export type StakeRemovedEventFilter = TypedEventFilter<StakeRemovedEvent>;

export interface UnstakedEventObject {
  queueId: string;
  staker: string;
  amount: BigNumber;
  sender: string;
}
export type UnstakedEvent = TypedEvent<
  [string, string, BigNumber, string],
  UnstakedEventObject
>;

export type UnstakedEventFilter = TypedEventFilter<UnstakedEvent>;

export interface Switchboard extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SwitchboardInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isAdmin(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isAllowed(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    setAdmin(
      sender: PromiseOrValue<string>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAllowed(
      sender: PromiseOrValue<string>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    aggregatorEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    aggregatorEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      aggregatorId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    aggregatorHistory(
      aggregatorId: PromiseOrValue<string>,
      roundId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[AggregatorLib.AggregatorHistoryResultStructOutput]>;

    aggregators(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[AggregatorLib.AggregatorStructOutput]>;

    createAggregator(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAggregatorsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

    getAllAggregators(
      overrides?: CallOverrides
    ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

    getCurrentIntervalId(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { roundId: BigNumber }>;

    getIntervalResult(
      aggregatorId: PromiseOrValue<string>,
      intervalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    latestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    openInterval(
      aggregatorId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    saveResults(
      ids: PromiseOrValue<string>[],
      results: PromiseOrValue<BigNumberish>[],
      queueId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAggregatorConfig(
      aggregatorId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    viewAggregatorResults(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[AggregatorLib.ResultStructOutput[]]>;

    viewLatestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { value: BigNumber; timestamp: BigNumber }
    >;

    addMrEnclaveToAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    attestationQueueHasMrEnclave(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    attestationQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[AttestationQueueLib.AttestationQueueStructOutput]>;

    createAttestationQueue(
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAttestationQueueMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getEnclaveIdx(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    removeMrEnclaveFromAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAttestationQueueConfig(
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAttestationQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    callBalances(
      callIds: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { balances: BigNumber[] }>;

    verifyCallbackParams(
      callIds: PromiseOrValue<string>[],
      hashes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    diamondCut(
      _diamondCut: IDiamondCut.FacetCutStruct[],
      _init: PromiseOrValue<string>,
      _calldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    facetAddress(
      _functionSelector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { facetAddress_: string }>;

    facetAddresses(
      overrides?: CallOverrides
    ): Promise<[string[]] & { facetAddresses_: string[] }>;

    facetFunctionSelectors(
      _facet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]] & { facetFunctionSelectors_: string[] }>;

    facets(overrides?: CallOverrides): Promise<
      [IDiamondLoupe.FacetStructOutput[]] & {
        facets_: IDiamondLoupe.FacetStructOutput[];
      }
    >;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string] & { owner_: string }>;

    transferOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createEnclave(
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createEnclaveWithId(
      enclaveId: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enclaveGarbageCollect(
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enclaveHeartbeat(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enclaveSignerToEnclaveId(
      signer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    enclaves(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[EnclaveLib.EnclaveStructOutput]>;

    failEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      verifierIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceOverrideVerify(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isEnclaveValid(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    rotateEnclaveSigner(
      enclaveId: PromiseOrValue<string>,
      newSigner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateEnclave(
      enclaveId: PromiseOrValue<string>,
      cid: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    validate(
      signer: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      validMeasurements: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[void]>;

    verifyEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      timestamp: PromiseOrValue<BigNumberish>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    callFunction(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    functionCallSettings(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[FunctionCallLib.FunctionCallSettingsStructOutput]>;

    functionCalls(
      callId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[FunctionCallLib.FunctionCallStructOutput]>;

    getActiveFunctionCallsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionCallLib.FunctionCallStructOutput[]]>;

    setFunctionCallSettings(
      functionId: PromiseOrValue<string>,
      requireEstimatedRunCostFee: PromiseOrValue<boolean>,
      minimumFee: PromiseOrValue<BigNumberish>,
      maxGasCost: PromiseOrValue<BigNumberish>,
      requireCallerPayFullCost: PromiseOrValue<boolean>,
      requireSenderBeReturnAddress: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    functionSettings(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[FunctionSettingsLib.FunctionSettingsStructOutput]>;

    setFunctionSettings(
      functionId: PromiseOrValue<string>,
      settings: FunctionSettingsLib.FunctionSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    failFunctionResult(
      params: FunctionVerifyLib.FunctionFailParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    verifyFunctionResult(
      params: FunctionVerifyLib.FunctionVerifyParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createOracle(
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createOracleWithId(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oracleGarbageCollect(
      oracleId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oracleHeartbeat(
      oracleId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oracles(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[OracleLib.OracleStructOutput]>;

    rotateOracleSigner(
      oracleId: PromiseOrValue<string>,
      newSigner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleConfig(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addMrEnclaveToOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createOracleQueue(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getOracleIdx(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getOracleQueueAllowedMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getOracles(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    oracleQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[OracleQueueLib.OracleQueueStructOutput]>;

    queueAttestationConfigs(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[OracleQueueLib.AttestationConfigStructOutput]>;

    removeMrEnclaveFromOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleQueueAttestationConfig(
      queueId: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      mrEnclaves: PromiseOrValue<BytesLike>[],
      requireValidEnclave: PromiseOrValue<boolean>,
      requireHeartbeatPermission: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleQueueConfig(
      queueId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracleQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    hasPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getActiveRequestsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RequestLib.RequestStructOutput[]]>;

    getRequestsByFunctionId(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RequestLib.RequestStructOutput[]]>;

    requestFund(
      requestId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    requestWithdrawal(
      requestId: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    requests(
      requestId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[RequestLib.RequestStructOutput]>;

    sendDelayedRequest(
      requestId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      startAfter: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    sendRequest(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    sendRequestWithId(
      requestId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createRoutineWithId(
      routineId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getActiveRoutinesByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

    getRoutinesByAuthority(
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

    getRoutinesByFunctionId(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

    routineEscrowFund(
      routineId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    routineEscrowWithdraw(
      routineId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    routineExists(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    routines(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[RoutineLib.RoutineStructOutput]>;

    updateRoutine(
      routineId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createFunction(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createFunctionWithId(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forward(
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    functionEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    functionEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    functionVerify(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    functionVerifyRequest(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      functionCallIds: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFunctionConfig(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFunctionDeactivated(
      functionId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setToleratedTimestampDiscrepancy(
      tolerance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addMrEnclaveToFunction(
      functionId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeMrEnclaveFromFunction(
      functionId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimatedRunCost(
      functionId: PromiseOrValue<string>,
      gasPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    funcs(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[FunctionLib.SbFunctionStructOutput]>;

    functionExists(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getActiveFunctionsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getAllFunctions(
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getFunctionMrEnclaves(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getFunctionPermittedCallers(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getFunctionsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getTransactionHash(
      expirationTimeSeconds: PromiseOrValue<BigNumberish>,
      gasLimit: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    isTrustedForwarder(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    approve(
      spender: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    transfer(
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addStake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getStakeForEnclave(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[StakingLib.StakeStructOutput]>;

    getStakeForEnclaveWithToken(
      enclaveId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[StakingLib.StakeStructOutput]>;

    getStakingConfig(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[StakingLib.StakingConfigStructOutput]>;

    prepareUnstake(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    recoverStakeWithToken(
      enclaveId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakingConfig(
      queueId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      stakingAmount: PromiseOrValue<BigNumberish>,
      stakingPeriod: PromiseOrValue<BigNumberish>,
      unstakingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    slashStake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    totalStaked(
      queueId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    unstake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  initialize(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isAdmin(
    sender: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isAllowed(
    sender: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  setAdmin(
    sender: PromiseOrValue<string>,
    status: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAllowed(
    sender: PromiseOrValue<string>,
    status: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  aggregatorEscrowFund(
    accountId: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  aggregatorEscrowWithdraw(
    recipient: PromiseOrValue<string>,
    aggregatorId: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  aggregatorHistory(
    aggregatorId: PromiseOrValue<string>,
    roundId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<AggregatorLib.AggregatorHistoryResultStructOutput>;

  aggregators(
    aggregatorId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<AggregatorLib.AggregatorStructOutput>;

  createAggregator(
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    batchSize: PromiseOrValue<BigNumberish>,
    minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
    minOracleResults: PromiseOrValue<BigNumberish>,
    jobsHash: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    varianceThreshold: PromiseOrValue<BigNumberish>,
    minJobResults: PromiseOrValue<BigNumberish>,
    forceReportPeriod: PromiseOrValue<BigNumberish>,
    enableHistory: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAggregatorsByAuthority(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

  getAllAggregators(
    overrides?: CallOverrides
  ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

  getCurrentIntervalId(
    aggregatorId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getIntervalResult(
    aggregatorId: PromiseOrValue<string>,
    intervalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  latestResult(
    aggregatorId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  openInterval(
    aggregatorId: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  saveResults(
    ids: PromiseOrValue<string>[],
    results: PromiseOrValue<BigNumberish>[],
    queueId: PromiseOrValue<string>,
    oracleIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAggregatorConfig(
    aggregatorId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    batchSize: PromiseOrValue<BigNumberish>,
    minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
    minOracleResults: PromiseOrValue<BigNumberish>,
    jobsHash: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    varianceThreshold: PromiseOrValue<BigNumberish>,
    minJobResults: PromiseOrValue<BigNumberish>,
    forceReportPeriod: PromiseOrValue<BigNumberish>,
    enableHistory: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  viewAggregatorResults(
    aggregatorId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<AggregatorLib.ResultStructOutput[]>;

  viewLatestResult(
    aggregatorId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { value: BigNumber; timestamp: BigNumber }
  >;

  addMrEnclaveToAttestationQueue(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  attestationQueueHasMrEnclave(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  attestationQueues(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<AttestationQueueLib.AttestationQueueStructOutput>;

  createAttestationQueue(
    authority: PromiseOrValue<string>,
    maxSize: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    enclaveTimeout: PromiseOrValue<BigNumberish>,
    maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
    allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
    requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
    requireUsagePermissions: PromiseOrValue<boolean>,
    maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAttestationQueueMrEnclaves(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getEnclaveIdx(
    enclaveId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getEnclaves(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  removeMrEnclaveFromAttestationQueue(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAttestationQueueConfig(
    queueId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    maxSize: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    enclaveTimeout: PromiseOrValue<BigNumberish>,
    maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
    allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
    requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
    requireUsagePermissions: PromiseOrValue<boolean>,
    maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAttestationQueuePermission(
    queueId: PromiseOrValue<string>,
    grantee: PromiseOrValue<string>,
    permission: PromiseOrValue<BigNumberish>,
    on: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callBalances(
    callIds: PromiseOrValue<string>[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  verifyCallbackParams(
    callIds: PromiseOrValue<string>[],
    hashes: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<void>;

  diamondCut(
    _diamondCut: IDiamondCut.FacetCutStruct[],
    _init: PromiseOrValue<string>,
    _calldata: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  facetAddress(
    _functionSelector: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  facetAddresses(overrides?: CallOverrides): Promise<string[]>;

  facetFunctionSelectors(
    _facet: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  facets(overrides?: CallOverrides): Promise<IDiamondLoupe.FacetStructOutput[]>;

  supportsInterface(
    _interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    _newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  init(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createEnclave(
    signer: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createEnclaveWithId(
    enclaveId: PromiseOrValue<string>,
    signer: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enclaveGarbageCollect(
    enclaveId: PromiseOrValue<string>,
    enclaveIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enclaveHeartbeat(
    enclaveId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enclaveSignerToEnclaveId(
    signer: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  enclaves(
    enclaveId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<EnclaveLib.EnclaveStructOutput>;

  failEnclave(
    verifierId: PromiseOrValue<string>,
    enclaveId: PromiseOrValue<string>,
    verifierIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceOverrideVerify(
    enclaveId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isEnclaveValid(
    enclaveId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  rotateEnclaveSigner(
    enclaveId: PromiseOrValue<string>,
    newSigner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateEnclave(
    enclaveId: PromiseOrValue<string>,
    cid: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  validate(
    signer: PromiseOrValue<string>,
    attestationQueueId: PromiseOrValue<string>,
    validMeasurements: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<void>;

  verifyEnclave(
    verifierId: PromiseOrValue<string>,
    enclaveId: PromiseOrValue<string>,
    enclaveIdx: PromiseOrValue<BigNumberish>,
    timestamp: PromiseOrValue<BigNumberish>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callFunction(
    functionId: PromiseOrValue<string>,
    params: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  functionCallSettings(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FunctionCallLib.FunctionCallSettingsStructOutput>;

  functionCalls(
    callId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FunctionCallLib.FunctionCallStructOutput>;

  getActiveFunctionCallsByQueue(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], FunctionCallLib.FunctionCallStructOutput[]]>;

  setFunctionCallSettings(
    functionId: PromiseOrValue<string>,
    requireEstimatedRunCostFee: PromiseOrValue<boolean>,
    minimumFee: PromiseOrValue<BigNumberish>,
    maxGasCost: PromiseOrValue<BigNumberish>,
    requireCallerPayFullCost: PromiseOrValue<boolean>,
    requireSenderBeReturnAddress: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  functionSettings(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FunctionSettingsLib.FunctionSettingsStructOutput>;

  setFunctionSettings(
    functionId: PromiseOrValue<string>,
    settings: FunctionSettingsLib.FunctionSettingsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  failFunctionResult(
    params: FunctionVerifyLib.FunctionFailParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  verifyFunctionResult(
    params: FunctionVerifyLib.FunctionVerifyParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createOracle(
    name: PromiseOrValue<string>,
    signer: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createOracleWithId(
    oracleId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    signer: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oracleGarbageCollect(
    oracleId: PromiseOrValue<string>,
    oracleIdx: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oracleHeartbeat(
    oracleId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oracles(
    oracleId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<OracleLib.OracleStructOutput>;

  rotateOracleSigner(
    oracleId: PromiseOrValue<string>,
    newSigner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleConfig(
    oracleId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    signer: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addMrEnclaveToOracleQueue(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createOracleQueue(
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
    maxSize: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    oracleTimeout: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getOracleIdx(
    oracleId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getOracleQueueAllowedMrEnclaves(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getOracles(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  oracleQueues(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<OracleQueueLib.OracleQueueStructOutput>;

  queueAttestationConfigs(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<OracleQueueLib.AttestationConfigStructOutput>;

  removeMrEnclaveFromOracleQueue(
    queueId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleQueueAttestationConfig(
    queueId: PromiseOrValue<string>,
    attestationQueueId: PromiseOrValue<string>,
    mrEnclaves: PromiseOrValue<BytesLike>[],
    requireValidEnclave: PromiseOrValue<boolean>,
    requireHeartbeatPermission: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleQueueConfig(
    queueId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
    maxSize: PromiseOrValue<BigNumberish>,
    reward: PromiseOrValue<BigNumberish>,
    oracleTimeout: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracleQueuePermission(
    queueId: PromiseOrValue<string>,
    grantee: PromiseOrValue<string>,
    permission: PromiseOrValue<BigNumberish>,
    on: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getPermission(
    granter: PromiseOrValue<string>,
    grantee: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  hasPermission(
    granter: PromiseOrValue<string>,
    grantee: PromiseOrValue<string>,
    permission: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getActiveRequestsByQueue(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], RequestLib.RequestStructOutput[]]>;

  getRequestsByFunctionId(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], RequestLib.RequestStructOutput[]]>;

  requestFund(
    requestId: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  requestWithdrawal(
    requestId: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  requests(
    requestId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<RequestLib.RequestStructOutput>;

  sendDelayedRequest(
    requestId: PromiseOrValue<string>,
    functionId: PromiseOrValue<string>,
    params: PromiseOrValue<BytesLike>,
    startAfter: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  sendRequest(
    functionId: PromiseOrValue<string>,
    params: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  sendRequestWithId(
    requestId: PromiseOrValue<string>,
    functionId: PromiseOrValue<string>,
    params: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createRoutineWithId(
    routineId: PromiseOrValue<string>,
    functionId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    params: PromiseOrValue<BytesLike>,
    schedule: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getActiveRoutinesByQueue(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

  getRoutinesByAuthority(
    authority: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

  getRoutinesByFunctionId(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

  routineEscrowFund(
    routineId: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  routineEscrowWithdraw(
    routineId: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  routineExists(
    routineId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  routines(
    routineId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<RoutineLib.RoutineStructOutput>;

  updateRoutine(
    routineId: PromiseOrValue<string>,
    functionId: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    params: PromiseOrValue<BytesLike>,
    schedule: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createFunction(
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    containerRegistry: PromiseOrValue<string>,
    container: PromiseOrValue<string>,
    version: PromiseOrValue<string>,
    schedule: PromiseOrValue<string>,
    paramsSchema: PromiseOrValue<string>,
    permittedCallers: PromiseOrValue<string>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createFunctionWithId(
    functionId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    queueId: PromiseOrValue<string>,
    containerRegistry: PromiseOrValue<string>,
    container: PromiseOrValue<string>,
    version: PromiseOrValue<string>,
    schedule: PromiseOrValue<string>,
    paramsSchema: PromiseOrValue<string>,
    permittedCallers: PromiseOrValue<string>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forward(
    transactions: TransactionLib.TransactionStruct[],
    signatures: PromiseOrValue<BytesLike>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  functionEscrowFund(
    accountId: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  functionEscrowWithdraw(
    recipient: PromiseOrValue<string>,
    functionId: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  functionVerify(
    enclaveIdx: PromiseOrValue<BigNumberish>,
    functionId: PromiseOrValue<string>,
    delegatedSignerAddress: PromiseOrValue<string>,
    observedTime: PromiseOrValue<BigNumberish>,
    nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
    isFailure: PromiseOrValue<boolean>,
    mrEnclave: PromiseOrValue<BytesLike>,
    transactions: TransactionLib.TransactionStruct[],
    signatures: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  functionVerifyRequest(
    enclaveIdx: PromiseOrValue<BigNumberish>,
    functionId: PromiseOrValue<string>,
    delegatedSignerAddress: PromiseOrValue<string>,
    observedTime: PromiseOrValue<BigNumberish>,
    nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
    isFailure: PromiseOrValue<boolean>,
    mrEnclave: PromiseOrValue<BytesLike>,
    transactions: TransactionLib.TransactionStruct[],
    signatures: PromiseOrValue<BytesLike>[],
    functionCallIds: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFunctionConfig(
    functionId: PromiseOrValue<string>,
    name: PromiseOrValue<string>,
    authority: PromiseOrValue<string>,
    containerRegistry: PromiseOrValue<string>,
    container: PromiseOrValue<string>,
    version: PromiseOrValue<string>,
    schedule: PromiseOrValue<string>,
    paramsSchema: PromiseOrValue<string>,
    permittedCallers: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFunctionDeactivated(
    functionId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setToleratedTimestampDiscrepancy(
    tolerance: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addMrEnclaveToFunction(
    functionId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeMrEnclaveFromFunction(
    functionId: PromiseOrValue<string>,
    mrEnclave: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimatedRunCost(
    functionId: PromiseOrValue<string>,
    gasPrice: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  funcs(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FunctionLib.SbFunctionStructOutput>;

  functionExists(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getActiveFunctionsByQueue(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

  getAllFunctions(
    overrides?: CallOverrides
  ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

  getFunctionMrEnclaves(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getFunctionPermittedCallers(
    functionId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getFunctionsByAuthority(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

  getTransactionHash(
    expirationTimeSeconds: PromiseOrValue<BigNumberish>,
    gasLimit: PromiseOrValue<BigNumberish>,
    value: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  isTrustedForwarder(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  allowance(
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  approve(
    spender: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  balanceOf(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  transfer(
    to: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addStake(
    enclaveId: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getStakeForEnclave(
    enclaveId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<StakingLib.StakeStructOutput>;

  getStakeForEnclaveWithToken(
    enclaveId: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<StakingLib.StakeStructOutput>;

  getStakingConfig(
    queueId: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<StakingLib.StakingConfigStructOutput>;

  prepareUnstake(
    enclaveId: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  recoverStakeWithToken(
    enclaveId: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakingConfig(
    queueId: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    stakingAmount: PromiseOrValue<BigNumberish>,
    stakingPeriod: PromiseOrValue<BigNumberish>,
    unstakingPeriod: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  slashStake(
    enclaveId: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  totalStaked(
    queueId: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  unstake(
    enclaveId: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    initialize(overrides?: CallOverrides): Promise<void>;

    isAdmin(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isAllowed(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setAdmin(
      sender: PromiseOrValue<string>,
      status: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setAllowed(
      sender: PromiseOrValue<string>,
      status: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    aggregatorEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    aggregatorEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      aggregatorId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    aggregatorHistory(
      aggregatorId: PromiseOrValue<string>,
      roundId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<AggregatorLib.AggregatorHistoryResultStructOutput>;

    aggregators(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<AggregatorLib.AggregatorStructOutput>;

    createAggregator(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAggregatorsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

    getAllAggregators(
      overrides?: CallOverrides
    ): Promise<[string[], AggregatorLib.AggregatorStructOutput[]]>;

    getCurrentIntervalId(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIntervalResult(
      aggregatorId: PromiseOrValue<string>,
      intervalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        value: BigNumber;
        timestamp: BigNumber;
        medianTimestamp: BigNumber;
      }
    >;

    latestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { value: BigNumber; timestamp: BigNumber }
    >;

    openInterval(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    saveResults(
      ids: PromiseOrValue<string>[],
      results: PromiseOrValue<BigNumberish>[],
      queueId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setAggregatorConfig(
      aggregatorId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    viewAggregatorResults(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<AggregatorLib.ResultStructOutput[]>;

    viewLatestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { value: BigNumber; timestamp: BigNumber }
    >;

    addMrEnclaveToAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    attestationQueueHasMrEnclave(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    attestationQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<AttestationQueueLib.AttestationQueueStructOutput>;

    createAttestationQueue(
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAttestationQueueMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getEnclaveIdx(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    removeMrEnclaveFromAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setAttestationQueueConfig(
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setAttestationQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    callBalances(
      callIds: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    verifyCallbackParams(
      callIds: PromiseOrValue<string>[],
      hashes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    diamondCut(
      _diamondCut: IDiamondCut.FacetCutStruct[],
      _init: PromiseOrValue<string>,
      _calldata: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    facetAddress(
      _functionSelector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    facetAddresses(overrides?: CallOverrides): Promise<string[]>;

    facetFunctionSelectors(
      _facet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    facets(
      overrides?: CallOverrides
    ): Promise<IDiamondLoupe.FacetStructOutput[]>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    transferOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    init(overrides?: CallOverrides): Promise<void>;

    createEnclave(
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    createEnclaveWithId(
      enclaveId: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    enclaveGarbageCollect(
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    enclaveHeartbeat(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    enclaveSignerToEnclaveId(
      signer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    enclaves(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<EnclaveLib.EnclaveStructOutput>;

    failEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      verifierIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceOverrideVerify(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    isEnclaveValid(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    rotateEnclaveSigner(
      enclaveId: PromiseOrValue<string>,
      newSigner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateEnclave(
      enclaveId: PromiseOrValue<string>,
      cid: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    validate(
      signer: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      validMeasurements: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    verifyEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      timestamp: PromiseOrValue<BigNumberish>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    callFunction(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    functionCallSettings(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FunctionCallLib.FunctionCallSettingsStructOutput>;

    functionCalls(
      callId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FunctionCallLib.FunctionCallStructOutput>;

    getActiveFunctionCallsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionCallLib.FunctionCallStructOutput[]]>;

    setFunctionCallSettings(
      functionId: PromiseOrValue<string>,
      requireEstimatedRunCostFee: PromiseOrValue<boolean>,
      minimumFee: PromiseOrValue<BigNumberish>,
      maxGasCost: PromiseOrValue<BigNumberish>,
      requireCallerPayFullCost: PromiseOrValue<boolean>,
      requireSenderBeReturnAddress: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    functionSettings(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FunctionSettingsLib.FunctionSettingsStructOutput>;

    setFunctionSettings(
      functionId: PromiseOrValue<string>,
      settings: FunctionSettingsLib.FunctionSettingsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    failFunctionResult(
      params: FunctionVerifyLib.FunctionFailParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    verifyFunctionResult(
      params: FunctionVerifyLib.FunctionVerifyParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    createOracle(
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    createOracleWithId(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    oracleGarbageCollect(
      oracleId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    oracleHeartbeat(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    oracles(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<OracleLib.OracleStructOutput>;

    rotateOracleSigner(
      oracleId: PromiseOrValue<string>,
      newSigner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleConfig(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addMrEnclaveToOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    createOracleQueue(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getOracleIdx(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOracleQueueAllowedMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getOracles(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    oracleQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<OracleQueueLib.OracleQueueStructOutput>;

    queueAttestationConfigs(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<OracleQueueLib.AttestationConfigStructOutput>;

    removeMrEnclaveFromOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleQueueAttestationConfig(
      queueId: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      mrEnclaves: PromiseOrValue<BytesLike>[],
      requireValidEnclave: PromiseOrValue<boolean>,
      requireHeartbeatPermission: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleQueueConfig(
      queueId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracleQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    getPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getActiveRequestsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RequestLib.RequestStructOutput[]]>;

    getRequestsByFunctionId(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RequestLib.RequestStructOutput[]]>;

    requestFund(
      requestId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    requestWithdrawal(
      requestId: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    requests(
      requestId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<RequestLib.RequestStructOutput>;

    sendDelayedRequest(
      requestId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      startAfter: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    sendRequest(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    sendRequestWithId(
      requestId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    createRoutineWithId(
      routineId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    getActiveRoutinesByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

    getRoutinesByAuthority(
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

    getRoutinesByFunctionId(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], RoutineLib.RoutineStructOutput[]]>;

    routineEscrowFund(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    routineEscrowWithdraw(
      routineId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    routineExists(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    routines(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<RoutineLib.RoutineStructOutput>;

    updateRoutine(
      routineId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    createFunction(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    createFunctionWithId(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    forward(
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    functionEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    functionEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    functionVerify(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    functionVerifyRequest(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      functionCallIds: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setFunctionConfig(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setFunctionDeactivated(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setToleratedTimestampDiscrepancy(
      tolerance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    addMrEnclaveToFunction(
      functionId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeMrEnclaveFromFunction(
      functionId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    estimatedRunCost(
      functionId: PromiseOrValue<string>,
      gasPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    funcs(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FunctionLib.SbFunctionStructOutput>;

    functionExists(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getActiveFunctionsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getAllFunctions(
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getFunctionMrEnclaves(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getFunctionPermittedCallers(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getFunctionsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], FunctionLib.SbFunctionStructOutput[]]>;

    getTransactionHash(
      expirationTimeSeconds: PromiseOrValue<BigNumberish>,
      gasLimit: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    isTrustedForwarder(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    approve(
      spender: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    addStake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getStakeForEnclave(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<StakingLib.StakeStructOutput>;

    getStakeForEnclaveWithToken(
      enclaveId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<StakingLib.StakeStructOutput>;

    getStakingConfig(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<StakingLib.StakingConfigStructOutput>;

    prepareUnstake(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    recoverStakeWithToken(
      enclaveId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakingConfig(
      queueId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      stakingAmount: PromiseOrValue<BigNumberish>,
      stakingPeriod: PromiseOrValue<BigNumberish>,
      unstakingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    slashStake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    totalStaked(
      queueId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unstake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AggregatorAccountInit(address,address,uint256)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null,
      timestamp?: null
    ): AggregatorAccountInitEventFilter;
    AggregatorAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null,
      timestamp?: null
    ): AggregatorAccountInitEventFilter;

    "AggregatorFundEvent(address,address,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): AggregatorFundEventEventFilter;
    AggregatorFundEvent(
      aggregatorId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): AggregatorFundEventEventFilter;

    "AggregatorIntervalRefreshed(address,uint256,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      intervalId?: PromiseOrValue<BigNumberish> | null,
      balanceLeftForInterval?: PromiseOrValue<BigNumberish> | null
    ): AggregatorIntervalRefreshedEventFilter;
    AggregatorIntervalRefreshed(
      aggregatorId?: PromiseOrValue<string> | null,
      intervalId?: PromiseOrValue<BigNumberish> | null,
      balanceLeftForInterval?: PromiseOrValue<BigNumberish> | null
    ): AggregatorIntervalRefreshedEventFilter;

    "AggregatorOpenInterval(address,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      intervalId?: PromiseOrValue<BigNumberish> | null
    ): AggregatorOpenIntervalEventFilter;
    AggregatorOpenInterval(
      aggregatorId?: PromiseOrValue<string> | null,
      intervalId?: PromiseOrValue<BigNumberish> | null
    ): AggregatorOpenIntervalEventFilter;

    "AggregatorRead(address,address,int256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      reader?: PromiseOrValue<string> | null,
      value?: null
    ): AggregatorReadEventFilter;
    AggregatorRead(
      aggregatorId?: PromiseOrValue<string> | null,
      reader?: PromiseOrValue<string> | null,
      value?: null
    ): AggregatorReadEventFilter;

    "AggregatorSaveResult(address,address,int256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      oracle?: PromiseOrValue<string> | null,
      value?: PromiseOrValue<BigNumberish> | null
    ): AggregatorSaveResultEventFilter;
    AggregatorSaveResult(
      aggregatorId?: PromiseOrValue<string> | null,
      oracle?: PromiseOrValue<string> | null,
      value?: PromiseOrValue<BigNumberish> | null
    ): AggregatorSaveResultEventFilter;

    "AggregatorSettingsUpdated(address,uint256,uint256,uint256,uint256,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      minUpdateDelaySeconds?: null,
      minOracleResults?: null,
      varianceThreshold?: null,
      minJobResults?: null,
      forceReportPeriod?: null
    ): AggregatorSettingsUpdatedEventFilter;
    AggregatorSettingsUpdated(
      aggregatorId?: PromiseOrValue<string> | null,
      minUpdateDelaySeconds?: null,
      minOracleResults?: null,
      varianceThreshold?: null,
      minJobResults?: null,
      forceReportPeriod?: null
    ): AggregatorSettingsUpdatedEventFilter;

    "AggregatorUpdate(address,int256,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      value?: PromiseOrValue<BigNumberish> | null,
      timestamp?: null
    ): AggregatorUpdateEventFilter;
    AggregatorUpdate(
      aggregatorId?: PromiseOrValue<string> | null,
      value?: PromiseOrValue<BigNumberish> | null,
      timestamp?: null
    ): AggregatorUpdateEventFilter;

    "AggregatorWithdrawEvent(address,address,uint256)"(
      aggregatorId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): AggregatorWithdrawEventEventFilter;
    AggregatorWithdrawEvent(
      aggregatorId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): AggregatorWithdrawEventEventFilter;

    "OraclePayoutEvent(address,address,uint256)"(
      oracleId?: PromiseOrValue<string> | null,
      aggregatorId?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): OraclePayoutEventEventFilter;
    OraclePayoutEvent(
      oracleId?: PromiseOrValue<string> | null,
      aggregatorId?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): OraclePayoutEventEventFilter;

    "AddMrEnclave(address,bytes32)"(
      queueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): AddMrEnclaveEventFilter;
    AddMrEnclave(
      queueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): AddMrEnclaveEventFilter;

    "AttestationQueueAccountInit(address,address)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): AttestationQueueAccountInitEventFilter;
    AttestationQueueAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): AttestationQueueAccountInitEventFilter;

    "AttestationQueuePermissionUpdated(address,address,address,uint256)"(
      queueId?: PromiseOrValue<string> | null,
      granter?: PromiseOrValue<string> | null,
      grantee?: PromiseOrValue<string> | null,
      permission?: null
    ): AttestationQueuePermissionUpdatedEventFilter;
    AttestationQueuePermissionUpdated(
      queueId?: PromiseOrValue<string> | null,
      granter?: PromiseOrValue<string> | null,
      grantee?: PromiseOrValue<string> | null,
      permission?: null
    ): AttestationQueuePermissionUpdatedEventFilter;

    "AttestationQueueSetConfig(address,address)"(
      queueId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): AttestationQueueSetConfigEventFilter;
    AttestationQueueSetConfig(
      queueId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): AttestationQueueSetConfigEventFilter;

    "RemoveMrEnclave(address,bytes32)"(
      queueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): RemoveMrEnclaveEventFilter;
    RemoveMrEnclave(
      queueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): RemoveMrEnclaveEventFilter;

    "DiamondCut(tuple[],address,bytes)"(
      _diamondCut?: null,
      _init?: null,
      _calldata?: null
    ): DiamondCutEventFilter;
    DiamondCut(
      _diamondCut?: null,
      _init?: null,
      _calldata?: null
    ): DiamondCutEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "EnclaveAccountInit(address,address)"(
      signer?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): EnclaveAccountInitEventFilter;
    EnclaveAccountInit(
      signer?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): EnclaveAccountInitEventFilter;

    "EnclaveGC(address,address)"(
      enclaveId?: PromiseOrValue<string> | null,
      queue?: PromiseOrValue<string> | null
    ): EnclaveGCEventFilter;
    EnclaveGC(
      enclaveId?: PromiseOrValue<string> | null,
      queue?: PromiseOrValue<string> | null
    ): EnclaveGCEventFilter;

    "EnclaveHeartbeat(address,address)"(
      enclaveId?: PromiseOrValue<string> | null,
      signer?: PromiseOrValue<string> | null
    ): EnclaveHeartbeatEventFilter;
    EnclaveHeartbeat(
      enclaveId?: PromiseOrValue<string> | null,
      signer?: PromiseOrValue<string> | null
    ): EnclaveHeartbeatEventFilter;

    "EnclavePayoutEvent(address,address,uint256)"(
      nodeId?: PromiseOrValue<string> | null,
      enclaveId?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): EnclavePayoutEventEventFilter;
    EnclavePayoutEvent(
      nodeId?: PromiseOrValue<string> | null,
      enclaveId?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): EnclavePayoutEventEventFilter;

    "EnclaveRotateSigner(address,address,address)"(
      queueId?: PromiseOrValue<string> | null,
      oldSigner?: PromiseOrValue<string> | null,
      newSigner?: PromiseOrValue<string> | null
    ): EnclaveRotateSignerEventFilter;
    EnclaveRotateSigner(
      queueId?: PromiseOrValue<string> | null,
      oldSigner?: PromiseOrValue<string> | null,
      newSigner?: PromiseOrValue<string> | null
    ): EnclaveRotateSignerEventFilter;

    "EnclaveVerifyRequest(address,address,address)"(
      queueId?: PromiseOrValue<string> | null,
      verifier?: PromiseOrValue<string> | null,
      verifiee?: PromiseOrValue<string> | null
    ): EnclaveVerifyRequestEventFilter;
    EnclaveVerifyRequest(
      queueId?: PromiseOrValue<string> | null,
      verifier?: PromiseOrValue<string> | null,
      verifiee?: PromiseOrValue<string> | null
    ): EnclaveVerifyRequestEventFilter;

    "FunctionCallEvent(address,address,address,bytes)"(
      functionId?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      callId?: PromiseOrValue<string> | null,
      params?: null
    ): FunctionCallEventEventFilter;
    FunctionCallEvent(
      functionId?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      callId?: PromiseOrValue<string> | null,
      params?: null
    ): FunctionCallEventEventFilter;

    "FunctionCallFund(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionCallFundEventFilter;
    FunctionCallFund(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionCallFundEventFilter;

    "VerifyFailed(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      callId?: PromiseOrValue<string> | null,
      code?: PromiseOrValue<BigNumberish> | null
    ): VerifyFailedEventFilter;
    VerifyFailed(
      functionId?: PromiseOrValue<string> | null,
      callId?: PromiseOrValue<string> | null,
      code?: PromiseOrValue<BigNumberish> | null
    ): VerifyFailedEventFilter;

    "OracleAccountInit(address,address)"(
      signer?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): OracleAccountInitEventFilter;
    OracleAccountInit(
      signer?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): OracleAccountInitEventFilter;

    "OracleGC(address,address)"(
      oracleId?: PromiseOrValue<string> | null,
      queueId?: PromiseOrValue<string> | null
    ): OracleGCEventFilter;
    OracleGC(
      oracleId?: PromiseOrValue<string> | null,
      queueId?: PromiseOrValue<string> | null
    ): OracleGCEventFilter;

    "OracleHeartbeat(address)"(
      oracleId?: PromiseOrValue<string> | null
    ): OracleHeartbeatEventFilter;
    OracleHeartbeat(
      oracleId?: PromiseOrValue<string> | null
    ): OracleHeartbeatEventFilter;

    "OracleRotateSigner(address,address,address)"(
      queueId?: PromiseOrValue<string> | null,
      oldSigner?: PromiseOrValue<string> | null,
      newSigner?: PromiseOrValue<string> | null
    ): OracleRotateSignerEventFilter;
    OracleRotateSigner(
      queueId?: PromiseOrValue<string> | null,
      oldSigner?: PromiseOrValue<string> | null,
      newSigner?: PromiseOrValue<string> | null
    ): OracleRotateSignerEventFilter;

    "OracleSetConfig(address,string,address,address,address)"(
      oracleId?: PromiseOrValue<string> | null,
      name?: null,
      signer?: PromiseOrValue<string> | null,
      queueId?: PromiseOrValue<string> | null,
      authority?: null
    ): OracleSetConfigEventFilter;
    OracleSetConfig(
      oracleId?: PromiseOrValue<string> | null,
      name?: null,
      signer?: PromiseOrValue<string> | null,
      queueId?: PromiseOrValue<string> | null,
      authority?: null
    ): OracleSetConfigEventFilter;

    "OracleQueueAccountInit(address,address)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): OracleQueueAccountInitEventFilter;
    OracleQueueAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): OracleQueueAccountInitEventFilter;

    "OracleQueueAddMrEnclave(address,address,bytes32)"(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): OracleQueueAddMrEnclaveEventFilter;
    OracleQueueAddMrEnclave(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): OracleQueueAddMrEnclaveEventFilter;

    "OracleQueueRemoveMrEnclave(address,address,bytes32)"(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): OracleQueueRemoveMrEnclaveEventFilter;
    OracleQueueRemoveMrEnclave(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null,
      mrEnclave?: null
    ): OracleQueueRemoveMrEnclaveEventFilter;

    "OracleQueueSetAttestationConfig(address,address)"(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null
    ): OracleQueueSetAttestationConfigEventFilter;
    OracleQueueSetAttestationConfig(
      queueId?: PromiseOrValue<string> | null,
      attestationQueueId?: PromiseOrValue<string> | null
    ): OracleQueueSetAttestationConfigEventFilter;

    "OracleQueueSetConfig(address,address)"(
      queueId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): OracleQueueSetConfigEventFilter;
    OracleQueueSetConfig(
      queueId?: PromiseOrValue<string> | null,
      authority?: PromiseOrValue<string> | null
    ): OracleQueueSetConfigEventFilter;

    "OracleQueueSetPermission(address,address,address,uint256)"(
      queueId?: PromiseOrValue<string> | null,
      granter?: PromiseOrValue<string> | null,
      grantee?: PromiseOrValue<string> | null,
      permission?: null
    ): OracleQueueSetPermissionEventFilter;
    OracleQueueSetPermission(
      queueId?: PromiseOrValue<string> | null,
      granter?: PromiseOrValue<string> | null,
      grantee?: PromiseOrValue<string> | null,
      permission?: null
    ): OracleQueueSetPermissionEventFilter;

    "RequestEvent(address,address,address,bytes)"(
      functionId?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      requestId?: PromiseOrValue<string> | null,
      params?: null
    ): RequestEventEventFilter;
    RequestEvent(
      functionId?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      requestId?: PromiseOrValue<string> | null,
      params?: null
    ): RequestEventEventFilter;

    "RequestFund(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: null
    ): RequestFundEventFilter;
    RequestFund(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: null
    ): RequestFundEventFilter;

    "RequestWithdraw(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: null
    ): RequestWithdrawEventFilter;
    RequestWithdraw(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: null
    ): RequestWithdrawEventFilter;

    "RoutineCreated(address,address,address,bytes)"(
      functionId?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      routineId?: PromiseOrValue<string> | null,
      params?: null
    ): RoutineCreatedEventFilter;
    RoutineCreated(
      functionId?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      routineId?: PromiseOrValue<string> | null,
      params?: null
    ): RoutineCreatedEventFilter;

    "RoutineFund(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: null
    ): RoutineFundEventFilter;
    RoutineFund(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: null
    ): RoutineFundEventFilter;

    "RoutineWithdraw(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: null
    ): RoutineWithdrawEventFilter;
    RoutineWithdraw(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: null
    ): RoutineWithdrawEventFilter;

    "FunctionAccountInit(address,address)"(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): FunctionAccountInitEventFilter;
    FunctionAccountInit(
      authority?: PromiseOrValue<string> | null,
      accountId?: PromiseOrValue<string> | null
    ): FunctionAccountInitEventFilter;

    "FunctionFund(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionFundEventFilter;
    FunctionFund(
      functionId?: PromiseOrValue<string> | null,
      funder?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionFundEventFilter;

    "FunctionWithdraw(address,address,uint256)"(
      functionId?: PromiseOrValue<string> | null,
      withdrawer?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionWithdrawEventFilter;
    FunctionWithdraw(
      functionId?: PromiseOrValue<string> | null,
      withdrawer?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): FunctionWithdrawEventFilter;

    "Approval(address,address,uint256)"(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null
    ): ApprovalEventFilter;

    "Transfer(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null
    ): TransferEventFilter;

    "StakeAdded(address,address,uint256,address)"(
      queueId?: PromiseOrValue<string> | null,
      staker?: PromiseOrValue<string> | null,
      amount?: null,
      sender?: null
    ): StakeAddedEventFilter;
    StakeAdded(
      queueId?: PromiseOrValue<string> | null,
      staker?: PromiseOrValue<string> | null,
      amount?: null,
      sender?: null
    ): StakeAddedEventFilter;

    "StakeRemoved(address,address,uint256,address)"(
      queueId?: PromiseOrValue<string> | null,
      staker?: PromiseOrValue<string> | null,
      amount?: null,
      sender?: null
    ): StakeRemovedEventFilter;
    StakeRemoved(
      queueId?: PromiseOrValue<string> | null,
      staker?: PromiseOrValue<string> | null,
      amount?: null,
      sender?: null
    ): StakeRemovedEventFilter;

    "Unstaked(address,address,uint256,address)"(
      queueId?: PromiseOrValue<string> | null,
      staker?: PromiseOrValue<string> | null,
      amount?: null,
      sender?: null
    ): UnstakedEventFilter;
    Unstaked(
      queueId?: PromiseOrValue<string> | null,
      staker?: PromiseOrValue<string> | null,
      amount?: null,
      sender?: null
    ): UnstakedEventFilter;
  };

  estimateGas: {
    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isAdmin(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isAllowed(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setAdmin(
      sender: PromiseOrValue<string>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAllowed(
      sender: PromiseOrValue<string>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    aggregatorEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    aggregatorEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      aggregatorId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    aggregatorHistory(
      aggregatorId: PromiseOrValue<string>,
      roundId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    aggregators(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createAggregator(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAggregatorsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllAggregators(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentIntervalId(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIntervalResult(
      aggregatorId: PromiseOrValue<string>,
      intervalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    latestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    openInterval(
      aggregatorId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    saveResults(
      ids: PromiseOrValue<string>[],
      results: PromiseOrValue<BigNumberish>[],
      queueId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAggregatorConfig(
      aggregatorId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    viewAggregatorResults(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    viewLatestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addMrEnclaveToAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    attestationQueueHasMrEnclave(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    attestationQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createAttestationQueue(
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAttestationQueueMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEnclaveIdx(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeMrEnclaveFromAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAttestationQueueConfig(
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAttestationQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    callBalances(
      callIds: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyCallbackParams(
      callIds: PromiseOrValue<string>[],
      hashes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    diamondCut(
      _diamondCut: IDiamondCut.FacetCutStruct[],
      _init: PromiseOrValue<string>,
      _calldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    facetAddress(
      _functionSelector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    facetAddresses(overrides?: CallOverrides): Promise<BigNumber>;

    facetFunctionSelectors(
      _facet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    facets(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createEnclave(
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createEnclaveWithId(
      enclaveId: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enclaveGarbageCollect(
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enclaveHeartbeat(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enclaveSignerToEnclaveId(
      signer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    enclaves(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    failEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      verifierIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceOverrideVerify(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isEnclaveValid(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rotateEnclaveSigner(
      enclaveId: PromiseOrValue<string>,
      newSigner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateEnclave(
      enclaveId: PromiseOrValue<string>,
      cid: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    validate(
      signer: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      validMeasurements: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      timestamp: PromiseOrValue<BigNumberish>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    callFunction(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    functionCallSettings(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    functionCalls(
      callId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getActiveFunctionCallsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setFunctionCallSettings(
      functionId: PromiseOrValue<string>,
      requireEstimatedRunCostFee: PromiseOrValue<boolean>,
      minimumFee: PromiseOrValue<BigNumberish>,
      maxGasCost: PromiseOrValue<BigNumberish>,
      requireCallerPayFullCost: PromiseOrValue<boolean>,
      requireSenderBeReturnAddress: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    functionSettings(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setFunctionSettings(
      functionId: PromiseOrValue<string>,
      settings: FunctionSettingsLib.FunctionSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    failFunctionResult(
      params: FunctionVerifyLib.FunctionFailParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    verifyFunctionResult(
      params: FunctionVerifyLib.FunctionVerifyParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createOracle(
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createOracleWithId(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oracleGarbageCollect(
      oracleId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oracleHeartbeat(
      oracleId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oracles(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rotateOracleSigner(
      oracleId: PromiseOrValue<string>,
      newSigner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleConfig(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addMrEnclaveToOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createOracleQueue(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getOracleIdx(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOracleQueueAllowedMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOracles(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oracleQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    queueAttestationConfigs(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeMrEnclaveFromOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleQueueAttestationConfig(
      queueId: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      mrEnclaves: PromiseOrValue<BytesLike>[],
      requireValidEnclave: PromiseOrValue<boolean>,
      requireHeartbeatPermission: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleQueueConfig(
      queueId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracleQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getActiveRequestsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRequestsByFunctionId(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    requestFund(
      requestId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    requestWithdrawal(
      requestId: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    requests(
      requestId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sendDelayedRequest(
      requestId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      startAfter: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    sendRequest(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    sendRequestWithId(
      requestId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createRoutineWithId(
      routineId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getActiveRoutinesByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoutinesByAuthority(
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoutinesByFunctionId(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    routineEscrowFund(
      routineId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    routineEscrowWithdraw(
      routineId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    routineExists(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    routines(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateRoutine(
      routineId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createFunction(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createFunctionWithId(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forward(
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    functionEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    functionEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    functionVerify(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    functionVerifyRequest(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      functionCallIds: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFunctionConfig(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFunctionDeactivated(
      functionId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setToleratedTimestampDiscrepancy(
      tolerance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addMrEnclaveToFunction(
      functionId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeMrEnclaveFromFunction(
      functionId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimatedRunCost(
      functionId: PromiseOrValue<string>,
      gasPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    funcs(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    functionExists(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getActiveFunctionsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllFunctions(overrides?: CallOverrides): Promise<BigNumber>;

    getFunctionMrEnclaves(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFunctionPermittedCallers(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFunctionsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTransactionHash(
      expirationTimeSeconds: PromiseOrValue<BigNumberish>,
      gasLimit: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTrustedForwarder(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    approve(
      spender: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addStake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getStakeForEnclave(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStakeForEnclaveWithToken(
      enclaveId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStakingConfig(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    prepareUnstake(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    recoverStakeWithToken(
      enclaveId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakingConfig(
      queueId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      stakingAmount: PromiseOrValue<BigNumberish>,
      stakingPeriod: PromiseOrValue<BigNumberish>,
      unstakingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    slashStake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    totalStaked(
      queueId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unstake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isAdmin(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isAllowed(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setAdmin(
      sender: PromiseOrValue<string>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAllowed(
      sender: PromiseOrValue<string>,
      status: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    aggregatorEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    aggregatorEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      aggregatorId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    aggregatorHistory(
      aggregatorId: PromiseOrValue<string>,
      roundId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    aggregators(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createAggregator(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAggregatorsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllAggregators(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCurrentIntervalId(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getIntervalResult(
      aggregatorId: PromiseOrValue<string>,
      intervalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    latestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    openInterval(
      aggregatorId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    saveResults(
      ids: PromiseOrValue<string>[],
      results: PromiseOrValue<BigNumberish>[],
      queueId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAggregatorConfig(
      aggregatorId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      batchSize: PromiseOrValue<BigNumberish>,
      minUpdateDelaySeconds: PromiseOrValue<BigNumberish>,
      minOracleResults: PromiseOrValue<BigNumberish>,
      jobsHash: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      varianceThreshold: PromiseOrValue<BigNumberish>,
      minJobResults: PromiseOrValue<BigNumberish>,
      forceReportPeriod: PromiseOrValue<BigNumberish>,
      enableHistory: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    viewAggregatorResults(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    viewLatestResult(
      aggregatorId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addMrEnclaveToAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    attestationQueueHasMrEnclave(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    attestationQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createAttestationQueue(
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAttestationQueueMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getEnclaveIdx(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeMrEnclaveFromAttestationQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAttestationQueueConfig(
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      enclaveTimeout: PromiseOrValue<BigNumberish>,
      maxEnclaveVerificationAge: PromiseOrValue<BigNumberish>,
      allowAuthorityOverrideAfter: PromiseOrValue<BigNumberish>,
      requireAuthorityHeartbeatPermission: PromiseOrValue<boolean>,
      requireUsagePermissions: PromiseOrValue<boolean>,
      maxConsecutiveFunctionFailures: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAttestationQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    callBalances(
      callIds: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyCallbackParams(
      callIds: PromiseOrValue<string>[],
      hashes: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    diamondCut(
      _diamondCut: IDiamondCut.FacetCutStruct[],
      _init: PromiseOrValue<string>,
      _calldata: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    facetAddress(
      _functionSelector: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    facetAddresses(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    facetFunctionSelectors(
      _facet: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    facets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(
      _interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      _newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createEnclave(
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createEnclaveWithId(
      enclaveId: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enclaveGarbageCollect(
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enclaveHeartbeat(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enclaveSignerToEnclaveId(
      signer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    enclaves(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    failEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      verifierIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceOverrideVerify(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isEnclaveValid(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rotateEnclaveSigner(
      enclaveId: PromiseOrValue<string>,
      newSigner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateEnclave(
      enclaveId: PromiseOrValue<string>,
      cid: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    validate(
      signer: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      validMeasurements: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyEnclave(
      verifierId: PromiseOrValue<string>,
      enclaveId: PromiseOrValue<string>,
      enclaveIdx: PromiseOrValue<BigNumberish>,
      timestamp: PromiseOrValue<BigNumberish>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    callFunction(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    functionCallSettings(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    functionCalls(
      callId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getActiveFunctionCallsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setFunctionCallSettings(
      functionId: PromiseOrValue<string>,
      requireEstimatedRunCostFee: PromiseOrValue<boolean>,
      minimumFee: PromiseOrValue<BigNumberish>,
      maxGasCost: PromiseOrValue<BigNumberish>,
      requireCallerPayFullCost: PromiseOrValue<boolean>,
      requireSenderBeReturnAddress: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    functionSettings(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setFunctionSettings(
      functionId: PromiseOrValue<string>,
      settings: FunctionSettingsLib.FunctionSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    failFunctionResult(
      params: FunctionVerifyLib.FunctionFailParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    verifyFunctionResult(
      params: FunctionVerifyLib.FunctionVerifyParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createOracle(
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createOracleWithId(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oracleGarbageCollect(
      oracleId: PromiseOrValue<string>,
      oracleIdx: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oracleHeartbeat(
      oracleId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oracles(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rotateOracleSigner(
      oracleId: PromiseOrValue<string>,
      newSigner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleConfig(
      oracleId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      signer: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addMrEnclaveToOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createOracleQueue(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getOracleIdx(
      oracleId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOracleQueueAllowedMrEnclaves(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOracles(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oracleQueues(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    queueAttestationConfigs(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeMrEnclaveFromOracleQueue(
      queueId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleQueueAttestationConfig(
      queueId: PromiseOrValue<string>,
      attestationQueueId: PromiseOrValue<string>,
      mrEnclaves: PromiseOrValue<BytesLike>[],
      requireValidEnclave: PromiseOrValue<boolean>,
      requireHeartbeatPermission: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleQueueConfig(
      queueId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      unpermissionedFeedsEnabled: PromiseOrValue<boolean>,
      maxSize: PromiseOrValue<BigNumberish>,
      reward: PromiseOrValue<BigNumberish>,
      oracleTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracleQueuePermission(
      queueId: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      on: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasPermission(
      granter: PromiseOrValue<string>,
      grantee: PromiseOrValue<string>,
      permission: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getActiveRequestsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRequestsByFunctionId(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    requestFund(
      requestId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    requestWithdrawal(
      requestId: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    requests(
      requestId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    sendDelayedRequest(
      requestId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      startAfter: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    sendRequest(
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    sendRequestWithId(
      requestId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createRoutineWithId(
      routineId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getActiveRoutinesByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoutinesByAuthority(
      authority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoutinesByFunctionId(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    routineEscrowFund(
      routineId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    routineEscrowWithdraw(
      routineId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    routineExists(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    routines(
      routineId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    updateRoutine(
      routineId: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      params: PromiseOrValue<BytesLike>,
      schedule: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createFunction(
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createFunctionWithId(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      queueId: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forward(
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    functionEscrowFund(
      accountId: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    functionEscrowWithdraw(
      recipient: PromiseOrValue<string>,
      functionId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    functionVerify(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    functionVerifyRequest(
      enclaveIdx: PromiseOrValue<BigNumberish>,
      functionId: PromiseOrValue<string>,
      delegatedSignerAddress: PromiseOrValue<string>,
      observedTime: PromiseOrValue<BigNumberish>,
      nextAllowedTimestamp: PromiseOrValue<BigNumberish>,
      isFailure: PromiseOrValue<boolean>,
      mrEnclave: PromiseOrValue<BytesLike>,
      transactions: TransactionLib.TransactionStruct[],
      signatures: PromiseOrValue<BytesLike>[],
      functionCallIds: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFunctionConfig(
      functionId: PromiseOrValue<string>,
      name: PromiseOrValue<string>,
      authority: PromiseOrValue<string>,
      containerRegistry: PromiseOrValue<string>,
      container: PromiseOrValue<string>,
      version: PromiseOrValue<string>,
      schedule: PromiseOrValue<string>,
      paramsSchema: PromiseOrValue<string>,
      permittedCallers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFunctionDeactivated(
      functionId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setToleratedTimestampDiscrepancy(
      tolerance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addMrEnclaveToFunction(
      functionId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeMrEnclaveFromFunction(
      functionId: PromiseOrValue<string>,
      mrEnclave: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimatedRunCost(
      functionId: PromiseOrValue<string>,
      gasPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    funcs(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    functionExists(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getActiveFunctionsByQueue(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllFunctions(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getFunctionMrEnclaves(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFunctionPermittedCallers(
      functionId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFunctionsByAuthority(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTransactionHash(
      expirationTimeSeconds: PromiseOrValue<BigNumberish>,
      gasLimit: PromiseOrValue<BigNumberish>,
      value: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTrustedForwarder(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    approve(
      spender: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addStake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getStakeForEnclave(
      enclaveId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStakeForEnclaveWithToken(
      enclaveId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStakingConfig(
      queueId: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    prepareUnstake(
      enclaveId: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    recoverStakeWithToken(
      enclaveId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakingConfig(
      queueId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      stakingAmount: PromiseOrValue<BigNumberish>,
      stakingPeriod: PromiseOrValue<BigNumberish>,
      unstakingPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    slashStake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    totalStaked(
      queueId: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unstake(
      enclaveId: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
